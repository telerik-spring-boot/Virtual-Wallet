((e, t) => {
    "object" == typeof module && "object" == typeof module.exports ? module.exports = e.document ? t(e, !0) : function (e) {
        if (e.document) return t(e);
        throw new Error("jQuery requires a window with a document")
    } : t(e)
})("undefined" != typeof window ? window : this, function (k, X) {
    function b(e) {
        return "function" == typeof e && "number" != typeof e.nodeType && "function" != typeof e.item
    }

    function N(e) {
        return null != e && e === e.window
    }

    var t = [], F = Object.getPrototypeOf, o = t.slice, H = t.flat ? function (e) {
            return t.flat.call(e)
        } : function (e) {
            return t.concat.apply([], e)
        }, R = t.push, y = t.indexOf, Y = {}, W = Y.toString, B = Y.hasOwnProperty, j = B.toString, G = j.call(Object),
        f = {}, A = k.document, V = {type: !0, src: !0, nonce: !0, noModule: !0};

    function q(e, t, i) {
        var s, a, n = (i = i || A).createElement("script");
        if (n.text = e, t) for (s in V) (a = t[s] || t.getAttribute && t.getAttribute(s)) && n.setAttribute(s, a);
        i.head.appendChild(n).parentNode.removeChild(n)
    }

    function U(e) {
        return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? Y[W.call(e)] || "object" : typeof e
    }

    var e = "3.7.1", Z = /HTML$/i, C = function (e, t) {
        return new C.fn.init(e, t)
    };

    function $(e) {
        var t = !!e && "length" in e && e.length, i = U(e);
        return !b(e) && !N(e) && ("array" === i || 0 === t || "number" == typeof t && 0 < t && t - 1 in e)
    }

    function v(e, t) {
        return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase()
    }

    C.fn = C.prototype = {
        jquery: e, constructor: C, length: 0, toArray: function () {
            return o.call(this)
        }, get: function (e) {
            return null == e ? o.call(this) : e < 0 ? this[e + this.length] : this[e]
        }, pushStack: function (e) {
            e = C.merge(this.constructor(), e);
            return e.prevObject = this, e
        }, each: function (e) {
            return C.each(this, e)
        }, map: function (i) {
            return this.pushStack(C.map(this, function (e, t) {
                return i.call(e, t, e)
            }))
        }, slice: function () {
            return this.pushStack(o.apply(this, arguments))
        }, first: function () {
            return this.eq(0)
        }, last: function () {
            return this.eq(-1)
        }, even: function () {
            return this.pushStack(C.grep(this, function (e, t) {
                return (t + 1) % 2
            }))
        }, odd: function () {
            return this.pushStack(C.grep(this, function (e, t) {
                return t % 2
            }))
        }, eq: function (e) {
            var t = this.length, e = +e + (e < 0 ? t : 0);
            return this.pushStack(0 <= e && e < t ? [this[e]] : [])
        }, end: function () {
            return this.prevObject || this.constructor()
        }, push: R, sort: t.sort, splice: t.splice
    }, C.extend = C.fn.extend = function () {
        var e, t, i, s, a, n = arguments[0] || {}, r = 1, o = arguments.length, l = !1;
        for ("boolean" == typeof n && (l = n, n = arguments[r] || {}, r++), "object" == typeof n || b(n) || (n = {}), r === o && (n = this, r--); r < o; r++) if (null != (e = arguments[r])) for (t in e) i = e[t], "__proto__" !== t && n !== i && (l && i && (C.isPlainObject(i) || (s = Array.isArray(i))) ? (a = n[t], a = s && !Array.isArray(a) ? [] : s || C.isPlainObject(a) ? a : {}, s = !1, n[t] = C.extend(l, a, i)) : void 0 !== i && (n[t] = i));
        return n
    }, C.extend({
        expando: "jQuery" + (e + Math.random()).replace(/\D/g, ""), isReady: !0, error: function (e) {
            throw new Error(e)
        }, noop: function () {
        }, isPlainObject: function (e) {
            return !(!e || "[object Object]" !== W.call(e) || (e = F(e)) && ("function" != typeof (e = B.call(e, "constructor") && e.constructor) || j.call(e) !== G))
        }, isEmptyObject: function (e) {
            for (var t in e) return !1;
            return !0
        }, globalEval: function (e, t, i) {
            q(e, {nonce: t && t.nonce}, i)
        }, each: function (e, t) {
            var i, s = 0;
            if ($(e)) for (i = e.length; s < i && !1 !== t.call(e[s], s, e[s]); s++) ; else for (s in e) if (!1 === t.call(e[s], s, e[s])) break;
            return e
        }, text: function (e) {
            var t, i = "", s = 0, a = e.nodeType;
            if (!a) for (; t = e[s++];) i += C.text(t);
            return 1 === a || 11 === a ? e.textContent : 9 === a ? e.documentElement.textContent : 3 === a || 4 === a ? e.nodeValue : i
        }, makeArray: function (e, t) {
            t = t || [];
            return null != e && ($(Object(e)) ? C.merge(t, "string" == typeof e ? [e] : e) : R.call(t, e)), t
        }, inArray: function (e, t, i) {
            return null == t ? -1 : y.call(t, e, i)
        }, isXMLDoc: function (e) {
            var t = e && e.namespaceURI, e = e && (e.ownerDocument || e).documentElement;
            return !Z.test(t || e && e.nodeName || "HTML")
        }, merge: function (e, t) {
            for (var i = +t.length, s = 0, a = e.length; s < i; s++) e[a++] = t[s];
            return e.length = a, e
        }, grep: function (e, t, i) {
            for (var s = [], a = 0, n = e.length, r = !i; a < n; a++) !t(e[a], a) != r && s.push(e[a]);
            return s
        }, map: function (e, t, i) {
            var s, a, n = 0, r = [];
            if ($(e)) for (s = e.length; n < s; n++) null != (a = t(e[n], n, i)) && r.push(a); else for (n in e) null != (a = t(e[n], n, i)) && r.push(a);
            return H(r)
        }, guid: 1, support: f
    }), "function" == typeof Symbol && (C.fn[Symbol.iterator] = t[Symbol.iterator]), C.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (e, t) {
        Y["[object " + t + "]"] = t.toLowerCase()
    });
    var Q = t.pop, K = t.sort, J = t.splice, i = "[\\x20\\t\\r\\n\\f]",
        ee = new RegExp("^" + i + "+|((?:^|[^\\\\])(?:\\\\.)*)" + i + "+$", "g"), te = (C.contains = function (e, t) {
            t = t && t.parentNode;
            return e === t || !(!t || 1 !== t.nodeType || !(e.contains ? e.contains(t) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(t)))
        }, /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g);

    function ie(e, t) {
        return t ? "\0" === e ? "ï¿½" : e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " " : "\\" + e
    }

    C.escapeSelector = function (e) {
        return (e + "").replace(te, ie)
    };
    var se, w, ae, ne, re, S, s, L, u, oe, a = A, le = R, T = le, E = C.expando, P = 0, ce = 0, he = Pe(), de = Pe(),
        ue = Pe(), ge = Pe(), pe = function (e, t) {
            return e === t && (re = !0), 0
        },
        fe = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
        e = "(?:\\\\[\\da-fA-F]{1,6}" + i + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
        n = "\\[" + i + "*(" + e + ")(?:" + i + "*([*^$|!~]?=)" + i + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + e + "))|)" + i + "*\\]",
        r = ":(" + e + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + n + ")*)|.*)\\)|)",
        xe = new RegExp(i + "+", "g"), me = new RegExp("^" + i + "*," + i + "*"),
        be = new RegExp("^" + i + "*([>+~]|" + i + ")" + i + "*"), ve = new RegExp(i + "|>"), ye = new RegExp(r),
        we = new RegExp("^" + e + "$"), ke = {
            ID: new RegExp("^#(" + e + ")"),
            CLASS: new RegExp("^\\.(" + e + ")"),
            TAG: new RegExp("^(" + e + "|[*])"),
            ATTR: new RegExp("^" + n),
            PSEUDO: new RegExp("^" + r),
            CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + i + "*(even|odd|(([+-]|)(\\d*)n|)" + i + "*(?:([+-]|)" + i + "*(\\d+)|))" + i + "*\\)|)", "i"),
            bool: new RegExp("^(?:" + fe + ")$", "i"),
            needsContext: new RegExp("^" + i + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + i + "*((?:-\\d)?\\d*)" + i + "*\\)|)(?=[^-]|$)", "i")
        }, Ae = /^(?:input|select|textarea|button)$/i, Ce = /^h\d$/i, Se = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, Le = /[+~]/,
        d = new RegExp("\\\\[\\da-fA-F]{1,6}" + i + "?|\\\\([^\\r\\n\\f])", "g"), g = function (e, t) {
            e = "0x" + e.slice(1) - 65536;
            return t || (e < 0 ? String.fromCharCode(65536 + e) : String.fromCharCode(e >> 10 | 55296, 1023 & e | 56320))
        }, Te = function () {
            De()
        }, Ee = Fe(function (e) {
            return !0 === e.disabled && v(e, "fieldset")
        }, {dir: "parentNode", next: "legend"});
    try {
        T.apply(t = o.call(a.childNodes), a.childNodes), t[a.childNodes.length].nodeType
    } catch (se) {
        T = {
            apply: function (e, t) {
                le.apply(e, o.call(t))
            }, call: function (e) {
                le.apply(e, o.call(arguments, 1))
            }
        }
    }

    function _(e, t, i, s) {
        var a, n, r, o, l, c, h = t && t.ownerDocument, d = t ? t.nodeType : 9;
        if (i = i || [], "string" != typeof e || !e || 1 !== d && 9 !== d && 11 !== d) return i;
        if (!s && (De(t), t = t || S, L)) {
            if (11 !== d && (o = Se.exec(e))) if (a = o[1]) {
                if (9 === d) {
                    if (!(c = t.getElementById(a))) return i;
                    if (c.id === a) return T.call(i, c), i
                } else if (h && (c = h.getElementById(a)) && _.contains(t, c) && c.id === a) return T.call(i, c), i
            } else {
                if (o[2]) return T.apply(i, t.getElementsByTagName(e)), i;
                if ((a = o[3]) && t.getElementsByClassName) return T.apply(i, t.getElementsByClassName(a)), i
            }
            if (!(ge[e + " "] || u && u.test(e))) {
                if (c = e, h = t, 1 === d && (ve.test(e) || be.test(e))) {
                    for ((h = Le.test(e) && Oe(t.parentNode) || t) == t && f.scope || ((r = t.getAttribute("id")) ? r = C.escapeSelector(r) : t.setAttribute("id", r = E)), n = (l = Xe(e)).length; n--;) l[n] = (r ? "#" + r : ":scope") + " " + Ne(l[n]);
                    c = l.join(",")
                }
                try {
                    return T.apply(i, h.querySelectorAll(c)), i
                } catch (t) {
                    ge(e, !0)
                } finally {
                    r === E && t.removeAttribute("id")
                }
            }
        }
        return Be(e.replace(ee, "$1"), t, i, s)
    }

    function Pe() {
        var s = [];
        return function e(t, i) {
            return s.push(t + " ") > w.cacheLength && delete e[s.shift()], e[t + " "] = i
        }
    }

    function l(e) {
        return e[E] = !0, e
    }

    function _e(e) {
        var t = S.createElement("fieldset");
        try {
            return !!e(t)
        } catch (e) {
            return !1
        } finally {
            t.parentNode && t.parentNode.removeChild(t)
        }
    }

    function Me(t) {
        return function (e) {
            return "form" in e ? e.parentNode && !1 === e.disabled ? "label" in e ? "label" in e.parentNode ? e.parentNode.disabled === t : e.disabled === t : e.isDisabled === t || e.isDisabled !== !t && Ee(e) === t : e.disabled === t : "label" in e && e.disabled === t
        }
    }

    function Ie(r) {
        return l(function (n) {
            return n = +n, l(function (e, t) {
                for (var i, s = r([], e.length, n), a = s.length; a--;) e[i = s[a]] && (e[i] = !(t[i] = e[i]))
            })
        })
    }

    function Oe(e) {
        return e && void 0 !== e.getElementsByTagName && e
    }

    function De(e) {
        var e = e ? e.ownerDocument || e : a;
        return e != S && 9 === e.nodeType && e.documentElement && (s = (S = e).documentElement, L = !C.isXMLDoc(S), oe = s.matches || s.webkitMatchesSelector || s.msMatchesSelector, s.msMatchesSelector && a != S && (e = S.defaultView) && e.top !== e && e.addEventListener("unload", Te), f.getById = _e(function (e) {
            return s.appendChild(e).id = C.expando, !S.getElementsByName || !S.getElementsByName(C.expando).length
        }), f.disconnectedMatch = _e(function (e) {
            return oe.call(e, "*")
        }), f.scope = _e(function () {
            return S.querySelectorAll(":scope")
        }), f.cssHas = _e(function () {
            try {
                return S.querySelector(":has(*,:jqfake)"), 0
            } catch (e) {
                return 1
            }
        }), f.getById ? (w.filter.ID = function (e) {
            var t = e.replace(d, g);
            return function (e) {
                return e.getAttribute("id") === t
            }
        }, w.find.ID = function (e, t) {
            if (void 0 !== t.getElementById && L) return (t = t.getElementById(e)) ? [t] : []
        }) : (w.filter.ID = function (e) {
            var t = e.replace(d, g);
            return function (e) {
                e = void 0 !== e.getAttributeNode && e.getAttributeNode("id");
                return e && e.value === t
            }
        }, w.find.ID = function (e, t) {
            if (void 0 !== t.getElementById && L) {
                var i, s, a, n = t.getElementById(e);
                if (n) {
                    if ((i = n.getAttributeNode("id")) && i.value === e) return [n];
                    for (a = t.getElementsByName(e), s = 0; n = a[s++];) if ((i = n.getAttributeNode("id")) && i.value === e) return [n]
                }
                return []
            }
        }), w.find.TAG = function (e, t) {
            return void 0 !== t.getElementsByTagName ? t.getElementsByTagName(e) : t.querySelectorAll(e)
        }, w.find.CLASS = function (e, t) {
            if (void 0 !== t.getElementsByClassName && L) return t.getElementsByClassName(e)
        }, u = [], _e(function (e) {
            var t;
            s.appendChild(e).innerHTML = "<a id='" + E + "' href='' disabled='disabled'></a><select id='" + E + "-\r\\' disabled='disabled'><option selected=''></option></select>", e.querySelectorAll("[selected]").length || u.push("\\[" + i + "*(?:value|" + fe + ")"), e.querySelectorAll("[id~=" + E + "-]").length || u.push("~="), e.querySelectorAll("a#" + E + "+*").length || u.push(".#.+[+~]"), e.querySelectorAll(":checked").length || u.push(":checked"), (t = S.createElement("input")).setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), s.appendChild(e).disabled = !0, 2 !== e.querySelectorAll(":disabled").length && u.push(":enabled", ":disabled"), (t = S.createElement("input")).setAttribute("name", ""), e.appendChild(t), e.querySelectorAll("[name='']").length || u.push("\\[" + i + "*name" + i + "*=" + i + "*(?:''|\"\")")
        }), f.cssHas || u.push(":has"), u = u.length && new RegExp(u.join("|")), pe = function (e, t) {
            var i;
            return e === t ? (re = !0, 0) : !e.compareDocumentPosition - !t.compareDocumentPosition || (1 & (i = (e.ownerDocument || e) == (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !f.sortDetached && t.compareDocumentPosition(e) === i ? e === S || e.ownerDocument == a && _.contains(a, e) ? -1 : t === S || t.ownerDocument == a && _.contains(a, t) ? 1 : ne ? y.call(ne, e) - y.call(ne, t) : 0 : 4 & i ? -1 : 1)
        }), S
    }

    for (se in _.matches = function (e, t) {
        return _(e, null, null, t)
    }, _.matchesSelector = function (e, t) {
        if (De(e), L && !ge[t + " "] && (!u || !u.test(t))) try {
            var i = oe.call(e, t);
            if (i || f.disconnectedMatch || e.document && 11 !== e.document.nodeType) return i
        } catch (e) {
            ge(t, !0)
        }
        return 0 < _(t, S, null, [e]).length
    }, _.contains = function (e, t) {
        return (e.ownerDocument || e) != S && De(e), C.contains(e, t)
    }, _.attr = function (e, t) {
        (e.ownerDocument || e) != S && De(e);
        var i = w.attrHandle[t.toLowerCase()], i = i && B.call(w.attrHandle, t.toLowerCase()) ? i(e, t, !L) : void 0;
        return void 0 !== i ? i : e.getAttribute(t)
    }, _.error = function (e) {
        throw new Error("Syntax error, unrecognized expression: " + e)
    }, C.uniqueSort = function (e) {
        var t, i = [], s = 0, a = 0;
        if (re = !f.sortStable, ne = !f.sortStable && o.call(e, 0), K.call(e, pe), re) {
            for (; t = e[a++];) t === e[a] && (s = i.push(a));
            for (; s--;) J.call(e, i[s], 1)
        }
        return ne = null, e
    }, C.fn.uniqueSort = function () {
        return this.pushStack(C.uniqueSort(o.apply(this)))
    }, (w = C.expr = {
        cacheLength: 50,
        createPseudo: l,
        match: ke,
        attrHandle: {},
        find: {},
        relative: {
            ">": {dir: "parentNode", first: !0},
            " ": {dir: "parentNode"},
            "+": {dir: "previousSibling", first: !0},
            "~": {dir: "previousSibling"}
        },
        preFilter: {
            ATTR: function (e) {
                return e[1] = e[1].replace(d, g), e[3] = (e[3] || e[4] || e[5] || "").replace(d, g), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4)
            }, CHILD: function (e) {
                return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || _.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && _.error(e[0]), e
            }, PSEUDO: function (e) {
                var t, i = !e[6] && e[2];
                return ke.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : i && ye.test(i) && (t = (t = Xe(i, !0)) && i.indexOf(")", i.length - t) - i.length) && (e[0] = e[0].slice(0, t), e[2] = i.slice(0, t)), e.slice(0, 3))
            }
        },
        filter: {
            TAG: function (e) {
                var t = e.replace(d, g).toLowerCase();
                return "*" === e ? function () {
                    return !0
                } : function (e) {
                    return v(e, t)
                }
            }, CLASS: function (e) {
                var t = he[e + " "];
                return t || (t = new RegExp("(^|" + i + ")" + e + "(" + i + "|$)")) && he(e, function (e) {
                    return t.test("string" == typeof e.className && e.className || void 0 !== e.getAttribute && e.getAttribute("class") || "")
                })
            }, ATTR: function (t, i, s) {
                return function (e) {
                    e = _.attr(e, t);
                    return null == e ? "!=" === i : !i || (e += "", "=" === i ? e === s : "!=" === i ? e !== s : "^=" === i ? s && 0 === e.indexOf(s) : "*=" === i ? s && -1 < e.indexOf(s) : "$=" === i ? s && e.slice(-s.length) === s : "~=" === i ? -1 < (" " + e.replace(xe, " ") + " ").indexOf(s) : "|=" === i && (e === s || e.slice(0, s.length + 1) === s + "-"))
                }
            }, CHILD: function (g, e, t, p, f) {
                var x = "nth" !== g.slice(0, 3), m = "last" !== g.slice(-4), b = "of-type" === e;
                return 1 === p && 0 === f ? function (e) {
                    return !!e.parentNode
                } : function (e, t, i) {
                    var s, a, n, r, o, l = x != m ? "nextSibling" : "previousSibling", c = e.parentNode,
                        h = b && e.nodeName.toLowerCase(), d = !i && !b, u = !1;
                    if (c) {
                        if (x) {
                            for (; l;) {
                                for (n = e; n = n[l];) if (b ? v(n, h) : 1 === n.nodeType) return !1;
                                o = l = "only" === g && !o && "nextSibling"
                            }
                            return !0
                        }
                        if (o = [m ? c.firstChild : c.lastChild], m && d) {
                            for (u = (r = (s = (a = c[E] || (c[E] = {}))[g] || [])[0] === P && s[1]) && s[2], n = r && c.childNodes[r]; n = ++r && n && n[l] || (u = r = 0, o.pop());) if (1 === n.nodeType && ++u && n === e) {
                                a[g] = [P, r, u];
                                break
                            }
                        } else if (!1 === (u = d ? r = (s = (a = e[E] || (e[E] = {}))[g] || [])[0] === P && s[1] : u)) for (; (n = ++r && n && n[l] || (u = r = 0, o.pop())) && ((b ? !v(n, h) : 1 !== n.nodeType) || !++u || (d && ((a = n[E] || (n[E] = {}))[g] = [P, u]), n !== e));) ;
                        return (u -= f) === p || u % p == 0 && 0 <= u / p
                    }
                }
            }, PSEUDO: function (e, n) {
                var t, r = w.pseudos[e] || w.setFilters[e.toLowerCase()] || _.error("unsupported pseudo: " + e);
                return r[E] ? r(n) : 1 < r.length ? (t = [e, e, "", n], w.setFilters.hasOwnProperty(e.toLowerCase()) ? l(function (e, t) {
                    for (var i, s = r(e, n), a = s.length; a--;) e[i = y.call(e, s[a])] = !(t[i] = s[a])
                }) : function (e) {
                    return r(e, 0, t)
                }) : r
            }
        },
        pseudos: {
            not: l(function (e) {
                var s = [], a = [], o = We(e.replace(ee, "$1"));
                return o[E] ? l(function (e, t, i, s) {
                    for (var a, n = o(e, null, s, []), r = e.length; r--;) (a = n[r]) && (e[r] = !(t[r] = a))
                }) : function (e, t, i) {
                    return s[0] = e, o(s, null, i, a), s[0] = null, !a.pop()
                }
            }), has: l(function (t) {
                return function (e) {
                    return 0 < _(t, e).length
                }
            }), contains: l(function (t) {
                return t = t.replace(d, g), function (e) {
                    return -1 < (e.textContent || C.text(e)).indexOf(t)
                }
            }), lang: l(function (i) {
                return we.test(i || "") || _.error("unsupported lang: " + i), i = i.replace(d, g).toLowerCase(), function (e) {
                    var t;
                    do {
                        if (t = L ? e.lang : e.getAttribute("xml:lang") || e.getAttribute("lang")) return (t = t.toLowerCase()) === i || 0 === t.indexOf(i + "-")
                    } while ((e = e.parentNode) && 1 === e.nodeType);
                    return !1
                }
            }), target: function (e) {
                var t = k.location && k.location.hash;
                return t && t.slice(1) === e.id
            }, root: function (e) {
                return e === s
            }, focus: function (e) {
                return e === (() => {
                    try {
                        return S.activeElement
                    } catch (e) {
                    }
                })() && S.hasFocus() && !!(e.type || e.href || ~e.tabIndex)
            }, enabled: Me(!1), disabled: Me(!0), checked: function (e) {
                return v(e, "input") && !!e.checked || v(e, "option") && !!e.selected
            }, selected: function (e) {
                return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected
            }, empty: function (e) {
                for (e = e.firstChild; e; e = e.nextSibling) if (e.nodeType < 6) return !1;
                return !0
            }, parent: function (e) {
                return !w.pseudos.empty(e)
            }, header: function (e) {
                return Ce.test(e.nodeName)
            }, input: function (e) {
                return Ae.test(e.nodeName)
            }, button: function (e) {
                return v(e, "input") && "button" === e.type || v(e, "button")
            }, text: function (e) {
                return v(e, "input") && "text" === e.type && (null == (e = e.getAttribute("type")) || "text" === e.toLowerCase())
            }, first: Ie(function () {
                return [0]
            }), last: Ie(function (e, t) {
                return [t - 1]
            }), eq: Ie(function (e, t, i) {
                return [i < 0 ? i + t : i]
            }), even: Ie(function (e, t) {
                for (var i = 0; i < t; i += 2) e.push(i);
                return e
            }), odd: Ie(function (e, t) {
                for (var i = 1; i < t; i += 2) e.push(i);
                return e
            }), lt: Ie(function (e, t, i) {
                for (var s = i < 0 ? i + t : t < i ? t : i; 0 <= --s;) e.push(s);
                return e
            }), gt: Ie(function (e, t, i) {
                for (var s = i < 0 ? i + t : i; ++s < t;) e.push(s);
                return e
            })
        }
    }).pseudos.nth = w.pseudos.eq, {
        radio: !0,
        checkbox: !0,
        file: !0,
        password: !0,
        image: !0
    }) w.pseudos[se] = (t => function (e) {
        return v(e, "input") && e.type === t
    })(se);
    for (se in {submit: !0, reset: !0}) w.pseudos[se] = (t => function (e) {
        return (v(e, "input") || v(e, "button")) && e.type === t
    })(se);

    function ze() {
    }

    function Xe(e, t) {
        var i, s, a, n, r, o, l, c = de[e + " "];
        if (c) return t ? 0 : c.slice(0);
        for (r = e, o = [], l = w.preFilter; r;) {
            for (n in i && !(s = me.exec(r)) || (s && (r = r.slice(s[0].length) || r), o.push(a = [])), i = !1, (s = be.exec(r)) && (i = s.shift(), a.push({
                value: i,
                type: s[0].replace(ee, " ")
            }), r = r.slice(i.length)), w.filter) !(s = ke[n].exec(r)) || l[n] && !(s = l[n](s)) || (i = s.shift(), a.push({
                value: i,
                type: n,
                matches: s
            }), r = r.slice(i.length));
            if (!i) break
        }
        return t ? r.length : r ? _.error(e) : de(e, o).slice(0)
    }

    function Ne(e) {
        for (var t = 0, i = e.length, s = ""; t < i; t++) s += e[t].value;
        return s
    }

    function Fe(r, e, t) {
        var o = e.dir, l = e.next, c = l || o, h = t && "parentNode" === c, d = ce++;
        return e.first ? function (e, t, i) {
            for (; e = e[o];) if (1 === e.nodeType || h) return r(e, t, i);
            return !1
        } : function (e, t, i) {
            var s, a, n = [P, d];
            if (i) {
                for (; e = e[o];) if ((1 === e.nodeType || h) && r(e, t, i)) return !0
            } else for (; e = e[o];) if (1 === e.nodeType || h) if (a = e[E] || (e[E] = {}), l && v(e, l)) e = e[o] || e; else {
                if ((s = a[c]) && s[0] === P && s[1] === d) return n[2] = s[2];
                if ((a[c] = n)[2] = r(e, t, i)) return !0
            }
            return !1
        }
    }

    function He(a) {
        return 1 < a.length ? function (e, t, i) {
            for (var s = a.length; s--;) if (!a[s](e, t, i)) return !1;
            return !0
        } : a[0]
    }

    function Re(e, t, i, s, a) {
        for (var n, r = [], o = 0, l = e.length, c = null != t; o < l; o++) !(n = e[o]) || i && !i(n, s, a) || (r.push(n), c && t.push(o));
        return r
    }

    function Ye(g, p, f, x, m, e) {
        return x && !x[E] && (x = Ye(x)), m && !m[E] && (m = Ye(m, e)), l(function (e, t, i, s) {
            var a, n, r, o, l = [], c = [], h = t.length, d = e || ((e, t, i) => {
                for (var s = 0, a = t.length; s < a; s++) _(e, t[s], i);
                return i
            })(p || "*", i.nodeType ? [i] : i, []), u = !g || !e && p ? d : Re(d, l, g, i, s);
            if (f ? f(u, o = m || (e ? g : h || x) ? [] : t, i, s) : o = u, x) for (a = Re(o, c), x(a, [], i, s), n = a.length; n--;) (r = a[n]) && (o[c[n]] = !(u[c[n]] = r));
            if (e) {
                if (m || g) {
                    if (m) {
                        for (a = [], n = o.length; n--;) (r = o[n]) && a.push(u[n] = r);
                        m(null, o = [], a, s)
                    }
                    for (n = o.length; n--;) (r = o[n]) && -1 < (a = m ? y.call(e, r) : l[n]) && (e[a] = !(t[a] = r))
                }
            } else o = Re(o === t ? o.splice(h, o.length) : o), m ? m(null, t, o, s) : T.apply(t, o)
        })
    }

    function We(e, t) {
        var i, x, m, b, v, s, a = [], n = [], r = ue[e + " "];
        if (!r) {
            for (i = (t = t || Xe(e)).length; i--;) ((r = function e(t) {
                for (var s, i, a, n = t.length, r = w.relative[t[0].type], o = r || w.relative[" "], l = r ? 1 : 0, c = Fe(function (e) {
                    return e === s
                }, o, !0), h = Fe(function (e) {
                    return -1 < y.call(s, e)
                }, o, !0), d = [function (e, t, i) {
                    return e = !r && (i || t != ae) || ((s = t).nodeType ? c : h)(e, t, i), s = null, e
                }]; l < n; l++) if (i = w.relative[t[l].type]) d = [Fe(He(d), i)]; else {
                    if ((i = w.filter[t[l].type].apply(null, t[l].matches))[E]) {
                        for (a = ++l; a < n && !w.relative[t[a].type]; a++) ;
                        return Ye(1 < l && He(d), 1 < l && Ne(t.slice(0, l - 1).concat({value: " " === t[l - 2].type ? "*" : ""})).replace(ee, "$1"), i, l < a && e(t.slice(l, a)), a < n && e(t = t.slice(a)), a < n && Ne(t))
                    }
                    d.push(i)
                }
                return He(d)
            }(t[i]))[E] ? a : n).push(r);
            (r = ue(e, (b = 0 < (m = a).length, v = 0 < (x = n).length, s = function (e, t, i, s, a) {
                var n, r, o, l = 0, c = "0", h = e && [], d = [], u = ae, g = e || v && w.find.TAG("*", a),
                    p = P += null == u ? 1 : Math.random() || .1, f = g.length;
                for (a && (ae = t == S || t || a); c !== f && null != (n = g[c]); c++) {
                    if (v && n) {
                        for (r = 0, t || n.ownerDocument == S || (De(n), i = !L); o = x[r++];) if (o(n, t || S, i)) {
                            T.call(s, n);
                            break
                        }
                        a && (P = p)
                    }
                    b && ((n = !o && n) && l--, e) && h.push(n)
                }
                if (l += c, b && c !== l) {
                    for (r = 0; o = m[r++];) o(h, d, t, i);
                    if (e) {
                        if (0 < l) for (; c--;) h[c] || d[c] || (d[c] = Q.call(s));
                        d = Re(d)
                    }
                    T.apply(s, d), a && !e && 0 < d.length && 1 < l + m.length && C.uniqueSort(s)
                }
                return a && (P = p, ae = u), h
            }, b ? l(s) : s))).selector = e
        }
        return r
    }

    function Be(e, t, i, s) {
        var a, n, r, o, l, c = "function" == typeof e && e, h = !s && Xe(e = c.selector || e);
        if (i = i || [], 1 === h.length) {
            if (2 < (n = h[0] = h[0].slice(0)).length && "ID" === (r = n[0]).type && 9 === t.nodeType && L && w.relative[n[1].type]) {
                if (!(t = (w.find.ID(r.matches[0].replace(d, g), t) || [])[0])) return i;
                c && (t = t.parentNode), e = e.slice(n.shift().value.length)
            }
            for (a = ke.needsContext.test(e) ? 0 : n.length; a-- && (r = n[a], !w.relative[o = r.type]);) if ((l = w.find[o]) && (s = l(r.matches[0].replace(d, g), Le.test(n[0].type) && Oe(t.parentNode) || t))) {
                if (n.splice(a, 1), e = s.length && Ne(n)) break;
                return T.apply(i, s), i
            }
        }
        return (c || We(e, h))(s, t, !L, i, !t || Le.test(e) && Oe(t.parentNode) || t), i
    }

    ze.prototype = w.filters = w.pseudos, w.setFilters = new ze, f.sortStable = E.split("").sort(pe).join("") === E, De(), f.sortDetached = _e(function (e) {
        return 1 & e.compareDocumentPosition(S.createElement("fieldset"))
    }), C.find = _, C.expr[":"] = C.expr.pseudos, C.unique = C.uniqueSort, _.compile = We, _.select = Be, _.setDocument = De, _.tokenize = Xe, _.escape = C.escapeSelector, _.getText = C.text, _.isXML = C.isXMLDoc, _.selectors = C.expr, _.support = C.support, _.uniqueSort = C.uniqueSort;

    function je(e, t, i) {
        for (var s = [], a = void 0 !== i; (e = e[t]) && 9 !== e.nodeType;) if (1 === e.nodeType) {
            if (a && C(e).is(i)) break;
            s.push(e)
        }
        return s
    }

    function Ge(e, t) {
        for (var i = []; e; e = e.nextSibling) 1 === e.nodeType && e !== t && i.push(e);
        return i
    }

    var Ve = C.expr.match.needsContext, qe = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;

    function Ue(e, i, s) {
        return b(i) ? C.grep(e, function (e, t) {
            return !!i.call(e, t, e) !== s
        }) : i.nodeType ? C.grep(e, function (e) {
            return e === i !== s
        }) : "string" != typeof i ? C.grep(e, function (e) {
            return -1 < y.call(i, e) !== s
        }) : C.filter(i, e, s)
    }

    C.filter = function (e, t, i) {
        var s = t[0];
        return i && (e = ":not(" + e + ")"), 1 === t.length && 1 === s.nodeType ? C.find.matchesSelector(s, e) ? [s] : [] : C.find.matches(e, C.grep(t, function (e) {
            return 1 === e.nodeType
        }))
    }, C.fn.extend({
        find: function (e) {
            var t, i, s = this.length, a = this;
            if ("string" != typeof e) return this.pushStack(C(e).filter(function () {
                for (t = 0; t < s; t++) if (C.contains(a[t], this)) return !0
            }));
            for (i = this.pushStack([]), t = 0; t < s; t++) C.find(e, a[t], i);
            return 1 < s ? C.uniqueSort(i) : i
        }, filter: function (e) {
            return this.pushStack(Ue(this, e || [], !1))
        }, not: function (e) {
            return this.pushStack(Ue(this, e || [], !0))
        }, is: function (e) {
            return !!Ue(this, "string" == typeof e && Ve.test(e) ? C(e) : e || [], !1).length
        }
    });
    var Ze, $e = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, Qe = ((C.fn.init = function (e, t, i) {
            if (e) {
                if (i = i || Ze, "string" != typeof e) return e.nodeType ? (this[0] = e, this.length = 1, this) : b(e) ? void 0 !== i.ready ? i.ready(e) : e(C) : C.makeArray(e, this);
                if (!(s = "<" === e[0] && ">" === e[e.length - 1] && 3 <= e.length ? [null, e, null] : $e.exec(e)) || !s[1] && t) return (!t || t.jquery ? t || i : this.constructor(t)).find(e);
                if (s[1]) {
                    if (t = t instanceof C ? t[0] : t, C.merge(this, C.parseHTML(s[1], t && t.nodeType ? t.ownerDocument || t : A, !0)), qe.test(s[1]) && C.isPlainObject(t)) for (var s in t) b(this[s]) ? this[s](t[s]) : this.attr(s, t[s])
                } else (i = A.getElementById(s[2])) && (this[0] = i, this.length = 1)
            }
            return this
        }).prototype = C.fn, Ze = C(A), /^(?:parents|prev(?:Until|All))/),
        Ke = {children: !0, contents: !0, next: !0, prev: !0};

    function Je(e, t) {
        for (; (e = e[t]) && 1 !== e.nodeType;) ;
        return e
    }

    C.fn.extend({
        has: function (e) {
            var t = C(e, this), i = t.length;
            return this.filter(function () {
                for (var e = 0; e < i; e++) if (C.contains(this, t[e])) return !0
            })
        }, closest: function (e, t) {
            var i, s = 0, a = this.length, n = [], r = "string" != typeof e && C(e);
            if (!Ve.test(e)) for (; s < a; s++) for (i = this[s]; i && i !== t; i = i.parentNode) if (i.nodeType < 11 && (r ? -1 < r.index(i) : 1 === i.nodeType && C.find.matchesSelector(i, e))) {
                n.push(i);
                break
            }
            return this.pushStack(1 < n.length ? C.uniqueSort(n) : n)
        }, index: function (e) {
            return e ? "string" == typeof e ? y.call(C(e), this[0]) : y.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
        }, add: function (e, t) {
            return this.pushStack(C.uniqueSort(C.merge(this.get(), C(e, t))))
        }, addBack: function (e) {
            return this.add(null == e ? this.prevObject : this.prevObject.filter(e))
        }
    }), C.each({
        parent: function (e) {
            e = e.parentNode;
            return e && 11 !== e.nodeType ? e : null
        }, parents: function (e) {
            return je(e, "parentNode")
        }, parentsUntil: function (e, t, i) {
            return je(e, "parentNode", i)
        }, next: function (e) {
            return Je(e, "nextSibling")
        }, prev: function (e) {
            return Je(e, "previousSibling")
        }, nextAll: function (e) {
            return je(e, "nextSibling")
        }, prevAll: function (e) {
            return je(e, "previousSibling")
        }, nextUntil: function (e, t, i) {
            return je(e, "nextSibling", i)
        }, prevUntil: function (e, t, i) {
            return je(e, "previousSibling", i)
        }, siblings: function (e) {
            return Ge((e.parentNode || {}).firstChild, e)
        }, children: function (e) {
            return Ge(e.firstChild)
        }, contents: function (e) {
            return null != e.contentDocument && F(e.contentDocument) ? e.contentDocument : (v(e, "template") && (e = e.content || e), C.merge([], e.childNodes))
        }
    }, function (s, a) {
        C.fn[s] = function (e, t) {
            var i = C.map(this, a, e);
            return (t = "Until" !== s.slice(-5) ? e : t) && "string" == typeof t && (i = C.filter(t, i)), 1 < this.length && (Ke[s] || C.uniqueSort(i), Qe.test(s)) && i.reverse(), this.pushStack(i)
        }
    });
    var M = /[^\x20\t\r\n\f]+/g;

    function et(e) {
        return e
    }

    function tt(e) {
        throw e
    }

    function it(e, t, i, s) {
        var a;
        try {
            e && b(a = e.promise) ? a.call(e).done(t).fail(i) : e && b(a = e.then) ? a.call(e, t, i) : t.apply(void 0, [e].slice(s))
        } catch (e) {
            i.apply(void 0, [e])
        }
    }

    C.Callbacks = function (s) {
        var e, i;
        s = "string" == typeof s ? (e = s, i = {}, C.each(e.match(M) || [], function (e, t) {
            i[t] = !0
        }), i) : C.extend({}, s);

        function a() {
            for (o = o || s.once, r = n = !0; c.length; h = -1) for (t = c.shift(); ++h < l.length;) !1 === l[h].apply(t[0], t[1]) && s.stopOnFalse && (h = l.length, t = !1);
            s.memory || (t = !1), n = !1, o && (l = t ? [] : "")
        }

        var n, t, r, o, l = [], c = [], h = -1, d = {
            add: function () {
                return l && (t && !n && (h = l.length - 1, c.push(t)), function i(e) {
                    C.each(e, function (e, t) {
                        b(t) ? s.unique && d.has(t) || l.push(t) : t && t.length && "string" !== U(t) && i(t)
                    })
                }(arguments), t) && !n && a(), this
            }, remove: function () {
                return C.each(arguments, function (e, t) {
                    for (var i; -1 < (i = C.inArray(t, l, i));) l.splice(i, 1), i <= h && h--
                }), this
            }, has: function (e) {
                return e ? -1 < C.inArray(e, l) : 0 < l.length
            }, empty: function () {
                return l = l && [], this
            }, disable: function () {
                return o = c = [], l = t = "", this
            }, disabled: function () {
                return !l
            }, lock: function () {
                return o = c = [], t || n || (l = t = ""), this
            }, locked: function () {
                return !!o
            }, fireWith: function (e, t) {
                return o || (t = [e, (t = t || []).slice ? t.slice() : t], c.push(t), n) || a(), this
            }, fire: function () {
                return d.fireWith(this, arguments), this
            }, fired: function () {
                return !!r
            }
        };
        return d
    }, C.extend({
        Deferred: function (e) {
            var n = [["notify", "progress", C.Callbacks("memory"), C.Callbacks("memory"), 2], ["resolve", "done", C.Callbacks("once memory"), C.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", C.Callbacks("once memory"), C.Callbacks("once memory"), 1, "rejected"]],
                a = "pending", r = {
                    state: function () {
                        return a
                    }, always: function () {
                        return o.done(arguments).fail(arguments), this
                    }, catch: function (e) {
                        return r.then(null, e)
                    }, pipe: function () {
                        var a = arguments;
                        return C.Deferred(function (s) {
                            C.each(n, function (e, t) {
                                var i = b(a[t[4]]) && a[t[4]];
                                o[t[1]](function () {
                                    var e = i && i.apply(this, arguments);
                                    e && b(e.promise) ? e.promise().progress(s.notify).done(s.resolve).fail(s.reject) : s[t[0] + "With"](this, i ? [e] : arguments)
                                })
                            }), a = null
                        }).promise()
                    }, then: function (t, i, s) {
                        var l = 0;

                        function c(a, n, r, o) {
                            return function () {
                                function e() {
                                    var e, t;
                                    if (!(a < l)) {
                                        if ((e = r.apply(i, s)) === n.promise()) throw new TypeError("Thenable self-resolution");
                                        t = e && ("object" == typeof e || "function" == typeof e) && e.then, b(t) ? o ? t.call(e, c(l, n, et, o), c(l, n, tt, o)) : (l++, t.call(e, c(l, n, et, o), c(l, n, tt, o), c(l, n, et, n.notifyWith))) : (r !== et && (i = void 0, s = [e]), (o || n.resolveWith)(i, s))
                                    }
                                }

                                var i = this, s = arguments, t = o ? e : function () {
                                    try {
                                        e()
                                    } catch (e) {
                                        C.Deferred.exceptionHook && C.Deferred.exceptionHook(e, t.error), l <= a + 1 && (r !== tt && (i = void 0, s = [e]), n.rejectWith(i, s))
                                    }
                                };
                                a ? t() : (C.Deferred.getErrorHook ? t.error = C.Deferred.getErrorHook() : C.Deferred.getStackHook && (t.error = C.Deferred.getStackHook()), k.setTimeout(t))
                            }
                        }

                        return C.Deferred(function (e) {
                            n[0][3].add(c(0, e, b(s) ? s : et, e.notifyWith)), n[1][3].add(c(0, e, b(t) ? t : et)), n[2][3].add(c(0, e, b(i) ? i : tt))
                        }).promise()
                    }, promise: function (e) {
                        return null != e ? C.extend(e, r) : r
                    }
                }, o = {};
            return C.each(n, function (e, t) {
                var i = t[2], s = t[5];
                r[t[1]] = i.add, s && i.add(function () {
                    a = s
                }, n[3 - e][2].disable, n[3 - e][3].disable, n[0][2].lock, n[0][3].lock), i.add(t[3].fire), o[t[0]] = function () {
                    return o[t[0] + "With"](this === o ? void 0 : this, arguments), this
                }, o[t[0] + "With"] = i.fireWith
            }), r.promise(o), e && e.call(o, o), o
        }, when: function (e) {
            function t(t) {
                return function (e) {
                    a[t] = this, n[t] = 1 < arguments.length ? o.call(arguments) : e, --i || r.resolveWith(a, n)
                }
            }

            var i = arguments.length, s = i, a = Array(s), n = o.call(arguments), r = C.Deferred();
            if (i <= 1 && (it(e, r.done(t(s)).resolve, r.reject, !i), "pending" === r.state() || b(n[s] && n[s].then))) return r.then();
            for (; s--;) it(n[s], t(s), r.reject);
            return r.promise()
        }
    });
    var st = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/,
        at = (C.Deferred.exceptionHook = function (e, t) {
            k.console && k.console.warn && e && st.test(e.name) && k.console.warn("jQuery.Deferred exception: " + e.message, e.stack, t)
        }, C.readyException = function (e) {
            k.setTimeout(function () {
                throw e
            })
        }, C.Deferred());

    function nt() {
        A.removeEventListener("DOMContentLoaded", nt), k.removeEventListener("load", nt), C.ready()
    }

    C.fn.ready = function (e) {
        return at.then(e).catch(function (e) {
            C.readyException(e)
        }), this
    }, C.extend({
        isReady: !1, readyWait: 1, ready: function (e) {
            (!0 === e ? --C.readyWait : C.isReady) || (C.isReady = !0) !== e && 0 < --C.readyWait || at.resolveWith(A, [C])
        }
    }), C.ready.then = at.then, "complete" === A.readyState || "loading" !== A.readyState && !A.documentElement.doScroll ? k.setTimeout(C.ready) : (A.addEventListener("DOMContentLoaded", nt), k.addEventListener("load", nt));

    function h(e, t, i, s, a, n, r) {
        var o = 0, l = e.length, c = null == i;
        if ("object" === U(i)) for (o in a = !0, i) h(e, t, o, i[o], !0, n, r); else if (void 0 !== s && (a = !0, b(s) || (r = !0), t = c ? r ? (t.call(e, s), null) : (c = t, function (e, t, i) {
            return c.call(C(e), i)
        }) : t)) for (; o < l; o++) t(e[o], i, r ? s : s.call(e[o], o, t(e[o], i)));
        return a ? e : c ? t.call(e) : l ? t(e[0], i) : n
    }

    var rt = /^-ms-/, ot = /-([a-z])/g;

    function lt(e, t) {
        return t.toUpperCase()
    }

    function I(e) {
        return e.replace(rt, "ms-").replace(ot, lt)
    }

    function ct(e) {
        return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType
    }

    function ht() {
        this.expando = C.expando + ht.uid++
    }

    ht.uid = 1, ht.prototype = {
        cache: function (e) {
            var t = e[this.expando];
            return t || (t = {}, ct(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, {
                value: t,
                configurable: !0
            }))), t
        }, set: function (e, t, i) {
            var s, a = this.cache(e);
            if ("string" == typeof t) a[I(t)] = i; else for (s in t) a[I(s)] = t[s];
            return a
        }, get: function (e, t) {
            return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][I(t)]
        }, access: function (e, t, i) {
            return void 0 === t || t && "string" == typeof t && void 0 === i ? this.get(e, t) : (this.set(e, t, i), void 0 !== i ? i : t)
        }, remove: function (e, t) {
            var i, s = e[this.expando];
            if (void 0 !== s) {
                if (void 0 !== t) {
                    i = (t = Array.isArray(t) ? t.map(I) : (t = I(t)) in s ? [t] : t.match(M) || []).length;
                    for (; i--;) delete s[t[i]]
                }
                void 0 !== t && !C.isEmptyObject(s) || (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando])
            }
        }, hasData: function (e) {
            e = e[this.expando];
            return void 0 !== e && !C.isEmptyObject(e)
        }
    };
    var m = new ht, c = new ht, dt = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, ut = /[A-Z]/g;

    function gt(e, t, i) {
        var s, a;
        if (void 0 === i && 1 === e.nodeType) if (s = "data-" + t.replace(ut, "-$&").toLowerCase(), "string" == typeof (i = e.getAttribute(s))) {
            try {
                i = "true" === (a = i) || "false" !== a && ("null" === a ? null : a === +a + "" ? +a : dt.test(a) ? JSON.parse(a) : a)
            } catch (e) {
            }
            c.set(e, t, i)
        } else i = void 0;
        return i
    }

    C.extend({
        hasData: function (e) {
            return c.hasData(e) || m.hasData(e)
        }, data: function (e, t, i) {
            return c.access(e, t, i)
        }, removeData: function (e, t) {
            c.remove(e, t)
        }, _data: function (e, t, i) {
            return m.access(e, t, i)
        }, _removeData: function (e, t) {
            m.remove(e, t)
        }
    }), C.fn.extend({
        data: function (i, e) {
            var t, s, a, n = this[0], r = n && n.attributes;
            if (void 0 !== i) return "object" == typeof i ? this.each(function () {
                c.set(this, i)
            }) : h(this, function (e) {
                var t;
                if (n && void 0 === e) return void 0 !== (t = c.get(n, i)) || void 0 !== (t = gt(n, i)) ? t : void 0;
                this.each(function () {
                    c.set(this, i, e)
                })
            }, null, e, 1 < arguments.length, null, !0);
            if (this.length && (a = c.get(n), 1 === n.nodeType) && !m.get(n, "hasDataAttrs")) {
                for (t = r.length; t--;) r[t] && 0 === (s = r[t].name).indexOf("data-") && (s = I(s.slice(5)), gt(n, s, a[s]));
                m.set(n, "hasDataAttrs", !0)
            }
            return a
        }, removeData: function (e) {
            return this.each(function () {
                c.remove(this, e)
            })
        }
    }), C.extend({
        queue: function (e, t, i) {
            var s;
            if (e) return s = m.get(e, t = (t || "fx") + "queue"), i && (!s || Array.isArray(i) ? s = m.access(e, t, C.makeArray(i)) : s.push(i)), s || []
        }, dequeue: function (e, t) {
            t = t || "fx";
            var i = C.queue(e, t), s = i.length, a = i.shift(), n = C._queueHooks(e, t);
            "inprogress" === a && (a = i.shift(), s--), a && ("fx" === t && i.unshift("inprogress"), delete n.stop, a.call(e, function () {
                C.dequeue(e, t)
            }, n)), !s && n && n.empty.fire()
        }, _queueHooks: function (e, t) {
            var i = t + "queueHooks";
            return m.get(e, i) || m.access(e, i, {
                empty: C.Callbacks("once memory").add(function () {
                    m.remove(e, [t + "queue", i])
                })
            })
        }
    }), C.fn.extend({
        queue: function (t, i) {
            var e = 2;
            return "string" != typeof t && (i = t, t = "fx", e--), arguments.length < e ? C.queue(this[0], t) : void 0 === i ? this : this.each(function () {
                var e = C.queue(this, t, i);
                C._queueHooks(this, t), "fx" === t && "inprogress" !== e[0] && C.dequeue(this, t)
            })
        }, dequeue: function (e) {
            return this.each(function () {
                C.dequeue(this, e)
            })
        }, clearQueue: function (e) {
            return this.queue(e || "fx", [])
        }, promise: function (e, t) {
            function i() {
                --a || n.resolveWith(r, [r])
            }

            var s, a = 1, n = C.Deferred(), r = this, o = this.length;
            for ("string" != typeof e && (t = e, e = void 0), e = e || "fx"; o--;) (s = m.get(r[o], e + "queueHooks")) && s.empty && (a++, s.empty.add(i));
            return i(), n.promise(t)
        }
    });

    function pt(e, t) {
        return "none" === (e = t || e).style.display || "" === e.style.display && bt(e) && "none" === C.css(e, "display")
    }

    var e = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, ft = new RegExp("^(?:([+-])=|)(" + e + ")([a-z%]*)$", "i"),
        xt = ["Top", "Right", "Bottom", "Left"], mt = A.documentElement, bt = function (e) {
            return C.contains(e.ownerDocument, e)
        }, vt = {composed: !0};
    mt.getRootNode && (bt = function (e) {
        return C.contains(e.ownerDocument, e) || e.getRootNode(vt) === e.ownerDocument
    });

    function yt(e, t, i, s) {
        var a, n, r = 20, o = s ? function () {
                return s.cur()
            } : function () {
                return C.css(e, t, "")
            }, l = o(), c = i && i[3] || (C.cssNumber[t] ? "" : "px"),
            h = e.nodeType && (C.cssNumber[t] || "px" !== c && +l) && ft.exec(C.css(e, t));
        if (h && h[3] !== c) {
            for (c = c || h[3], h = +(l /= 2) || 1; r--;) C.style(e, t, h + c), (1 - n) * (1 - (n = o() / l || .5)) <= 0 && (r = 0), h /= n;
            C.style(e, t, (h *= 2) + c), i = i || []
        }
        return i && (h = +h || +l || 0, a = i[1] ? h + (i[1] + 1) * i[2] : +i[2], s) && (s.unit = c, s.start = h, s.end = a), a
    }

    var wt = {};

    function kt(e, t) {
        for (var i, s, a, n, r, o, l = [], c = 0, h = e.length; c < h; c++) (s = e[c]).style && (i = s.style.display, t ? ("none" === i && (l[c] = m.get(s, "display") || null, l[c] || (s.style.display = "")), "" === s.style.display && pt(s) && (l[c] = (o = n = a = void 0, n = s.ownerDocument, (o = wt[r = s.nodeName]) || (a = n.body.appendChild(n.createElement(r)), o = C.css(a, "display"), a.parentNode.removeChild(a), wt[r] = o = "none" === o ? "block" : o)))) : "none" !== i && (l[c] = "none", m.set(s, "display", i)));
        for (c = 0; c < h; c++) null != l[c] && (e[c].style.display = l[c]);
        return e
    }

    C.fn.extend({
        show: function () {
            return kt(this, !0)
        }, hide: function () {
            return kt(this)
        }, toggle: function (e) {
            return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function () {
                pt(this) ? C(this).show() : C(this).hide()
            })
        }
    });
    var At = /^(?:checkbox|radio)$/i, Ct = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i, St = /^$|^module$|\/(?:java|ecma)script/i,
        n = A.createDocumentFragment().appendChild(A.createElement("div")),
        p = ((r = A.createElement("input")).setAttribute("type", "radio"), r.setAttribute("checked", "checked"), r.setAttribute("name", "t"), n.appendChild(r), f.checkClone = n.cloneNode(!0).cloneNode(!0).lastChild.checked, n.innerHTML = "<textarea>x</textarea>", f.noCloneChecked = !!n.cloneNode(!0).lastChild.defaultValue, n.innerHTML = "<option></option>", f.option = !!n.lastChild, {
            thead: [1, "<table>", "</table>"],
            col: [2, "<table><colgroup>", "</colgroup></table>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
            _default: [0, "", ""]
        });

    function x(e, t) {
        var i = void 0 !== e.getElementsByTagName ? e.getElementsByTagName(t || "*") : void 0 !== e.querySelectorAll ? e.querySelectorAll(t || "*") : [];
        return void 0 === t || t && v(e, t) ? C.merge([e], i) : i
    }

    function Lt(e, t) {
        for (var i = 0, s = e.length; i < s; i++) m.set(e[i], "globalEval", !t || m.get(t[i], "globalEval"))
    }

    p.tbody = p.tfoot = p.colgroup = p.caption = p.thead, p.th = p.td, f.option || (p.optgroup = p.option = [1, "<select multiple='multiple'>", "</select>"]);
    var Tt = /<|&#?\w+;/;

    function Et(e, t, i, s, a) {
        for (var n, r, o, l, c, h = t.createDocumentFragment(), d = [], u = 0, g = e.length; u < g; u++) if ((n = e[u]) || 0 === n) if ("object" === U(n)) C.merge(d, n.nodeType ? [n] : n); else if (Tt.test(n)) {
            for (r = r || h.appendChild(t.createElement("div")), o = (Ct.exec(n) || ["", ""])[1].toLowerCase(), o = p[o] || p._default, r.innerHTML = o[1] + C.htmlPrefilter(n) + o[2], c = o[0]; c--;) r = r.lastChild;
            C.merge(d, r.childNodes), (r = h.firstChild).textContent = ""
        } else d.push(t.createTextNode(n));
        for (h.textContent = "", u = 0; n = d[u++];) if (s && -1 < C.inArray(n, s)) a && a.push(n); else if (l = bt(n), r = x(h.appendChild(n), "script"), l && Lt(r), i) for (c = 0; n = r[c++];) St.test(n.type || "") && i.push(n);
        return h
    }

    var Pt = /^([^.]*)(?:\.(.+)|)/;

    function _t() {
        return !0
    }

    function Mt() {
        return !1
    }

    function It(e, t, i, s, a, n) {
        var r, o;
        if ("object" == typeof t) {
            for (o in "string" != typeof i && (s = s || i, i = void 0), t) It(e, o, i, s, t[o], n);
            return e
        }
        if (null == s && null == a ? (a = i, s = i = void 0) : null == a && ("string" == typeof i ? (a = s, s = void 0) : (a = s, s = i, i = void 0)), !1 === a) a = Mt; else if (!a) return e;
        return 1 === n && (r = a, (a = function (e) {
            return C().off(e), r.apply(this, arguments)
        }).guid = r.guid || (r.guid = C.guid++)), e.each(function () {
            C.event.add(this, t, a, s, i)
        })
    }

    function Ot(e, s, t) {
        t ? (m.set(e, s, !1), C.event.add(e, s, {
            namespace: !1, handler: function (e) {
                var t, i = m.get(this, s);
                if (1 & e.isTrigger && this[s]) {
                    if (i) (C.event.special[s] || {}).delegateType && e.stopPropagation(); else if (i = o.call(arguments), m.set(this, s, i), this[s](), t = m.get(this, s), m.set(this, s, !1), i !== t) return e.stopImmediatePropagation(), e.preventDefault(), t
                } else i && (m.set(this, s, C.event.trigger(i[0], i.slice(1), this)), e.stopPropagation(), e.isImmediatePropagationStopped = _t)
            }
        })) : void 0 === m.get(e, s) && C.event.add(e, s, _t)
    }

    C.event = {
        global: {}, add: function (t, e, i, s, a) {
            var n, r, o, l, c, h, d, u, g, p = m.get(t);
            if (ct(t)) for (i.handler && (i = (n = i).handler, a = n.selector), a && C.find.matchesSelector(mt, a), i.guid || (i.guid = C.guid++), o = (o = p.events) || (p.events = Object.create(null)), r = (r = p.handle) || (p.handle = function (e) {
                return void 0 !== C && C.event.triggered !== e.type ? C.event.dispatch.apply(t, arguments) : void 0
            }), l = (e = (e || "").match(M) || [""]).length; l--;) d = g = (u = Pt.exec(e[l]) || [])[1], u = (u[2] || "").split(".").sort(), d && (c = C.event.special[d] || {}, d = (a ? c.delegateType : c.bindType) || d, c = C.event.special[d] || {}, g = C.extend({
                type: d,
                origType: g,
                data: s,
                handler: i,
                guid: i.guid,
                selector: a,
                needsContext: a && C.expr.match.needsContext.test(a),
                namespace: u.join(".")
            }, n), (h = o[d]) || ((h = o[d] = []).delegateCount = 0, c.setup && !1 !== c.setup.call(t, s, u, r)) || t.addEventListener && t.addEventListener(d, r), c.add && (c.add.call(t, g), g.handler.guid || (g.handler.guid = i.guid)), a ? h.splice(h.delegateCount++, 0, g) : h.push(g), C.event.global[d] = !0)
        }, remove: function (e, t, i, s, a) {
            var n, r, o, l, c, h, d, u, g, p, f, x = m.hasData(e) && m.get(e);
            if (x && (l = x.events)) {
                for (c = (t = (t || "").match(M) || [""]).length; c--;) if (g = f = (o = Pt.exec(t[c]) || [])[1], p = (o[2] || "").split(".").sort(), g) {
                    for (d = C.event.special[g] || {}, u = l[g = (s ? d.delegateType : d.bindType) || g] || [], o = o[2] && new RegExp("(^|\\.)" + p.join("\\.(?:.*\\.|)") + "(\\.|$)"), r = n = u.length; n--;) h = u[n], !a && f !== h.origType || i && i.guid !== h.guid || o && !o.test(h.namespace) || s && s !== h.selector && ("**" !== s || !h.selector) || (u.splice(n, 1), h.selector && u.delegateCount--, d.remove && d.remove.call(e, h));
                    r && !u.length && (d.teardown && !1 !== d.teardown.call(e, p, x.handle) || C.removeEvent(e, g, x.handle), delete l[g])
                } else for (g in l) C.event.remove(e, g + t[c], i, s, !0);
                C.isEmptyObject(l) && m.remove(e, "handle events")
            }
        }, dispatch: function (e) {
            var t, i, s, a, n, r = new Array(arguments.length), o = C.event.fix(e),
                e = (m.get(this, "events") || Object.create(null))[o.type] || [], l = C.event.special[o.type] || {};
            for (r[0] = o, t = 1; t < arguments.length; t++) r[t] = arguments[t];
            if (o.delegateTarget = this, !l.preDispatch || !1 !== l.preDispatch.call(this, o)) {
                for (n = C.event.handlers.call(this, o, e), t = 0; (s = n[t++]) && !o.isPropagationStopped();) for (o.currentTarget = s.elem, i = 0; (a = s.handlers[i++]) && !o.isImmediatePropagationStopped();) o.rnamespace && !1 !== a.namespace && !o.rnamespace.test(a.namespace) || (o.handleObj = a, o.data = a.data, void 0 !== (a = ((C.event.special[a.origType] || {}).handle || a.handler).apply(s.elem, r)) && !1 === (o.result = a) && (o.preventDefault(), o.stopPropagation()));
                return l.postDispatch && l.postDispatch.call(this, o), o.result
            }
        }, handlers: function (e, t) {
            var i, s, a, n, r, o = [], l = t.delegateCount, c = e.target;
            if (l && c.nodeType && !("click" === e.type && 1 <= e.button)) for (; c !== this; c = c.parentNode || this) if (1 === c.nodeType && ("click" !== e.type || !0 !== c.disabled)) {
                for (n = [], r = {}, i = 0; i < l; i++) void 0 === r[a = (s = t[i]).selector + " "] && (r[a] = s.needsContext ? -1 < C(a, this).index(c) : C.find(a, this, null, [c]).length), r[a] && n.push(s);
                n.length && o.push({elem: c, handlers: n})
            }
            return c = this, l < t.length && o.push({elem: c, handlers: t.slice(l)}), o
        }, addProp: function (t, e) {
            Object.defineProperty(C.Event.prototype, t, {
                enumerable: !0, configurable: !0, get: b(e) ? function () {
                    if (this.originalEvent) return e(this.originalEvent)
                } : function () {
                    if (this.originalEvent) return this.originalEvent[t]
                }, set: function (e) {
                    Object.defineProperty(this, t, {enumerable: !0, configurable: !0, writable: !0, value: e})
                }
            })
        }, fix: function (e) {
            return e[C.expando] ? e : new C.Event(e)
        }, special: {
            load: {noBubble: !0}, click: {
                setup: function (e) {
                    e = this || e;
                    return At.test(e.type) && e.click && v(e, "input") && Ot(e, "click", !0), !1
                }, trigger: function (e) {
                    e = this || e;
                    return At.test(e.type) && e.click && v(e, "input") && Ot(e, "click"), !0
                }, _default: function (e) {
                    e = e.target;
                    return At.test(e.type) && e.click && v(e, "input") && m.get(e, "click") || v(e, "a")
                }
            }, beforeunload: {
                postDispatch: function (e) {
                    void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result)
                }
            }
        }
    }, C.removeEvent = function (e, t, i) {
        e.removeEventListener && e.removeEventListener(t, i)
    }, C.Event = function (e, t) {
        if (!(this instanceof C.Event)) return new C.Event(e, t);
        e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? _t : Mt, this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, t && C.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), this[C.expando] = !0
    }, C.Event.prototype = {
        constructor: C.Event,
        isDefaultPrevented: Mt,
        isPropagationStopped: Mt,
        isImmediatePropagationStopped: Mt,
        isSimulated: !1,
        preventDefault: function () {
            var e = this.originalEvent;
            this.isDefaultPrevented = _t, e && !this.isSimulated && e.preventDefault()
        },
        stopPropagation: function () {
            var e = this.originalEvent;
            this.isPropagationStopped = _t, e && !this.isSimulated && e.stopPropagation()
        },
        stopImmediatePropagation: function () {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = _t, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation()
        }
    }, C.each({
        altKey: !0,
        bubbles: !0,
        cancelable: !0,
        changedTouches: !0,
        ctrlKey: !0,
        detail: !0,
        eventPhase: !0,
        metaKey: !0,
        pageX: !0,
        pageY: !0,
        shiftKey: !0,
        view: !0,
        char: !0,
        code: !0,
        charCode: !0,
        key: !0,
        keyCode: !0,
        button: !0,
        buttons: !0,
        clientX: !0,
        clientY: !0,
        offsetX: !0,
        offsetY: !0,
        pointerId: !0,
        pointerType: !0,
        screenX: !0,
        screenY: !0,
        targetTouches: !0,
        toElement: !0,
        touches: !0,
        which: !0
    }, C.event.addProp), C.each({focus: "focusin", blur: "focusout"}, function (s, a) {
        function n(e) {
            var t, i;
            A.documentMode ? (t = m.get(this, "handle"), (i = C.event.fix(e)).type = "focusin" === e.type ? "focus" : "blur", i.isSimulated = !0, t(e), i.target === i.currentTarget && t(i)) : C.event.simulate(a, e.target, C.event.fix(e))
        }

        C.event.special[s] = {
            setup: function () {
                var e;
                if (Ot(this, s, !0), !A.documentMode) return !1;
                (e = m.get(this, a)) || this.addEventListener(a, n), m.set(this, a, (e || 0) + 1)
            }, trigger: function () {
                return Ot(this, s), !0
            }, teardown: function () {
                var e;
                if (!A.documentMode) return !1;
                (e = m.get(this, a) - 1) ? m.set(this, a, e) : (this.removeEventListener(a, n), m.remove(this, a))
            }, _default: function (e) {
                return m.get(e.target, s)
            }, delegateType: a
        }, C.event.special[a] = {
            setup: function () {
                var e = this.ownerDocument || this.document || this, t = A.documentMode ? this : e, i = m.get(t, a);
                i || (A.documentMode ? this.addEventListener(a, n) : e.addEventListener(s, n, !0)), m.set(t, a, (i || 0) + 1)
            }, teardown: function () {
                var e = this.ownerDocument || this.document || this, t = A.documentMode ? this : e, i = m.get(t, a) - 1;
                i ? m.set(t, a, i) : (A.documentMode ? this.removeEventListener(a, n) : e.removeEventListener(s, n, !0), m.remove(t, a))
            }
        }
    }), C.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function (e, a) {
        C.event.special[e] = {
            delegateType: a, bindType: a, handle: function (e) {
                var t, i = e.relatedTarget, s = e.handleObj;
                return i && (i === this || C.contains(this, i)) || (e.type = s.origType, t = s.handler.apply(this, arguments), e.type = a), t
            }
        }
    }), C.fn.extend({
        on: function (e, t, i, s) {
            return It(this, e, t, i, s)
        }, one: function (e, t, i, s) {
            return It(this, e, t, i, s, 1)
        }, off: function (e, t, i) {
            var s, a;
            if (e && e.preventDefault && e.handleObj) s = e.handleObj, C(e.delegateTarget).off(s.namespace ? s.origType + "." + s.namespace : s.origType, s.selector, s.handler); else {
                if ("object" != typeof e) return !1 !== t && "function" != typeof t || (i = t, t = void 0), !1 === i && (i = Mt), this.each(function () {
                    C.event.remove(this, e, i, t)
                });
                for (a in e) this.off(a, t, e[a])
            }
            return this
        }
    });
    var Dt = /<script|<style|<link/i, zt = /checked\s*(?:[^=]|=\s*.checked.)/i, Xt = /^\s*<!\[CDATA\[|\]\]>\s*$/g;

    function Nt(e, t) {
        return v(e, "table") && v(11 !== t.nodeType ? t : t.firstChild, "tr") && C(e).children("tbody")[0] || e
    }

    function Ft(e) {
        return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e
    }

    function Ht(e) {
        return "true/" === (e.type || "").slice(0, 5) ? e.type = e.type.slice(5) : e.removeAttribute("type"), e
    }

    function Rt(e, t) {
        var i, s, a, n;
        if (1 === t.nodeType) {
            if (m.hasData(e) && (n = m.get(e).events)) for (a in m.remove(t, "handle events"), n) for (i = 0, s = n[a].length; i < s; i++) C.event.add(t, a, n[a][i]);
            c.hasData(e) && (e = c.access(e), e = C.extend({}, e), c.set(t, e))
        }
    }

    function Yt(i, s, a, n) {
        s = H(s);
        var e, t, r, o, l, c, h = 0, d = i.length, u = d - 1, g = s[0], p = b(g);
        if (p || 1 < d && "string" == typeof g && !f.checkClone && zt.test(g)) return i.each(function (e) {
            var t = i.eq(e);
            p && (s[0] = g.call(this, e, t.html())), Yt(t, s, a, n)
        });
        if (d && (t = (e = Et(s, i[0].ownerDocument, !1, i, n)).firstChild, 1 === e.childNodes.length && (e = t), t || n)) {
            for (o = (r = C.map(x(e, "script"), Ft)).length; h < d; h++) l = e, h !== u && (l = C.clone(l, !0, !0), o) && C.merge(r, x(l, "script")), a.call(i[h], l, h);
            if (o) for (c = r[r.length - 1].ownerDocument, C.map(r, Ht), h = 0; h < o; h++) l = r[h], St.test(l.type || "") && !m.access(l, "globalEval") && C.contains(c, l) && (l.src && "module" !== (l.type || "").toLowerCase() ? C._evalUrl && !l.noModule && C._evalUrl(l.src, {nonce: l.nonce || l.getAttribute("nonce")}, c) : q(l.textContent.replace(Xt, ""), l, c))
        }
        return i
    }

    function Wt(e, t, i) {
        for (var s, a = t ? C.filter(t, e) : e, n = 0; null != (s = a[n]); n++) i || 1 !== s.nodeType || C.cleanData(x(s)), s.parentNode && (i && bt(s) && Lt(x(s, "script")), s.parentNode.removeChild(s));
        return e
    }

    C.extend({
        htmlPrefilter: function (e) {
            return e
        }, clone: function (e, t, i) {
            var s, a, n, r, o, l, c, h = e.cloneNode(!0), d = bt(e);
            if (!(f.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || C.isXMLDoc(e))) for (r = x(h), s = 0, a = (n = x(e)).length; s < a; s++) o = n[s], "input" === (c = (l = r[s]).nodeName.toLowerCase()) && At.test(o.type) ? l.checked = o.checked : "input" !== c && "textarea" !== c || (l.defaultValue = o.defaultValue);
            if (t) if (i) for (n = n || x(e), r = r || x(h), s = 0, a = n.length; s < a; s++) Rt(n[s], r[s]); else Rt(e, h);
            return 0 < (r = x(h, "script")).length && Lt(r, !d && x(e, "script")), h
        }, cleanData: function (e) {
            for (var t, i, s, a = C.event.special, n = 0; void 0 !== (i = e[n]); n++) if (ct(i)) {
                if (t = i[m.expando]) {
                    if (t.events) for (s in t.events) a[s] ? C.event.remove(i, s) : C.removeEvent(i, s, t.handle);
                    i[m.expando] = void 0
                }
                i[c.expando] && (i[c.expando] = void 0)
            }
        }
    }), C.fn.extend({
        detach: function (e) {
            return Wt(this, e, !0)
        }, remove: function (e) {
            return Wt(this, e)
        }, text: function (e) {
            return h(this, function (e) {
                return void 0 === e ? C.text(this) : this.empty().each(function () {
                    1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e)
                })
            }, null, e, arguments.length)
        }, append: function () {
            return Yt(this, arguments, function (e) {
                1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || Nt(this, e).appendChild(e)
            })
        }, prepend: function () {
            return Yt(this, arguments, function (e) {
                var t;
                1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (t = Nt(this, e)).insertBefore(e, t.firstChild)
            })
        }, before: function () {
            return Yt(this, arguments, function (e) {
                this.parentNode && this.parentNode.insertBefore(e, this)
            })
        }, after: function () {
            return Yt(this, arguments, function (e) {
                this.parentNode && this.parentNode.insertBefore(e, this.nextSibling)
            })
        }, empty: function () {
            for (var e, t = 0; null != (e = this[t]); t++) 1 === e.nodeType && (C.cleanData(x(e, !1)), e.textContent = "");
            return this
        }, clone: function (e, t) {
            return e = null != e && e, t = null == t ? e : t, this.map(function () {
                return C.clone(this, e, t)
            })
        }, html: function (e) {
            return h(this, function (e) {
                var t = this[0] || {}, i = 0, s = this.length;
                if (void 0 === e && 1 === t.nodeType) return t.innerHTML;
                if ("string" == typeof e && !Dt.test(e) && !p[(Ct.exec(e) || ["", ""])[1].toLowerCase()]) {
                    e = C.htmlPrefilter(e);
                    try {
                        for (; i < s; i++) 1 === (t = this[i] || {}).nodeType && (C.cleanData(x(t, !1)), t.innerHTML = e);
                        t = 0
                    } catch (e) {
                    }
                }
                t && this.empty().append(e)
            }, null, e, arguments.length)
        }, replaceWith: function () {
            var i = [];
            return Yt(this, arguments, function (e) {
                var t = this.parentNode;
                C.inArray(this, i) < 0 && (C.cleanData(x(this)), t) && t.replaceChild(e, this)
            }, i)
        }
    }), C.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function (e, r) {
        C.fn[e] = function (e) {
            for (var t, i = [], s = C(e), a = s.length - 1, n = 0; n <= a; n++) t = n === a ? this : this.clone(!0), C(s[n])[r](t), R.apply(i, t.get());
            return this.pushStack(i)
        }
    });

    function Bt(e) {
        var t = e.ownerDocument.defaultView;
        return (t = t && t.opener ? t : k).getComputedStyle(e)
    }

    function jt(e, t, i) {
        var s, a = {};
        for (s in t) a[s] = e.style[s], e.style[s] = t[s];
        for (s in i = i.call(e), t) e.style[s] = a[s];
        return i
    }

    var Gt, Vt, qt, Ut, Zt, $t, Qt, O, Kt = new RegExp("^(" + e + ")(?!px)[a-z%]+$", "i"), Jt = /^--/,
        ei = new RegExp(xt.join("|"), "i");

    function ti(e, t, i) {
        var s, a = Jt.test(t), n = e.style;
        return (i = i || Bt(e)) && (s = i.getPropertyValue(t) || i[t], "" !== (s = a ? s && (s.replace(ee, "$1") || void 0) : s) || bt(e) || (s = C.style(e, t)), !f.pixelBoxStyles()) && Kt.test(s) && ei.test(t) && (a = n.width, e = n.minWidth, t = n.maxWidth, n.minWidth = n.maxWidth = n.width = s, s = i.width, n.width = a, n.minWidth = e, n.maxWidth = t), void 0 !== s ? s + "" : s
    }

    function ii(e, t) {
        return {
            get: function () {
                if (!e()) return (this.get = t).apply(this, arguments);
                delete this.get
            }
        }
    }

    function si() {
        var e;
        O && (Qt.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", O.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", mt.appendChild(Qt).appendChild(O), e = k.getComputedStyle(O), Gt = "1%" !== e.top, $t = 12 === ai(e.marginLeft), O.style.right = "60%", Ut = 36 === ai(e.right), Vt = 36 === ai(e.width), O.style.position = "absolute", qt = 12 === ai(O.offsetWidth / 3), mt.removeChild(Qt), O = null)
    }

    function ai(e) {
        return Math.round(parseFloat(e))
    }

    Qt = A.createElement("div"), (O = A.createElement("div")).style && (O.style.backgroundClip = "content-box", O.cloneNode(!0).style.backgroundClip = "", f.clearCloneStyle = "content-box" === O.style.backgroundClip, C.extend(f, {
        boxSizingReliable: function () {
            return si(), Vt
        }, pixelBoxStyles: function () {
            return si(), Ut
        }, pixelPosition: function () {
            return si(), Gt
        }, reliableMarginLeft: function () {
            return si(), $t
        }, scrollboxSize: function () {
            return si(), qt
        }, reliableTrDimensions: function () {
            var e, t, i;
            return null == Zt && (e = A.createElement("table"), t = A.createElement("tr"), i = A.createElement("div"), e.style.cssText = "position:absolute;left:-11111px;border-collapse:separate", t.style.cssText = "box-sizing:content-box;border:1px solid", t.style.height = "1px", i.style.height = "9px", i.style.display = "block", mt.appendChild(e).appendChild(t).appendChild(i), i = k.getComputedStyle(t), Zt = parseInt(i.height, 10) + parseInt(i.borderTopWidth, 10) + parseInt(i.borderBottomWidth, 10) === t.offsetHeight, mt.removeChild(e)), Zt
        }
    }));
    var ni = ["Webkit", "Moz", "ms"], ri = A.createElement("div").style, oi = {};

    function li(e) {
        return C.cssProps[e] || oi[e] || (e in ri ? e : oi[e] = (e => {
            for (var t = e[0].toUpperCase() + e.slice(1), i = ni.length; i--;) if ((e = ni[i] + t) in ri) return e
        })(e) || e)
    }

    var ci = /^(none|table(?!-c[ea]).+)/, hi = {position: "absolute", visibility: "hidden", display: "block"},
        di = {letterSpacing: "0", fontWeight: "400"};

    function ui(e, t, i) {
        var s = ft.exec(t);
        return s ? Math.max(0, s[2] - (i || 0)) + (s[3] || "px") : t
    }

    function gi(e, t, i, s, a, n) {
        var r = "width" === t ? 1 : 0, o = 0, l = 0, c = 0;
        if (i === (s ? "border" : "content")) return 0;
        for (; r < 4; r += 2) "margin" === i && (c += C.css(e, i + xt[r], !0, a)), s ? ("content" === i && (l -= C.css(e, "padding" + xt[r], !0, a)), "margin" !== i && (l -= C.css(e, "border" + xt[r] + "Width", !0, a))) : (l += C.css(e, "padding" + xt[r], !0, a), "padding" !== i ? l += C.css(e, "border" + xt[r] + "Width", !0, a) : o += C.css(e, "border" + xt[r] + "Width", !0, a));
        return !s && 0 <= n && (l += Math.max(0, Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - n - l - o - .5)) || 0), l + c
    }

    function pi(e, t, i) {
        var s = Bt(e), a = (!f.boxSizingReliable() || i) && "border-box" === C.css(e, "boxSizing", !1, s), n = a,
            r = ti(e, t, s), o = "offset" + t[0].toUpperCase() + t.slice(1);
        if (Kt.test(r)) {
            if (!i) return r;
            r = "auto"
        }
        return (!f.boxSizingReliable() && a || !f.reliableTrDimensions() && v(e, "tr") || "auto" === r || !parseFloat(r) && "inline" === C.css(e, "display", !1, s)) && e.getClientRects().length && (a = "border-box" === C.css(e, "boxSizing", !1, s), n = o in e) && (r = e[o]), (r = parseFloat(r) || 0) + gi(e, t, i || (a ? "border" : "content"), n, s, r) + "px"
    }

    function D(e, t, i, s, a) {
        return new D.prototype.init(e, t, i, s, a)
    }

    C.extend({
        cssHooks: {
            opacity: {
                get: function (e, t) {
                    if (t) return "" === (t = ti(e, "opacity")) ? "1" : t
                }
            }
        },
        cssNumber: {
            animationIterationCount: !0,
            aspectRatio: !0,
            borderImageSlice: !0,
            columnCount: !0,
            flexGrow: !0,
            flexShrink: !0,
            fontWeight: !0,
            gridArea: !0,
            gridColumn: !0,
            gridColumnEnd: !0,
            gridColumnStart: !0,
            gridRow: !0,
            gridRowEnd: !0,
            gridRowStart: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            scale: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0,
            fillOpacity: !0,
            floodOpacity: !0,
            stopOpacity: !0,
            strokeMiterlimit: !0,
            strokeOpacity: !0
        },
        cssProps: {},
        style: function (e, t, i, s) {
            if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
                var a, n, r, o = I(t), l = Jt.test(t), c = e.style;
                if (l || (t = li(o)), r = C.cssHooks[t] || C.cssHooks[o], void 0 === i) return r && "get" in r && void 0 !== (a = r.get(e, !1, s)) ? a : c[t];
                "string" == (n = typeof i) && (a = ft.exec(i)) && a[1] && (i = yt(e, t, a), n = "number"), null != i && i == i && ("number" !== n || l || (i += a && a[3] || (C.cssNumber[o] ? "" : "px")), f.clearCloneStyle || "" !== i || 0 !== t.indexOf("background") || (c[t] = "inherit"), r && "set" in r && void 0 === (i = r.set(e, i, s)) || (l ? c.setProperty(t, i) : c[t] = i))
            }
        },
        css: function (e, t, i, s) {
            var a, n = I(t);
            return Jt.test(t) || (t = li(n)), "normal" === (a = void 0 === (a = (n = C.cssHooks[t] || C.cssHooks[n]) && "get" in n ? n.get(e, !0, i) : a) ? ti(e, t, s) : a) && t in di && (a = di[t]), ("" === i || i) && (n = parseFloat(a), !0 === i || isFinite(n)) ? n || 0 : a
        }
    }), C.each(["height", "width"], function (e, r) {
        C.cssHooks[r] = {
            get: function (e, t, i) {
                if (t) return !ci.test(C.css(e, "display")) || e.getClientRects().length && e.getBoundingClientRect().width ? pi(e, r, i) : jt(e, hi, function () {
                    return pi(e, r, i)
                })
            }, set: function (e, t, i) {
                var s = Bt(e), a = !f.scrollboxSize() && "absolute" === s.position,
                    n = (a || i) && "border-box" === C.css(e, "boxSizing", !1, s), i = i ? gi(e, r, i, n, s) : 0;
                return n && a && (i -= Math.ceil(e["offset" + r[0].toUpperCase() + r.slice(1)] - parseFloat(s[r]) - gi(e, r, "border", !1, s) - .5)), i && (n = ft.exec(t)) && "px" !== (n[3] || "px") && (e.style[r] = t, t = C.css(e, r)), ui(0, t, i)
            }
        }
    }), C.cssHooks.marginLeft = ii(f.reliableMarginLeft, function (e, t) {
        if (t) return (parseFloat(ti(e, "marginLeft")) || e.getBoundingClientRect().left - jt(e, {marginLeft: 0}, function () {
            return e.getBoundingClientRect().left
        })) + "px"
    }), C.each({margin: "", padding: "", border: "Width"}, function (a, n) {
        C.cssHooks[a + n] = {
            expand: function (e) {
                for (var t = 0, i = {}, s = "string" == typeof e ? e.split(" ") : [e]; t < 4; t++) i[a + xt[t] + n] = s[t] || s[t - 2] || s[0];
                return i
            }
        }, "margin" !== a && (C.cssHooks[a + n].set = ui)
    }), C.fn.extend({
        css: function (e, t) {
            return h(this, function (e, t, i) {
                var s, a, n = {}, r = 0;
                if (Array.isArray(t)) {
                    for (s = Bt(e), a = t.length; r < a; r++) n[t[r]] = C.css(e, t[r], !1, s);
                    return n
                }
                return void 0 !== i ? C.style(e, t, i) : C.css(e, t)
            }, e, t, 1 < arguments.length)
        }
    }), ((C.Tween = D).prototype = {
        constructor: D, init: function (e, t, i, s, a, n) {
            this.elem = e, this.prop = i, this.easing = a || C.easing._default, this.options = t, this.start = this.now = this.cur(), this.end = s, this.unit = n || (C.cssNumber[i] ? "" : "px")
        }, cur: function () {
            var e = D.propHooks[this.prop];
            return (e && e.get ? e : D.propHooks._default).get(this)
        }, run: function (e) {
            var t, i = D.propHooks[this.prop];
            return this.options.duration ? this.pos = t = C.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), (i && i.set ? i : D.propHooks._default).set(this), this
        }
    }).init.prototype = D.prototype, (D.propHooks = {
        _default: {
            get: function (e) {
                return 1 !== e.elem.nodeType || null != e.elem[e.prop] && null == e.elem.style[e.prop] ? e.elem[e.prop] : (e = C.css(e.elem, e.prop, "")) && "auto" !== e ? e : 0
            }, set: function (e) {
                C.fx.step[e.prop] ? C.fx.step[e.prop](e) : 1 !== e.elem.nodeType || !C.cssHooks[e.prop] && null == e.elem.style[li(e.prop)] ? e.elem[e.prop] = e.now : C.style(e.elem, e.prop, e.now + e.unit)
            }
        }
    }).scrollTop = D.propHooks.scrollLeft = {
        set: function (e) {
            e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now)
        }
    }, C.easing = {
        linear: function (e) {
            return e
        }, swing: function (e) {
            return .5 - Math.cos(e * Math.PI) / 2
        }, _default: "swing"
    }, C.fx = D.prototype.init, C.fx.step = {};
    var fi, xi, mi = /^(?:toggle|show|hide)$/, bi = /queueHooks$/;

    function vi() {
        xi && (!1 === A.hidden && k.requestAnimationFrame ? k.requestAnimationFrame(vi) : k.setTimeout(vi, C.fx.interval), C.fx.tick())
    }

    function yi() {
        return k.setTimeout(function () {
            fi = void 0
        }), fi = Date.now()
    }

    function wi(e, t) {
        var i, s = 0, a = {height: e};
        for (t = t ? 1 : 0; s < 4; s += 2 - t) a["margin" + (i = xt[s])] = a["padding" + i] = e;
        return t && (a.opacity = a.width = e), a
    }

    function ki(e, t, i) {
        for (var s, a = (z.tweeners[t] || []).concat(z.tweeners["*"]), n = 0, r = a.length; n < r; n++) if (s = a[n].call(i, t, e)) return s
    }

    function z(a, e, t) {
        var i, n, s, r, o, l, c, h = 0, d = z.prefilters.length, u = C.Deferred().always(function () {
            delete g.elem
        }), g = function () {
            if (n) return !1;
            for (var e = fi || yi(), e = Math.max(0, p.startTime + p.duration - e), t = 1 - (e / p.duration || 0), i = 0, s = p.tweens.length; i < s; i++) p.tweens[i].run(t);
            return u.notifyWith(a, [p, t, e]), t < 1 && s ? e : (s || u.notifyWith(a, [p, 1, 0]), u.resolveWith(a, [p]), !1)
        }, p = u.promise({
            elem: a,
            props: C.extend({}, e),
            opts: C.extend(!0, {specialEasing: {}, easing: C.easing._default}, t),
            originalProperties: e,
            originalOptions: t,
            startTime: fi || yi(),
            duration: t.duration,
            tweens: [],
            createTween: function (e, t) {
                t = C.Tween(a, p.opts, e, t, p.opts.specialEasing[e] || p.opts.easing);
                return p.tweens.push(t), t
            },
            stop: function (e) {
                var t = 0, i = e ? p.tweens.length : 0;
                if (!n) {
                    for (n = !0; t < i; t++) p.tweens[t].run(1);
                    e ? (u.notifyWith(a, [p, 1, 0]), u.resolveWith(a, [p, e])) : u.rejectWith(a, [p, e])
                }
                return this
            }
        }), f = p.props, x = f, m = p.opts.specialEasing;
        for (s in x) if (o = m[r = I(s)], l = x[s], Array.isArray(l) && (o = l[1], l = x[s] = l[0]), s !== r && (x[r] = l, delete x[s]), (c = C.cssHooks[r]) && "expand" in c) for (s in l = c.expand(l), delete x[r], l) s in x || (x[s] = l[s], m[s] = o); else m[r] = o;
        for (; h < d; h++) if (i = z.prefilters[h].call(p, a, f, p.opts)) return b(i.stop) && (C._queueHooks(p.elem, p.opts.queue).stop = i.stop.bind(i)), i;
        return C.map(f, ki, p), b(p.opts.start) && p.opts.start.call(a, p), p.progress(p.opts.progress).done(p.opts.done, p.opts.complete).fail(p.opts.fail).always(p.opts.always), C.fx.timer(C.extend(g, {
            elem: a,
            anim: p,
            queue: p.opts.queue
        })), p
    }

    C.Animation = C.extend(z, {
        tweeners: {
            "*": [function (e, t) {
                var i = this.createTween(e, t);
                return yt(i.elem, e, ft.exec(t), i), i
            }]
        }, tweener: function (e, t) {
            for (var i, s = 0, a = (e = b(e) ? (t = e, ["*"]) : e.match(M)).length; s < a; s++) i = e[s], z.tweeners[i] = z.tweeners[i] || [], z.tweeners[i].unshift(t)
        }, prefilters: [function (e, t, i) {
            var s, a, n, r, o, l, c, h = "width" in t || "height" in t, d = this, u = {}, g = e.style,
                p = e.nodeType && pt(e), f = m.get(e, "fxshow");
            for (s in i.queue || (null == (r = C._queueHooks(e, "fx")).unqueued && (r.unqueued = 0, o = r.empty.fire, r.empty.fire = function () {
                r.unqueued || o()
            }), r.unqueued++, d.always(function () {
                d.always(function () {
                    r.unqueued--, C.queue(e, "fx").length || r.empty.fire()
                })
            })), t) if (a = t[s], mi.test(a)) {
                if (delete t[s], n = n || "toggle" === a, a === (p ? "hide" : "show")) {
                    if ("show" !== a || !f || void 0 === f[s]) continue;
                    p = !0
                }
                u[s] = f && f[s] || C.style(e, s)
            }
            if ((l = !C.isEmptyObject(t)) || !C.isEmptyObject(u)) for (s in h && 1 === e.nodeType && (i.overflow = [g.overflow, g.overflowX, g.overflowY], null == (c = f && f.display) && (c = m.get(e, "display")), "none" === (h = C.css(e, "display")) && (c ? h = c : (kt([e], !0), c = e.style.display || c, h = C.css(e, "display"), kt([e]))), "inline" === h || "inline-block" === h && null != c) && "none" === C.css(e, "float") && (l || (d.done(function () {
                g.display = c
            }), null == c && (h = g.display, c = "none" === h ? "" : h)), g.display = "inline-block"), i.overflow && (g.overflow = "hidden", d.always(function () {
                g.overflow = i.overflow[0], g.overflowX = i.overflow[1], g.overflowY = i.overflow[2]
            })), l = !1, u) l || (f ? "hidden" in f && (p = f.hidden) : f = m.access(e, "fxshow", {display: c}), n && (f.hidden = !p), p && kt([e], !0), d.done(function () {
                for (s in p || kt([e]), m.remove(e, "fxshow"), u) C.style(e, s, u[s])
            })), l = ki(p ? f[s] : 0, s, d), s in f || (f[s] = l.start, p && (l.end = l.start, l.start = 0))
        }], prefilter: function (e, t) {
            t ? z.prefilters.unshift(e) : z.prefilters.push(e)
        }
    }), C.speed = function (e, t, i) {
        var s = e && "object" == typeof e ? C.extend({}, e) : {
            complete: i || !i && t || b(e) && e,
            duration: e,
            easing: i && t || t && !b(t) && t
        };
        return C.fx.off ? s.duration = 0 : "number" != typeof s.duration && (s.duration in C.fx.speeds ? s.duration = C.fx.speeds[s.duration] : s.duration = C.fx.speeds._default), null != s.queue && !0 !== s.queue || (s.queue = "fx"), s.old = s.complete, s.complete = function () {
            b(s.old) && s.old.call(this), s.queue && C.dequeue(this, s.queue)
        }, s
    }, C.fn.extend({
        fadeTo: function (e, t, i, s) {
            return this.filter(pt).css("opacity", 0).show().end().animate({opacity: t}, e, i, s)
        }, animate: function (t, e, i, s) {
            function a() {
                var e = z(this, C.extend({}, t), r);
                (n || m.get(this, "finish")) && e.stop(!0)
            }

            var n = C.isEmptyObject(t), r = C.speed(e, i, s);
            return a.finish = a, n || !1 === r.queue ? this.each(a) : this.queue(r.queue, a)
        }, stop: function (a, e, n) {
            function r(e) {
                var t = e.stop;
                delete e.stop, t(n)
            }

            return "string" != typeof a && (n = e, e = a, a = void 0), e && this.queue(a || "fx", []), this.each(function () {
                var e = !0, t = null != a && a + "queueHooks", i = C.timers, s = m.get(this);
                if (t) s[t] && s[t].stop && r(s[t]); else for (t in s) s[t] && s[t].stop && bi.test(t) && r(s[t]);
                for (t = i.length; t--;) i[t].elem !== this || null != a && i[t].queue !== a || (i[t].anim.stop(n), e = !1, i.splice(t, 1));
                !e && n || C.dequeue(this, a)
            })
        }, finish: function (r) {
            return !1 !== r && (r = r || "fx"), this.each(function () {
                var e, t = m.get(this), i = t[r + "queue"], s = t[r + "queueHooks"], a = C.timers, n = i ? i.length : 0;
                for (t.finish = !0, C.queue(this, r, []), s && s.stop && s.stop.call(this, !0), e = a.length; e--;) a[e].elem === this && a[e].queue === r && (a[e].anim.stop(!0), a.splice(e, 1));
                for (e = 0; e < n; e++) i[e] && i[e].finish && i[e].finish.call(this);
                delete t.finish
            })
        }
    }), C.each(["toggle", "show", "hide"], function (e, s) {
        var a = C.fn[s];
        C.fn[s] = function (e, t, i) {
            return null == e || "boolean" == typeof e ? a.apply(this, arguments) : this.animate(wi(s, !0), e, t, i)
        }
    }), C.each({
        slideDown: wi("show"),
        slideUp: wi("hide"),
        slideToggle: wi("toggle"),
        fadeIn: {opacity: "show"},
        fadeOut: {opacity: "hide"},
        fadeToggle: {opacity: "toggle"}
    }, function (e, s) {
        C.fn[e] = function (e, t, i) {
            return this.animate(s, e, t, i)
        }
    }), C.timers = [], C.fx.tick = function () {
        var e, t = 0, i = C.timers;
        for (fi = Date.now(); t < i.length; t++) (e = i[t])() || i[t] !== e || i.splice(t--, 1);
        i.length || C.fx.stop(), fi = void 0
    }, C.fx.timer = function (e) {
        C.timers.push(e), C.fx.start()
    }, C.fx.interval = 13, C.fx.start = function () {
        xi || (xi = !0, vi())
    }, C.fx.stop = function () {
        xi = null
    }, C.fx.speeds = {slow: 600, fast: 200, _default: 400}, C.fn.delay = function (s, e) {
        return s = C.fx && C.fx.speeds[s] || s, this.queue(e = e || "fx", function (e, t) {
            var i = k.setTimeout(e, s);
            t.stop = function () {
                k.clearTimeout(i)
            }
        })
    }, r = A.createElement("input"), n = A.createElement("select").appendChild(A.createElement("option")), r.type = "checkbox", f.checkOn = "" !== r.value, f.optSelected = n.selected, (r = A.createElement("input")).value = "t", r.type = "radio", f.radioValue = "t" === r.value;
    var Ai, Ci = C.expr.attrHandle, Si = (C.fn.extend({
        attr: function (e, t) {
            return h(this, C.attr, e, t, 1 < arguments.length)
        }, removeAttr: function (e) {
            return this.each(function () {
                C.removeAttr(this, e)
            })
        }
    }), C.extend({
        attr: function (e, t, i) {
            var s, a, n = e.nodeType;
            if (3 !== n && 8 !== n && 2 !== n) return void 0 === e.getAttribute ? C.prop(e, t, i) : (1 === n && C.isXMLDoc(e) || (a = C.attrHooks[t.toLowerCase()] || (C.expr.match.bool.test(t) ? Ai : void 0)), void 0 !== i ? null === i ? void C.removeAttr(e, t) : a && "set" in a && void 0 !== (s = a.set(e, i, t)) ? s : (e.setAttribute(t, i + ""), i) : !(a && "get" in a && null !== (s = a.get(e, t))) && null == (s = C.find.attr(e, t)) ? void 0 : s)
        }, attrHooks: {
            type: {
                set: function (e, t) {
                    var i;
                    if (!f.radioValue && "radio" === t && v(e, "input")) return i = e.value, e.setAttribute("type", t), i && (e.value = i), t
                }
            }
        }, removeAttr: function (e, t) {
            var i, s = 0, a = t && t.match(M);
            if (a && 1 === e.nodeType) for (; i = a[s++];) e.removeAttribute(i)
        }
    }), Ai = {
        set: function (e, t, i) {
            return !1 === t ? C.removeAttr(e, i) : e.setAttribute(i, i), i
        }
    }, C.each(C.expr.match.bool.source.match(/\w+/g), function (e, t) {
        var r = Ci[t] || C.find.attr;
        Ci[t] = function (e, t, i) {
            var s, a, n = t.toLowerCase();
            return i || (a = Ci[n], Ci[n] = s, s = null != r(e, t, i) ? n : null, Ci[n] = a), s
        }
    }), /^(?:input|select|textarea|button)$/i), Li = /^(?:a|area)$/i;

    function Ti(e) {
        return (e.match(M) || []).join(" ")
    }

    function Ei(e) {
        return e.getAttribute && e.getAttribute("class") || ""
    }

    function Pi(e) {
        return Array.isArray(e) ? e : "string" == typeof e && e.match(M) || []
    }

    C.fn.extend({
        prop: function (e, t) {
            return h(this, C.prop, e, t, 1 < arguments.length)
        }, removeProp: function (e) {
            return this.each(function () {
                delete this[C.propFix[e] || e]
            })
        }
    }), C.extend({
        prop: function (e, t, i) {
            var s, a, n = e.nodeType;
            if (3 !== n && 8 !== n && 2 !== n) return 1 === n && C.isXMLDoc(e) || (t = C.propFix[t] || t, a = C.propHooks[t]), void 0 !== i ? a && "set" in a && void 0 !== (s = a.set(e, i, t)) ? s : e[t] = i : a && "get" in a && null !== (s = a.get(e, t)) ? s : e[t]
        }, propHooks: {
            tabIndex: {
                get: function (e) {
                    var t = C.find.attr(e, "tabindex");
                    return t ? parseInt(t, 10) : Si.test(e.nodeName) || Li.test(e.nodeName) && e.href ? 0 : -1
                }
            }
        }, propFix: {for: "htmlFor", class: "className"}
    }), f.optSelected || (C.propHooks.selected = {
        get: function (e) {
            e = e.parentNode;
            return e && e.parentNode && e.parentNode.selectedIndex, null
        }, set: function (e) {
            e = e.parentNode;
            e && (e.selectedIndex, e.parentNode) && e.parentNode.selectedIndex
        }
    }), C.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
        C.propFix[this.toLowerCase()] = this
    }), C.fn.extend({
        addClass: function (t) {
            var e, i, s, a, n, r;
            return b(t) ? this.each(function (e) {
                C(this).addClass(t.call(this, e, Ei(this)))
            }) : (e = Pi(t)).length ? this.each(function () {
                if (s = Ei(this), i = 1 === this.nodeType && " " + Ti(s) + " ") {
                    for (n = 0; n < e.length; n++) a = e[n], i.indexOf(" " + a + " ") < 0 && (i += a + " ");
                    r = Ti(i), s !== r && this.setAttribute("class", r)
                }
            }) : this
        }, removeClass: function (t) {
            var e, i, s, a, n, r;
            return b(t) ? this.each(function (e) {
                C(this).removeClass(t.call(this, e, Ei(this)))
            }) : arguments.length ? (e = Pi(t)).length ? this.each(function () {
                if (s = Ei(this), i = 1 === this.nodeType && " " + Ti(s) + " ") {
                    for (n = 0; n < e.length; n++) for (a = e[n]; -1 < i.indexOf(" " + a + " ");) i = i.replace(" " + a + " ", " ");
                    r = Ti(i), s !== r && this.setAttribute("class", r)
                }
            }) : this : this.attr("class", "")
        }, toggleClass: function (t, i) {
            var e, s, a, n, r = typeof t, o = "string" == r || Array.isArray(t);
            return b(t) ? this.each(function (e) {
                C(this).toggleClass(t.call(this, e, Ei(this), i), i)
            }) : "boolean" == typeof i && o ? i ? this.addClass(t) : this.removeClass(t) : (e = Pi(t), this.each(function () {
                if (o) for (n = C(this), a = 0; a < e.length; a++) s = e[a], n.hasClass(s) ? n.removeClass(s) : n.addClass(s); else void 0 !== t && "boolean" != r || ((s = Ei(this)) && m.set(this, "__className__", s), this.setAttribute && this.setAttribute("class", !s && !1 !== t && m.get(this, "__className__") || ""))
            }))
        }, hasClass: function (e) {
            for (var t, i = 0, s = " " + e + " "; t = this[i++];) if (1 === t.nodeType && -1 < (" " + Ti(Ei(t)) + " ").indexOf(s)) return !0;
            return !1
        }
    });

    function _i(e) {
        e.stopPropagation()
    }

    var Mi = /\r/g, Ii = (C.fn.extend({
            val: function (t) {
                var i, e, s, a = this[0];
                return arguments.length ? (s = b(t), this.each(function (e) {
                    1 === this.nodeType && (null == (e = s ? t.call(this, e, C(this).val()) : t) ? e = "" : "number" == typeof e ? e += "" : Array.isArray(e) && (e = C.map(e, function (e) {
                        return null == e ? "" : e + ""
                    })), (i = C.valHooks[this.type] || C.valHooks[this.nodeName.toLowerCase()]) && "set" in i && void 0 !== i.set(this, e, "value") || (this.value = e))
                })) : a ? (i = C.valHooks[a.type] || C.valHooks[a.nodeName.toLowerCase()]) && "get" in i && void 0 !== (e = i.get(a, "value")) ? e : "string" == typeof (e = a.value) ? e.replace(Mi, "") : null == e ? "" : e : void 0
            }
        }), C.extend({
            valHooks: {
                option: {
                    get: function (e) {
                        var t = C.find.attr(e, "value");
                        return null != t ? t : Ti(C.text(e))
                    }
                }, select: {
                    get: function (e) {
                        for (var t, i = e.options, s = e.selectedIndex, a = "select-one" === e.type, n = a ? null : [], r = a ? s + 1 : i.length, o = s < 0 ? r : a ? s : 0; o < r; o++) if (((t = i[o]).selected || o === s) && !t.disabled && (!t.parentNode.disabled || !v(t.parentNode, "optgroup"))) {
                            if (t = C(t).val(), a) return t;
                            n.push(t)
                        }
                        return n
                    }, set: function (e, t) {
                        for (var i, s, a = e.options, n = C.makeArray(t), r = a.length; r--;) ((s = a[r]).selected = -1 < C.inArray(C.valHooks.option.get(s), n)) && (i = !0);
                        return i || (e.selectedIndex = -1), n
                    }
                }
            }
        }), C.each(["radio", "checkbox"], function () {
            C.valHooks[this] = {
                set: function (e, t) {
                    if (Array.isArray(t)) return e.checked = -1 < C.inArray(C(e).val(), t)
                }
            }, f.checkOn || (C.valHooks[this].get = function (e) {
                return null === e.getAttribute("value") ? "on" : e.value
            })
        }), k.location), Oi = {guid: Date.now()}, Di = /\?/, zi = (C.parseXML = function (e) {
            var t, i;
            if (!e || "string" != typeof e) return null;
            try {
                t = (new k.DOMParser).parseFromString(e, "text/xml")
            } catch (e) {
            }
            return i = t && t.getElementsByTagName("parsererror")[0], t && !i || C.error("Invalid XML: " + (i ? C.map(i.childNodes, function (e) {
                return e.textContent
            }).join("\n") : e)), t
        }, /^(?:focusinfocus|focusoutblur)$/), Xi = (C.extend(C.event, {
            trigger: function (e, t, i, s) {
                var a, n, r, o, l, c, h, d = [i || A], u = B.call(e, "type") ? e.type : e,
                    g = B.call(e, "namespace") ? e.namespace.split(".") : [], p = h = n = i = i || A;
                if (3 !== i.nodeType && 8 !== i.nodeType && !zi.test(u + C.event.triggered) && (-1 < u.indexOf(".") && (u = (g = u.split(".")).shift(), g.sort()), o = u.indexOf(":") < 0 && "on" + u, (e = e[C.expando] ? e : new C.Event(u, "object" == typeof e && e)).isTrigger = s ? 2 : 3, e.namespace = g.join("."), e.rnamespace = e.namespace ? new RegExp("(^|\\.)" + g.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, e.result = void 0, e.target || (e.target = i), t = null == t ? [e] : C.makeArray(t, [e]), c = C.event.special[u] || {}, s || !c.trigger || !1 !== c.trigger.apply(i, t))) {
                    if (!s && !c.noBubble && !N(i)) {
                        for (r = c.delegateType || u, zi.test(r + u) || (p = p.parentNode); p; p = p.parentNode) d.push(p), n = p;
                        n === (i.ownerDocument || A) && d.push(n.defaultView || n.parentWindow || k)
                    }
                    for (a = 0; (p = d[a++]) && !e.isPropagationStopped();) h = p, e.type = 1 < a ? r : c.bindType || u, (l = (m.get(p, "events") || Object.create(null))[e.type] && m.get(p, "handle")) && l.apply(p, t), (l = o && p[o]) && l.apply && ct(p) && (e.result = l.apply(p, t), !1 === e.result) && e.preventDefault();
                    return e.type = u, s || e.isDefaultPrevented() || c._default && !1 !== c._default.apply(d.pop(), t) || !ct(i) || o && b(i[u]) && !N(i) && ((n = i[o]) && (i[o] = null), C.event.triggered = u, e.isPropagationStopped() && h.addEventListener(u, _i), i[u](), e.isPropagationStopped() && h.removeEventListener(u, _i), C.event.triggered = void 0, n) && (i[o] = n), e.result
                }
            }, simulate: function (e, t, i) {
                i = C.extend(new C.Event, i, {type: e, isSimulated: !0});
                C.event.trigger(i, null, t)
            }
        }), C.fn.extend({
            trigger: function (e, t) {
                return this.each(function () {
                    C.event.trigger(e, t, this)
                })
            }, triggerHandler: function (e, t) {
                var i = this[0];
                if (i) return C.event.trigger(e, t, i, !0)
            }
        }), /\[\]$/), Ni = /\r?\n/g, Fi = /^(?:submit|button|image|reset|file)$/i,
        Hi = /^(?:input|select|textarea|keygen)/i;
    C.param = function (e, t) {
        function i(e, t) {
            t = b(t) ? t() : t, a[a.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == t ? "" : t)
        }

        var s, a = [];
        if (null == e) return "";
        if (Array.isArray(e) || e.jquery && !C.isPlainObject(e)) C.each(e, function () {
            i(this.name, this.value)
        }); else for (s in e) !function i(s, e, a, n) {
            if (Array.isArray(e)) C.each(e, function (e, t) {
                a || Xi.test(s) ? n(s, t) : i(s + "[" + ("object" == typeof t && null != t ? e : "") + "]", t, a, n)
            }); else if (a || "object" !== U(e)) n(s, e); else for (var t in e) i(s + "[" + t + "]", e[t], a, n)
        }(s, e[s], t, i);
        return a.join("&")
    }, C.fn.extend({
        serialize: function () {
            return C.param(this.serializeArray())
        }, serializeArray: function () {
            return this.map(function () {
                var e = C.prop(this, "elements");
                return e ? C.makeArray(e) : this
            }).filter(function () {
                var e = this.type;
                return this.name && !C(this).is(":disabled") && Hi.test(this.nodeName) && !Fi.test(e) && (this.checked || !At.test(e))
            }).map(function (e, t) {
                var i = C(this).val();
                return null == i ? null : Array.isArray(i) ? C.map(i, function (e) {
                    return {name: t.name, value: e.replace(Ni, "\r\n")}
                }) : {name: t.name, value: i.replace(Ni, "\r\n")}
            }).get()
        }
    });
    var Ri = /%20/g, Yi = /#.*$/, Wi = /([?&])_=[^&]*/, Bi = /^(.*?):[ \t]*([^\r\n]*)$/gm, ji = /^(?:GET|HEAD)$/,
        Gi = /^\/\//, Vi = {}, qi = {}, Ui = "*/".concat("*"), Zi = A.createElement("a");

    function $i(n) {
        return function (e, t) {
            "string" != typeof e && (t = e, e = "*");
            var i, s = 0, a = e.toLowerCase().match(M) || [];
            if (b(t)) for (; i = a[s++];) "+" === i[0] ? (i = i.slice(1) || "*", (n[i] = n[i] || []).unshift(t)) : (n[i] = n[i] || []).push(t)
        }
    }

    function Qi(t, s, a, n) {
        var r = {}, o = t === qi;

        function l(e) {
            var i;
            return r[e] = !0, C.each(t[e] || [], function (e, t) {
                t = t(s, a, n);
                return "string" != typeof t || o || r[t] ? o ? !(i = t) : void 0 : (s.dataTypes.unshift(t), l(t), !1)
            }), i
        }

        return l(s.dataTypes[0]) || !r["*"] && l("*")
    }

    function Ki(e, t) {
        var i, s, a = C.ajaxSettings.flatOptions || {};
        for (i in t) void 0 !== t[i] && ((a[i] ? e : s = s || {})[i] = t[i]);
        return s && C.extend(!0, e, s), e
    }

    Zi.href = Ii.href, C.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: Ii.href,
            type: "GET",
            isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Ii.protocol),
            global: !0,
            processData: !0,
            async: !0,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": Ui,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/},
            responseFields: {xml: "responseXML", text: "responseText", json: "responseJSON"},
            converters: {"* text": String, "text html": !0, "text json": JSON.parse, "text xml": C.parseXML},
            flatOptions: {url: !0, context: !0}
        },
        ajaxSetup: function (e, t) {
            return t ? Ki(Ki(e, C.ajaxSettings), t) : Ki(C.ajaxSettings, e)
        },
        ajaxPrefilter: $i(Vi),
        ajaxTransport: $i(qi),
        ajax: function (e, t) {
            "object" == typeof e && (t = e, e = void 0);
            var l, c, h, i, d, u, g, s, a, p = C.ajaxSetup({}, t = t || {}), f = p.context || p,
                x = p.context && (f.nodeType || f.jquery) ? C(f) : C.event, m = C.Deferred(),
                b = C.Callbacks("once memory"), v = p.statusCode || {}, n = {}, r = {}, o = "canceled", y = {
                    readyState: 0, getResponseHeader: function (e) {
                        var t;
                        if (u) {
                            if (!i) for (i = {}; t = Bi.exec(h);) i[t[1].toLowerCase() + " "] = (i[t[1].toLowerCase() + " "] || []).concat(t[2]);
                            t = i[e.toLowerCase() + " "]
                        }
                        return null == t ? null : t.join(", ")
                    }, getAllResponseHeaders: function () {
                        return u ? h : null
                    }, setRequestHeader: function (e, t) {
                        return null == u && (e = r[e.toLowerCase()] = r[e.toLowerCase()] || e, n[e] = t), this
                    }, overrideMimeType: function (e) {
                        return null == u && (p.mimeType = e), this
                    }, statusCode: function (e) {
                        if (e) if (u) y.always(e[y.status]); else for (var t in e) v[t] = [v[t], e[t]];
                        return this
                    }, abort: function (e) {
                        e = e || o;
                        return l && l.abort(e), w(0, e), this
                    }
                };
            if (m.promise(y), p.url = ((e || p.url || Ii.href) + "").replace(Gi, Ii.protocol + "//"), p.type = t.method || t.type || p.method || p.type, p.dataTypes = (p.dataType || "*").toLowerCase().match(M) || [""], null == p.crossDomain) {
                a = A.createElement("a");
                try {
                    a.href = p.url, a.href = a.href, p.crossDomain = Zi.protocol + "//" + Zi.host != a.protocol + "//" + a.host
                } catch (e) {
                    p.crossDomain = !0
                }
            }
            if (p.data && p.processData && "string" != typeof p.data && (p.data = C.param(p.data, p.traditional)), Qi(Vi, p, t, y), !u) {
                for (s in (g = C.event && p.global) && 0 == C.active++ && C.event.trigger("ajaxStart"), p.type = p.type.toUpperCase(), p.hasContent = !ji.test(p.type), c = p.url.replace(Yi, ""), p.hasContent ? p.data && p.processData && 0 === (p.contentType || "").indexOf("application/x-www-form-urlencoded") && (p.data = p.data.replace(Ri, "+")) : (a = p.url.slice(c.length), p.data && (p.processData || "string" == typeof p.data) && (c += (Di.test(c) ? "&" : "?") + p.data, delete p.data), !1 === p.cache && (c = c.replace(Wi, "$1"), a = (Di.test(c) ? "&" : "?") + "_=" + Oi.guid++ + a), p.url = c + a), p.ifModified && (C.lastModified[c] && y.setRequestHeader("If-Modified-Since", C.lastModified[c]), C.etag[c]) && y.setRequestHeader("If-None-Match", C.etag[c]), (p.data && p.hasContent && !1 !== p.contentType || t.contentType) && y.setRequestHeader("Content-Type", p.contentType), y.setRequestHeader("Accept", p.dataTypes[0] && p.accepts[p.dataTypes[0]] ? p.accepts[p.dataTypes[0]] + ("*" !== p.dataTypes[0] ? ", " + Ui + "; q=0.01" : "") : p.accepts["*"]), p.headers) y.setRequestHeader(s, p.headers[s]);
                if (p.beforeSend && (!1 === p.beforeSend.call(f, y, p) || u)) return y.abort();
                if (o = "abort", b.add(p.complete), y.done(p.success), y.fail(p.error), l = Qi(qi, p, t, y)) {
                    if (y.readyState = 1, g && x.trigger("ajaxSend", [y, p]), u) return y;
                    p.async && 0 < p.timeout && (d = k.setTimeout(function () {
                        y.abort("timeout")
                    }, p.timeout));
                    try {
                        u = !1, l.send(n, w)
                    } catch (e) {
                        if (u) throw e;
                        w(-1, e)
                    }
                } else w(-1, "No Transport")
            }
            return y;

            function w(e, t, i, s) {
                var a, n, r, o = t;
                u || (u = !0, d && k.clearTimeout(d), l = void 0, h = s || "", y.readyState = 0 < e ? 4 : 0, s = 200 <= e && e < 300 || 304 === e, i && (r = ((e, t, i) => {
                    for (var s, a, n, r, o = e.contents, l = e.dataTypes; "*" === l[0];) l.shift(), void 0 === s && (s = e.mimeType || t.getResponseHeader("Content-Type"));
                    if (s) for (a in o) if (o[a] && o[a].test(s)) {
                        l.unshift(a);
                        break
                    }
                    if (l[0] in i) n = l[0]; else {
                        for (a in i) {
                            if (!l[0] || e.converters[a + " " + l[0]]) {
                                n = a;
                                break
                            }
                            r = r || a
                        }
                        n = n || r
                    }
                    if (n) return n !== l[0] && l.unshift(n), i[n]
                })(p, y, i)), !s && -1 < C.inArray("script", p.dataTypes) && C.inArray("json", p.dataTypes) < 0 && (p.converters["text script"] = function () {
                }), r = ((e, t, i, s) => {
                    var a, n, r, o, l, c = {}, h = e.dataTypes.slice();
                    if (h[1]) for (r in e.converters) c[r.toLowerCase()] = e.converters[r];
                    for (n = h.shift(); n;) if (e.responseFields[n] && (i[e.responseFields[n]] = t), !l && s && e.dataFilter && (t = e.dataFilter(t, e.dataType)), l = n, n = h.shift()) if ("*" === n) n = l; else if ("*" !== l && l !== n) {
                        if (!(r = c[l + " " + n] || c["* " + n])) for (a in c) if ((o = a.split(" "))[1] === n && (r = c[l + " " + o[0]] || c["* " + o[0]])) {
                            !0 === r ? r = c[a] : !0 !== c[a] && (n = o[0], h.unshift(o[1]));
                            break
                        }
                        if (!0 !== r) if (r && e.throws) t = r(t); else try {
                            t = r(t)
                        } catch (e) {
                            return {state: "parsererror", error: r ? e : "No conversion from " + l + " to " + n}
                        }
                    }
                    return {state: "success", data: t}
                })(p, r, y, s), s ? (p.ifModified && ((i = y.getResponseHeader("Last-Modified")) && (C.lastModified[c] = i), i = y.getResponseHeader("etag")) && (C.etag[c] = i), 204 === e || "HEAD" === p.type ? o = "nocontent" : 304 === e ? o = "notmodified" : (o = r.state, a = r.data, s = !(n = r.error))) : (n = o, !e && o || (o = "error", e < 0 && (e = 0))), y.status = e, y.statusText = (t || o) + "", s ? m.resolveWith(f, [a, o, y]) : m.rejectWith(f, [y, o, n]), y.statusCode(v), v = void 0, g && x.trigger(s ? "ajaxSuccess" : "ajaxError", [y, p, s ? a : n]), b.fireWith(f, [y, o]), g && (x.trigger("ajaxComplete", [y, p]), --C.active || C.event.trigger("ajaxStop")))
            }
        },
        getJSON: function (e, t, i) {
            return C.get(e, t, i, "json")
        },
        getScript: function (e, t) {
            return C.get(e, void 0, t, "script")
        }
    }), C.each(["get", "post"], function (e, a) {
        C[a] = function (e, t, i, s) {
            return b(t) && (s = s || i, i = t, t = void 0), C.ajax(C.extend({
                url: e,
                type: a,
                dataType: s,
                data: t,
                success: i
            }, C.isPlainObject(e) && e))
        }
    }), C.ajaxPrefilter(function (e) {
        for (var t in e.headers) "content-type" === t.toLowerCase() && (e.contentType = e.headers[t] || "")
    }), C._evalUrl = function (e, t, i) {
        return C.ajax({
            url: e,
            type: "GET",
            dataType: "script",
            cache: !0,
            async: !1,
            global: !1,
            converters: {
                "text script": function () {
                }
            },
            dataFilter: function (e) {
                C.globalEval(e, t, i)
            }
        })
    }, C.fn.extend({
        wrapAll: function (e) {
            return this[0] && (b(e) && (e = e.call(this[0])), e = C(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && e.insertBefore(this[0]), e.map(function () {
                for (var e = this; e.firstElementChild;) e = e.firstElementChild;
                return e
            }).append(this)), this
        }, wrapInner: function (i) {
            return b(i) ? this.each(function (e) {
                C(this).wrapInner(i.call(this, e))
            }) : this.each(function () {
                var e = C(this), t = e.contents();
                t.length ? t.wrapAll(i) : e.append(i)
            })
        }, wrap: function (t) {
            var i = b(t);
            return this.each(function (e) {
                C(this).wrapAll(i ? t.call(this, e) : t)
            })
        }, unwrap: function (e) {
            return this.parent(e).not("body").each(function () {
                C(this).replaceWith(this.childNodes)
            }), this
        }
    }), C.expr.pseudos.hidden = function (e) {
        return !C.expr.pseudos.visible(e)
    }, C.expr.pseudos.visible = function (e) {
        return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length)
    }, C.ajaxSettings.xhr = function () {
        try {
            return new k.XMLHttpRequest
        } catch (e) {
        }
    };
    var Ji = {0: 200, 1223: 204}, es = C.ajaxSettings.xhr();
    f.cors = !!es && "withCredentials" in es, f.ajax = es = !!es, C.ajaxTransport(function (a) {
        var n, r;
        if (f.cors || es && !a.crossDomain) return {
            send: function (e, t) {
                var i, s = a.xhr();
                if (s.open(a.type, a.url, a.async, a.username, a.password), a.xhrFields) for (i in a.xhrFields) s[i] = a.xhrFields[i];
                for (i in a.mimeType && s.overrideMimeType && s.overrideMimeType(a.mimeType), a.crossDomain || e["X-Requested-With"] || (e["X-Requested-With"] = "XMLHttpRequest"), e) s.setRequestHeader(i, e[i]);
                n = function (e) {
                    return function () {
                        n && (n = r = s.onload = s.onerror = s.onabort = s.ontimeout = s.onreadystatechange = null, "abort" === e ? s.abort() : "error" === e ? "number" != typeof s.status ? t(0, "error") : t(s.status, s.statusText) : t(Ji[s.status] || s.status, s.statusText, "text" !== (s.responseType || "text") || "string" != typeof s.responseText ? {binary: s.response} : {text: s.responseText}, s.getAllResponseHeaders()))
                    }
                }, s.onload = n(), r = s.onerror = s.ontimeout = n("error"), void 0 !== s.onabort ? s.onabort = r : s.onreadystatechange = function () {
                    4 === s.readyState && k.setTimeout(function () {
                        n && r()
                    })
                }, n = n("abort");
                try {
                    s.send(a.hasContent && a.data || null)
                } catch (e) {
                    if (n) throw e
                }
            }, abort: function () {
                n && n()
            }
        }
    }), C.ajaxPrefilter(function (e) {
        e.crossDomain && (e.contents.script = !1)
    }), C.ajaxSetup({
        accepts: {script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},
        contents: {script: /\b(?:java|ecma)script\b/},
        converters: {
            "text script": function (e) {
                return C.globalEval(e), e
            }
        }
    }), C.ajaxPrefilter("script", function (e) {
        void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET")
    }), C.ajaxTransport("script", function (i) {
        var s, a;
        if (i.crossDomain || i.scriptAttrs) return {
            send: function (e, t) {
                s = C("<script>").attr(i.scriptAttrs || {}).prop({
                    charset: i.scriptCharset,
                    src: i.url
                }).on("load error", a = function (e) {
                    s.remove(), a = null, e && t("error" === e.type ? 404 : 200, e.type)
                }), A.head.appendChild(s[0])
            }, abort: function () {
                a && a()
            }
        }
    });
    var ts = [], is = /(=)\?(?=&|$)|\?\?/, ss = (C.ajaxSetup({
        jsonp: "callback", jsonpCallback: function () {
            var e = ts.pop() || C.expando + "_" + Oi.guid++;
            return this[e] = !0, e
        }
    }), C.ajaxPrefilter("json jsonp", function (e, t, i) {
        var s, a, n,
            r = !1 !== e.jsonp && (is.test(e.url) ? "url" : "string" == typeof e.data && 0 === (e.contentType || "").indexOf("application/x-www-form-urlencoded") && is.test(e.data) && "data");
        if (r || "jsonp" === e.dataTypes[0]) return s = e.jsonpCallback = b(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, r ? e[r] = e[r].replace(is, "$1" + s) : !1 !== e.jsonp && (e.url += (Di.test(e.url) ? "&" : "?") + e.jsonp + "=" + s), e.converters["script json"] = function () {
            return n || C.error(s + " was not called"), n[0]
        }, e.dataTypes[0] = "json", a = k[s], k[s] = function () {
            n = arguments
        }, i.always(function () {
            void 0 === a ? C(k).removeProp(s) : k[s] = a, e[s] && (e.jsonpCallback = t.jsonpCallback, ts.push(s)), n && b(a) && a(n[0]), n = a = void 0
        }), "script"
    }), f.createHTMLDocument = ((e = A.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === e.childNodes.length), C.parseHTML = function (e, t, i) {
        return "string" != typeof e ? [] : ("boolean" == typeof t && (i = t, t = !1), t || (f.createHTMLDocument ? ((s = (t = A.implementation.createHTMLDocument("")).createElement("base")).href = A.location.href, t.head.appendChild(s)) : t = A), s = !i && [], (i = qe.exec(e)) ? [t.createElement(i[1])] : (i = Et([e], t, s), s && s.length && C(s).remove(), C.merge([], i.childNodes)));
        var s
    }, C.fn.load = function (e, t, i) {
        var s, a, n, r = this, o = e.indexOf(" ");
        return -1 < o && (s = Ti(e.slice(o)), e = e.slice(0, o)), b(t) ? (i = t, t = void 0) : t && "object" == typeof t && (a = "POST"), 0 < r.length && C.ajax({
            url: e,
            type: a || "GET",
            dataType: "html",
            data: t
        }).done(function (e) {
            n = arguments, r.html(s ? C("<div>").append(C.parseHTML(e)).find(s) : e)
        }).always(i && function (e, t) {
            r.each(function () {
                i.apply(this, n || [e.responseText, t, e])
            })
        }), this
    }, C.expr.pseudos.animated = function (t) {
        return C.grep(C.timers, function (e) {
            return t === e.elem
        }).length
    }, C.offset = {
        setOffset: function (e, t, i) {
            var s, a, n, r, o = C.css(e, "position"), l = C(e), c = {};
            "static" === o && (e.style.position = "relative"), n = l.offset(), s = C.css(e, "top"), r = C.css(e, "left"), o = ("absolute" === o || "fixed" === o) && -1 < (s + r).indexOf("auto") ? (a = (o = l.position()).top, o.left) : (a = parseFloat(s) || 0, parseFloat(r) || 0), null != (t = b(t) ? t.call(e, i, C.extend({}, n)) : t).top && (c.top = t.top - n.top + a), null != t.left && (c.left = t.left - n.left + o), "using" in t ? t.using.call(e, c) : l.css(c)
        }
    }, C.fn.extend({
        offset: function (t) {
            var e, i;
            return arguments.length ? void 0 === t ? this : this.each(function (e) {
                C.offset.setOffset(this, t, e)
            }) : (i = this[0]) ? i.getClientRects().length ? (e = i.getBoundingClientRect(), i = i.ownerDocument.defaultView, {
                top: e.top + i.pageYOffset,
                left: e.left + i.pageXOffset
            }) : {top: 0, left: 0} : void 0
        }, position: function () {
            if (this[0]) {
                var e, t, i, s = this[0], a = {top: 0, left: 0};
                if ("fixed" === C.css(s, "position")) t = s.getBoundingClientRect(); else {
                    for (t = this.offset(), i = s.ownerDocument, e = s.offsetParent || i.documentElement; e && (e === i.body || e === i.documentElement) && "static" === C.css(e, "position");) e = e.parentNode;
                    e && e !== s && 1 === e.nodeType && ((a = C(e).offset()).top += C.css(e, "borderTopWidth", !0), a.left += C.css(e, "borderLeftWidth", !0))
                }
                return {
                    top: t.top - a.top - C.css(s, "marginTop", !0),
                    left: t.left - a.left - C.css(s, "marginLeft", !0)
                }
            }
        }, offsetParent: function () {
            return this.map(function () {
                for (var e = this.offsetParent; e && "static" === C.css(e, "position");) e = e.offsetParent;
                return e || mt
            })
        }
    }), C.each({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function (t, a) {
        var n = "pageYOffset" === a;
        C.fn[t] = function (e) {
            return h(this, function (e, t, i) {
                var s;
                if (N(e) ? s = e : 9 === e.nodeType && (s = e.defaultView), void 0 === i) return s ? s[a] : e[t];
                s ? s.scrollTo(n ? s.pageXOffset : i, n ? i : s.pageYOffset) : e[t] = i
            }, t, e, arguments.length)
        }
    }), C.each(["top", "left"], function (e, i) {
        C.cssHooks[i] = ii(f.pixelPosition, function (e, t) {
            if (t) return t = ti(e, i), Kt.test(t) ? C(e).position()[i] + "px" : t
        })
    }), C.each({Height: "height", Width: "width"}, function (r, o) {
        C.each({padding: "inner" + r, content: o, "": "outer" + r}, function (s, n) {
            C.fn[n] = function (e, t) {
                var i = arguments.length && (s || "boolean" != typeof e),
                    a = s || (!0 === e || !0 === t ? "margin" : "border");
                return h(this, function (e, t, i) {
                    var s;
                    return N(e) ? 0 === n.indexOf("outer") ? e["inner" + r] : e.document.documentElement["client" + r] : 9 === e.nodeType ? (s = e.documentElement, Math.max(e.body["scroll" + r], s["scroll" + r], e.body["offset" + r], s["offset" + r], s["client" + r])) : void 0 === i ? C.css(e, t, a) : C.style(e, t, i, a)
                }, o, i ? e : void 0, i)
            }
        })
    }), C.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (e, t) {
        C.fn[t] = function (e) {
            return this.on(t, e)
        }
    }), C.fn.extend({
        bind: function (e, t, i) {
            return this.on(e, null, t, i)
        }, unbind: function (e, t) {
            return this.off(e, null, t)
        }, delegate: function (e, t, i, s) {
            return this.on(t, e, i, s)
        }, undelegate: function (e, t, i) {
            return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", i)
        }, hover: function (e, t) {
            return this.on("mouseenter", e).on("mouseleave", t || e)
        }
    }), C.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function (e, i) {
        C.fn[i] = function (e, t) {
            return 0 < arguments.length ? this.on(i, null, e, t) : this.trigger(i)
        }
    }), /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g), as = (C.proxy = function (e, t) {
        var i, s;
        if ("string" == typeof t && (s = e[t], t = e, e = s), b(e)) return i = o.call(arguments, 2), (s = function () {
            return e.apply(t || this, i.concat(o.call(arguments)))
        }).guid = e.guid = e.guid || C.guid++, s
    }, C.holdReady = function (e) {
        e ? C.readyWait++ : C.ready(!0)
    }, C.isArray = Array.isArray, C.parseJSON = JSON.parse, C.nodeName = v, C.isFunction = b, C.isWindow = N, C.camelCase = I, C.type = U, C.now = Date.now, C.isNumeric = function (e) {
        var t = C.type(e);
        return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e))
    }, C.trim = function (e) {
        return null == e ? "" : (e + "").replace(ss, "$1")
    }, "function" == typeof define && define.amd && define("jquery", [], function () {
        return C
    }), k.jQuery), ns = k.$;
    return C.noConflict = function (e) {
        return k.$ === C && (k.$ = ns), e && k.jQuery === C && (k.jQuery = as), C
    }, void 0 === X && (k.jQuery = k.$ = C), C
}), ((e, t) => {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).bootstrap = t()
})(this, function () {
    let s = new Map, X = {
            set(e, t, i) {
                s.has(e) || s.set(e, new Map);
                e = s.get(e);
                e.has(t) || 0 === e.size ? e.set(t, i) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(e.keys())[0]}.`)
            }, get: (e, t) => s.has(e) && s.get(e).get(t) || null, remove(e, t) {
                var i;
                s.has(e) && ((i = s.get(e)).delete(t), 0 === i.size) && s.delete(e)
            }
        }, N = "transitionend",
        F = e => e = e && window.CSS && window.CSS.escape ? e.replace(/#([^\s"#']+)/g, (e, t) => "#" + CSS.escape(t)) : e,
        H = e => {
            e.dispatchEvent(new Event(N))
        }, r = e => !(!e || "object" != typeof e) && void 0 !== (e = void 0 !== e.jquery ? e[0] : e).nodeType,
        a = e => r(e) ? e.jquery ? e[0] : e : "string" == typeof e && 0 < e.length ? document.querySelector(F(e)) : null,
        n = t => {
            if (!r(t) || 0 === t.getClientRects().length) return !1;
            let e = "visible" === getComputedStyle(t).getPropertyValue("visibility"),
                i = t.closest("details:not([open])");
            if (i && i !== t) {
                let e = t.closest("summary");
                if (e && e.parentNode !== i) return !1;
                if (null === e) return !1
            }
            return e
        },
        o = e => !e || e.nodeType !== Node.ELEMENT_NODE || !!e.classList.contains("disabled") || (void 0 !== e.disabled ? e.disabled : e.hasAttribute("disabled") && "false" !== e.getAttribute("disabled")),
        R = e => {
            var t;
            return document.documentElement.attachShadow ? "function" == typeof e.getRootNode ? (t = e.getRootNode()) instanceof ShadowRoot ? t : null : e instanceof ShadowRoot ? e : e.parentNode ? R(e.parentNode) : null : null
        }, Y = () => {
        }, W = e => {
            e.offsetHeight
        }, B = () => window.jQuery && !document.body.hasAttribute("data-bs-no-jquery") ? window.jQuery : null, j = [],
        l = () => "rtl" === document.documentElement.dir, e = s => {
            var e = () => {
                let i = B();
                if (i) {
                    let e = s.NAME, t = i.fn[e];
                    i.fn[e] = s.jQueryInterface, i.fn[e].Constructor = s, i.fn[e].noConflict = () => (i.fn[e] = t, s.jQueryInterface)
                }
            };
            "loading" === document.readyState ? (j.length || document.addEventListener("DOMContentLoaded", () => {
                for (var e of j) e()
            }), j.push(e)) : e()
        }, c = (e, t = [], i = e) => "function" == typeof e ? e(...t) : i, G = (s, a, e = !0) => {
            if (e) {
                e = (() => {
                    if (!a) return 0;
                    let {transitionDuration: e, transitionDelay: t} = window.getComputedStyle(a);
                    var i = Number.parseFloat(e), s = Number.parseFloat(t);
                    return i || s ? (e = e.split(",")[0], t = t.split(",")[0], 1e3 * (Number.parseFloat(e) + Number.parseFloat(t))) : 0
                })() + 5;
                let t = !1, i = ({target: e}) => {
                    e === a && (t = !0, a.removeEventListener(N, i), c(s))
                };
                a.addEventListener(N, i), setTimeout(() => {
                    t || H(a)
                }, e)
            } else c(s)
        }, V = (e, t, i, s) => {
            var a = e.length;
            let n = e.indexOf(t);
            return -1 === n ? !i && s ? e[a - 1] : e[0] : (n += i ? 1 : -1, s && (n = (n + a) % a), e[Math.max(0, Math.min(n, a - 1))])
        }, q = /[^.]*(?=\..*)\.|.*/, U = /\..*/, Z = /::\d+$/, $ = {}, Q = 1,
        K = {mouseenter: "mouseover", mouseleave: "mouseout"},
        J = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);

    function ee(e, t) {
        return t && t + "::" + Q++ || e.uidEvent || Q++
    }

    function te(e) {
        var t = ee(e);
        return e.uidEvent = t, $[t] = $[t] || {}, $[t]
    }

    function ie(e, t, i = null) {
        return Object.values(e).find(e => e.callable === t && e.delegationSelector === i)
    }

    function se(e, t, i) {
        var s = "string" == typeof t, t = !s && t || i;
        let a = re(e);
        return [s, t, a = J.has(a) ? a : e]
    }

    function ae(s, a, n, r, o) {
        if ("string" == typeof a && s) {
            let [e, t, i] = se(a, n, r);
            if (a in K) {
                let e = t => function (e) {
                    if (!e.relatedTarget || e.relatedTarget !== e.delegateTarget && !e.delegateTarget.contains(e.relatedTarget)) return t.call(this, e)
                };
                t = e(t)
            }
            var r = te(s), r = r[i] || (r[i] = {}), l = ie(r, t, e ? n : null);
            if (l) return l.oneOff = l.oneOff && o;
            var c, h, d, u, g, l = ee(t, a.replace(q, "")), a = e ? (d = s, u = n, g = t, function t(i) {
                var s = d.querySelectorAll(u);
                for (let e = i.target; e && e !== this; e = e.parentNode) for (var a of s) if (a === e) return oe(i, {delegateTarget: e}), t.oneOff && p.off(d, i.type, u, g), g.apply(e, [i])
            }) : (c = s, h = t, function e(t) {
                return oe(t, {delegateTarget: c}), e.oneOff && p.off(c, t.type, h), h.apply(c, [t])
            });
            a.delegationSelector = e ? n : null, a.callable = t, a.oneOff = o, r[a.uidEvent = l] = a, s.addEventListener(i, a, e)
        }
    }

    function ne(e, t, i, s, a) {
        s = ie(t[i], s, a);
        s && (e.removeEventListener(i, s, Boolean(a)), delete t[i][s.uidEvent])
    }

    function re(e) {
        return e = e.replace(U, ""), K[e] || e
    }

    let p = {
        on(e, t, i, s) {
            ae(e, t, i, s, !1)
        }, one(e, t, i, s) {
            ae(e, t, i, s, !0)
        }, off(o, l, c, h) {
            if ("string" == typeof l && o) {
                let [e, t, s] = se(l, c, h), a = s !== l, n = te(o), r = n[s] || {}, i = l.startsWith(".");
                if (void 0 === t) {
                    if (i) for (let e of Object.keys(n)) {
                        d = void 0;
                        u = void 0;
                        g = void 0;
                        p = void 0;
                        m = void 0;
                        f = void 0;
                        x = void 0;
                        var d = o;
                        var u = n;
                        var g = e;
                        var p = l.slice(1);
                        var f, x, m = u[g] || {};
                        for ([f, x] of Object.entries(m)) f.includes(p) && ne(d, u, g, x.callable, x.delegationSelector)
                    }
                    for (let [t, i] of Object.entries(r)) {
                        let e = t.replace(Z, "");
                        a && !l.includes(e) || ne(o, n, s, i.callable, i.delegationSelector)
                    }
                } else Object.keys(r).length && ne(o, n, s, t, e ? c : null)
            }
        }, trigger(e, t, i) {
            if ("string" != typeof t || !e) return null;
            var s = B();
            let a = null, n = !0, r = !0, o = !1;
            t !== re(t) && s && (a = s.Event(t, i), s(e).trigger(a), n = !a.isPropagationStopped(), r = !a.isImmediatePropagationStopped(), o = a.isDefaultPrevented());
            s = oe(new Event(t, {bubbles: n, cancelable: !0}), i);
            return o && s.preventDefault(), r && e.dispatchEvent(s), s.defaultPrevented && a && a.preventDefault(), s
        }
    };

    function oe(i, s = {}) {
        for (let [e, t] of Object.entries(s)) try {
            i[e] = t
        } catch (s) {
            Object.defineProperty(i, e, {configurable: !0, get: () => t})
        }
        return i
    }

    function le(t) {
        if ("true" === t) return !0;
        if ("false" === t) return !1;
        if (t === Number(t).toString()) return Number(t);
        if ("" === t || "null" === t) return null;
        if ("string" != typeof t) return t;
        try {
            return JSON.parse(decodeURIComponent(t))
        } catch (e) {
            return t
        }
    }

    function ce(e) {
        return e.replace(/[A-Z]/g, e => "-" + e.toLowerCase())
    }

    let h = {
        setDataAttribute(e, t, i) {
            e.setAttribute("data-bs-" + ce(t), i)
        }, removeDataAttribute(e, t) {
            e.removeAttribute("data-bs-" + ce(t))
        }, getDataAttributes(t) {
            if (!t) return {};
            var i, s = {};
            for (i of Object.keys(t.dataset).filter(e => e.startsWith("bs") && !e.startsWith("bsConfig"))) {
                let e = i.replace(/^bs/, "");
                s[e = e.charAt(0).toLowerCase() + e.slice(1, e.length)] = le(t.dataset[i])
            }
            return s
        }, getDataAttribute: (e, t) => le(e.getAttribute("data-bs-" + ce(t)))
    };

    class he {
        static get Default() {
            return {}
        }

        static get DefaultType() {
            return {}
        }

        static get NAME() {
            throw new Error('You have to implement the static method "NAME", for each component!')
        }

        _getConfig(e) {
            return e = this._mergeConfigObj(e), e = this._configAfterMerge(e), this._typeCheckConfig(e), e
        }

        _configAfterMerge(e) {
            return e
        }

        _mergeConfigObj(e, t) {
            var i = r(t) ? h.getDataAttribute(t, "config") : {};
            return {...this.constructor.Default, ..."object" == typeof i ? i : {}, ...r(t) ? h.getDataAttributes(t) : {}, ..."object" == typeof e ? e : {}}
        }

        _typeCheckConfig(i, e = this.constructor.DefaultType) {
            for (var [s, a] of Object.entries(e)) {
                let e = i[s],
                    t = r(e) ? "element" : null == (n = e) ? "" + n : Object.prototype.toString.call(n).match(/\s([a-z]+)/i)[1].toLowerCase();
                if (!new RegExp(a).test(t)) throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${s}" provided type "${t}" but expected type "${a}".`)
            }
            var n
        }
    }

    class t extends he {
        constructor(e, t) {
            super(), (e = a(e)) && (this._element = e, this._config = this._getConfig(t), X.set(this._element, this.constructor.DATA_KEY, this))
        }

        dispose() {
            X.remove(this._element, this.constructor.DATA_KEY), p.off(this._element, this.constructor.EVENT_KEY);
            for (var e of Object.getOwnPropertyNames(this)) this[e] = null
        }

        _queueCallback(e, t, i = !0) {
            G(e, t, i)
        }

        _getConfig(e) {
            return e = this._mergeConfigObj(e, this._element), e = this._configAfterMerge(e), this._typeCheckConfig(e), e
        }

        static getInstance(e) {
            return X.get(a(e), this.DATA_KEY)
        }

        static getOrCreateInstance(e, t = {}) {
            return this.getInstance(e) || new this(e, "object" == typeof t ? t : null)
        }

        static get VERSION() {
            return "5.3.3"
        }

        static get DATA_KEY() {
            return "bs." + this.NAME
        }

        static get EVENT_KEY() {
            return "." + this.DATA_KEY
        }

        static eventName(e) {
            return "" + e + this.EVENT_KEY
        }
    }

    let de = t => {
        let i = t.getAttribute("data-bs-target");
        if (!i || "#" === i) {
            let e = t.getAttribute("href");
            if (!e || !e.includes("#") && !e.startsWith(".")) return null;
            e.includes("#") && !e.startsWith("#") && (e = "#" + e.split("#")[1]), i = e && "#" !== e ? e.trim() : null
        }
        return i ? i.split(",").map(e => F(e)).join(",") : null
    }, d = {
        find: (e, t = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(t, e)),
        findOne: (e, t = document.documentElement) => Element.prototype.querySelector.call(t, e),
        children: (e, t) => [].concat(...e.children).filter(e => e.matches(t)),
        parents(e, t) {
            var i = [];
            let s = e.parentNode.closest(t);
            for (; s;) i.push(s), s = s.parentNode.closest(t);
            return i
        },
        prev(e, t) {
            let i = e.previousElementSibling;
            for (; i;) {
                if (i.matches(t)) return [i];
                i = i.previousElementSibling
            }
            return []
        },
        next(e, t) {
            let i = e.nextElementSibling;
            for (; i;) {
                if (i.matches(t)) return [i];
                i = i.nextElementSibling
            }
            return []
        },
        focusableChildren(e) {
            var t = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map(e => e + ':not([tabindex^="-"])').join(",");
            return this.find(t, e).filter(e => !o(e) && n(e))
        },
        getSelectorFromElement(e) {
            e = de(e);
            return e && d.findOne(e) ? e : null
        },
        getElementFromSelector(e) {
            e = de(e);
            return e ? d.findOne(e) : null
        },
        getMultipleElementsFromSelector(e) {
            e = de(e);
            return e ? d.find(e) : []
        }
    }, ue = (t, i = "hide") => {
        let e = "click.dismiss" + t.EVENT_KEY, s = t.NAME;
        p.on(document, e, `[data-bs-dismiss="${s}"]`, function (e) {
            ["A", "AREA"].includes(this.tagName) && e.preventDefault(), o(this) || (e = d.getElementFromSelector(this) || this.closest("." + s), t.getOrCreateInstance(e)[i]())
        })
    };

    class ge extends t {
        static get NAME() {
            return "alert"
        }

        close() {
            var e;
            p.trigger(this._element, "close.bs.alert").defaultPrevented || (this._element.classList.remove("show"), e = this._element.classList.contains("fade"), this._queueCallback(() => this._destroyElement(), this._element, e))
        }

        _destroyElement() {
            this._element.remove(), p.trigger(this._element, "closed.bs.alert"), this.dispose()
        }

        static jQueryInterface(t) {
            return this.each(function () {
                var e = ge.getOrCreateInstance(this);
                if ("string" == typeof t) {
                    if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
                    e[t](this)
                }
            })
        }
    }

    ue(ge, "close"), e(ge);
    let pe = '[data-bs-toggle="button"]';

    class fe extends t {
        static get NAME() {
            return "button"
        }

        toggle() {
            this._element.setAttribute("aria-pressed", this._element.classList.toggle("active"))
        }

        static jQueryInterface(t) {
            return this.each(function () {
                var e = fe.getOrCreateInstance(this);
                "toggle" === t && e[t]()
            })
        }
    }

    p.on(document, "click.bs.button.data-api", pe, e => {
        e.preventDefault();
        e = e.target.closest(pe);
        fe.getOrCreateInstance(e).toggle()
    }), e(fe);
    let i = ".bs.swipe", xe = (i, i, i, i, i, {endCallback: null, leftCallback: null, rightCallback: null}),
        me = {endCallback: "(function|null)", leftCallback: "(function|null)", rightCallback: "(function|null)"};

    class be extends he {
        constructor(e, t) {
            super(), (this._element = e) && be.isSupported() && (this._config = this._getConfig(t), this._deltaX = 0, this._supportPointerEvents = Boolean(window.PointerEvent), this._initEvents())
        }

        static get Default() {
            return xe
        }

        static get DefaultType() {
            return me
        }

        static get NAME() {
            return "swipe"
        }

        dispose() {
            p.off(this._element, i)
        }

        _start(e) {
            this._supportPointerEvents ? this._eventIsPointerPenTouch(e) && (this._deltaX = e.clientX) : this._deltaX = e.touches[0].clientX
        }

        _end(e) {
            this._eventIsPointerPenTouch(e) && (this._deltaX = e.clientX - this._deltaX), this._handleSwipe(), c(this._config.endCallback)
        }

        _move(e) {
            this._deltaX = e.touches && 1 < e.touches.length ? 0 : e.touches[0].clientX - this._deltaX
        }

        _handleSwipe() {
            var e = Math.abs(this._deltaX);
            e <= 40 || (e = e / this._deltaX, this._deltaX = 0, e && c(0 < e ? this._config.rightCallback : this._config.leftCallback))
        }

        _initEvents() {
            this._supportPointerEvents ? (p.on(this._element, "pointerdown.bs.swipe", e => this._start(e)), p.on(this._element, "pointerup.bs.swipe", e => this._end(e)), this._element.classList.add("pointer-event")) : (p.on(this._element, "touchstart.bs.swipe", e => this._start(e)), p.on(this._element, "touchmove.bs.swipe", e => this._move(e)), p.on(this._element, "touchend.bs.swipe", e => this._end(e)))
        }

        _eventIsPointerPenTouch(e) {
            return this._supportPointerEvents && ("pen" === e.pointerType || "touch" === e.pointerType)
        }

        static isSupported() {
            return "ontouchstart" in document.documentElement || 0 < navigator.maxTouchPoints
        }
    }

    let ve = ".bs.carousel", ye = "next", u = "prev", g = "left", we = "right", ke = "slid" + ve, Ae = "carousel",
        Ce = "active", Se = ".active", Le = ".carousel-item", Te = (Se, Le, {ArrowLeft: we, ArrowRight: g}),
        Ee = {interval: 5e3, keyboard: !0, pause: "hover", ride: !1, touch: !0, wrap: !0}, Pe = {
            interval: "(number|boolean)",
            keyboard: "boolean",
            pause: "(string|boolean)",
            ride: "(boolean|string)",
            touch: "boolean",
            wrap: "boolean"
        };

    class _e extends t {
        constructor(e, t) {
            super(e, t), this._interval = null, this._activeElement = null, this._isSliding = !1, this.touchTimeout = null, this._swipeHelper = null, this._indicatorsElement = d.findOne(".carousel-indicators", this._element), this._addEventListeners(), this._config.ride === Ae && this.cycle()
        }

        static get Default() {
            return Ee
        }

        static get DefaultType() {
            return Pe
        }

        static get NAME() {
            return "carousel"
        }

        next() {
            this._slide(ye)
        }

        nextWhenVisible() {
            !document.hidden && n(this._element) && this.next()
        }

        prev() {
            this._slide(u)
        }

        pause() {
            this._isSliding && H(this._element), this._clearInterval()
        }

        cycle() {
            this._clearInterval(), this._updateInterval(), this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval)
        }

        _maybeEnableCycle() {
            this._config.ride && (this._isSliding ? p.one(this._element, ke, () => this.cycle()) : this.cycle())
        }

        to(e) {
            var t, i = this._getItems();
            e > i.length - 1 || e < 0 || (this._isSliding ? p.one(this._element, ke, () => this.to(e)) : (t = this._getItemIndex(this._getActive())) !== e && (t = t < e ? ye : u, this._slide(t, i[e])))
        }

        dispose() {
            this._swipeHelper && this._swipeHelper.dispose(), super.dispose()
        }

        _configAfterMerge(e) {
            return e.defaultInterval = e.interval, e
        }

        _addEventListeners() {
            this._config.keyboard && p.on(this._element, "keydown.bs.carousel", e => this._keydown(e)), "hover" === this._config.pause && (p.on(this._element, "mouseenter.bs.carousel", () => this.pause()), p.on(this._element, "mouseleave.bs.carousel", () => this._maybeEnableCycle())), this._config.touch && be.isSupported() && this._addTouchEventListeners()
        }

        _addTouchEventListeners() {
            for (let e of d.find(".carousel-item img", this._element)) p.on(e, "dragstart.bs.carousel", e => e.preventDefault());
            let e = {
                leftCallback: () => this._slide(this._directionToOrder(g)),
                rightCallback: () => this._slide(this._directionToOrder(we)),
                endCallback: () => {
                    "hover" === this._config.pause && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), 500 + this._config.interval))
                }
            };
            this._swipeHelper = new be(this._element, e)
        }

        _keydown(e) {
            var t;
            /input|textarea/i.test(e.target.tagName) || (t = Te[e.key]) && (e.preventDefault(), this._slide(this._directionToOrder(t)))
        }

        _getItemIndex(e) {
            return this._getItems().indexOf(e)
        }

        _setActiveIndicatorElement(e) {
            var t;
            this._indicatorsElement && ((t = d.findOne(Se, this._indicatorsElement)).classList.remove(Ce), t.removeAttribute("aria-current"), t = d.findOne(`[data-bs-slide-to="${e}"]`, this._indicatorsElement)) && (t.classList.add(Ce), t.setAttribute("aria-current", "true"))
        }

        _updateInterval() {
            var e = this._activeElement || this._getActive();
            e && (e = Number.parseInt(e.getAttribute("data-bs-interval"), 10), this._config.interval = e || this._config.defaultInterval)
        }

        _slide(t, o = null) {
            if (!this._isSliding) {
                let a = this._getActive(), n = t === ye, r = o || V(this._getItems(), a, n, this._config.wrap);
                if (r !== a) {
                    let i = this._getItemIndex(r), s = e => p.trigger(this._element, e, {
                        relatedTarget: r,
                        direction: this._orderToDirection(t),
                        from: this._getItemIndex(a),
                        to: i
                    });
                    if (!s("slide.bs.carousel").defaultPrevented && a && r) {
                        o = Boolean(this._interval);
                        this.pause(), this._isSliding = !0, this._setActiveIndicatorElement(i), this._activeElement = r;
                        let e = n ? "carousel-item-start" : "carousel-item-end",
                            t = n ? "carousel-item-next" : "carousel-item-prev";
                        r.classList.add(t), W(r), a.classList.add(e), r.classList.add(e), this._queueCallback(() => {
                            r.classList.remove(e, t), r.classList.add(Ce), a.classList.remove(Ce, t, e), this._isSliding = !1, s(ke)
                        }, a, this._isAnimated()), o && this.cycle()
                    }
                }
            }
        }

        _isAnimated() {
            return this._element.classList.contains("slide")
        }

        _getActive() {
            return d.findOne(".active.carousel-item", this._element)
        }

        _getItems() {
            return d.find(Le, this._element)
        }

        _clearInterval() {
            this._interval && (clearInterval(this._interval), this._interval = null)
        }

        _directionToOrder(e) {
            return l() ? e === g ? u : ye : e === g ? ye : u
        }

        _orderToDirection(e) {
            return l() ? e === u ? g : we : e === u ? we : g
        }

        static jQueryInterface(t) {
            return this.each(function () {
                var e = _e.getOrCreateInstance(this, t);
                if ("number" != typeof t) {
                    if ("string" == typeof t) {
                        if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
                        e[t]()
                    }
                } else e.to(t)
            })
        }
    }

    p.on(document, "click.bs.carousel.data-api", "[data-bs-slide], [data-bs-slide-to]", function (e) {
        var t = d.getElementFromSelector(this);
        t && t.classList.contains(Ae) && (e.preventDefault(), e = _e.getOrCreateInstance(t), (t = this.getAttribute("data-bs-slide-to")) ? e.to(t) : "next" === h.getDataAttribute(this, "slide") ? e.next() : e.prev(), e._maybeEnableCycle())
    }), p.on(window, "load.bs.carousel.data-api", () => {
        var e;
        for (e of d.find('[data-bs-ride="carousel"]')) _e.getOrCreateInstance(e)
    }), e(_e);
    let Me = "show", f = "collapse", Ie = "collapsing", Oe = (f, f, '[data-bs-toggle="collapse"]'),
        De = {parent: null, toggle: !0}, ze = {parent: "(null|element)", toggle: "boolean"};

    class Xe extends t {
        constructor(e, t) {
            super(e, t), this._isTransitioning = !1, this._triggerArray = [];
            let s = d.find(Oe);
            for (let i of s) {
                let e = d.getSelectorFromElement(i), t = d.find(e).filter(e => e === this._element);
                null !== e && t.length && this._triggerArray.push(i)
            }
            this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle()
        }

        static get Default() {
            return De
        }

        static get DefaultType() {
            return ze
        }

        static get NAME() {
            return "collapse"
        }

        toggle() {
            this._isShown() ? this.hide() : this.show()
        }

        show() {
            if (!this._isTransitioning && !this._isShown()) {
                let t = [];
                if (!((t = this._config.parent ? this._getFirstLevelChildren(".collapse.show, .collapse.collapsing").filter(e => e !== this._element).map(e => Xe.getOrCreateInstance(e, {toggle: !1})) : t).length && t[0]._isTransitioning || p.trigger(this._element, "show.bs.collapse").defaultPrevented)) {
                    for (let e of t) e.hide();
                    let e = this._getDimension();
                    this._element.classList.remove(f), this._element.classList.add(Ie), this._element.style[e] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0;
                    var i = "scroll" + (e[0].toUpperCase() + e.slice(1));
                    this._queueCallback(() => {
                        this._isTransitioning = !1, this._element.classList.remove(Ie), this._element.classList.add(f, Me), this._element.style[e] = "", p.trigger(this._element, "shown.bs.collapse")
                    }, this._element, !0), this._element.style[e] = this._element[i] + "px"
                }
            }
        }

        hide() {
            if (!this._isTransitioning && this._isShown() && !p.trigger(this._element, "hide.bs.collapse").defaultPrevented) {
                let e = this._getDimension();
                this._element.style[e] = this._element.getBoundingClientRect()[e] + "px", W(this._element), this._element.classList.add(Ie), this._element.classList.remove(f, Me);
                for (let e of this._triggerArray) {
                    var t = d.getElementFromSelector(e);
                    t && !this._isShown(t) && this._addAriaAndCollapsedClass([e], !1)
                }
                this._isTransitioning = !0, this._element.style[e] = "", this._queueCallback(() => {
                    this._isTransitioning = !1, this._element.classList.remove(Ie), this._element.classList.add(f), p.trigger(this._element, "hidden.bs.collapse")
                }, this._element, !0)
            }
        }

        _isShown(e = this._element) {
            return e.classList.contains(Me)
        }

        _configAfterMerge(e) {
            return e.toggle = Boolean(e.toggle), e.parent = a(e.parent), e
        }

        _getDimension() {
            return this._element.classList.contains("collapse-horizontal") ? "width" : "height"
        }

        _initializeChildren() {
            if (this._config.parent) {
                let e = this._getFirstLevelChildren(Oe);
                for (var t of e) {
                    let e = d.getElementFromSelector(t);
                    e && this._addAriaAndCollapsedClass([t], this._isShown(e))
                }
            }
        }

        _getFirstLevelChildren(e) {
            let t = d.find(":scope .collapse .collapse", this._config.parent);
            return d.find(e, this._config.parent).filter(e => !t.includes(e))
        }

        _addAriaAndCollapsedClass(e, t) {
            if (e.length) for (var i of e) i.classList.toggle("collapsed", !t), i.setAttribute("aria-expanded", t)
        }

        static jQueryInterface(t) {
            let i = {};
            return "string" == typeof t && /show|hide/.test(t) && (i.toggle = !1), this.each(function () {
                var e = Xe.getOrCreateInstance(this, i);
                if ("string" == typeof t) {
                    if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
                    e[t]()
                }
            })
        }
    }

    p.on(document, "click.bs.collapse.data-api", Oe, function (e) {
        ("A" === e.target.tagName || e.delegateTarget && "A" === e.delegateTarget.tagName) && e.preventDefault();
        for (let e of d.getMultipleElementsFromSelector(this)) Xe.getOrCreateInstance(e, {toggle: !1}).toggle()
    }), e(Xe);
    var T = "top", E = "bottom", P = "right", _ = "left", Ne = "auto", M = [T, E, P, _], I = "start", v = "end",
        Fe = "clippingParents", He = "viewport", Re = "popper", Ye = "reference", We = M.reduce(function (e, t) {
            return e.concat([t + "-" + I, t + "-" + v])
        }, []), Be = [].concat(M, [Ne]).reduce(function (e, t) {
            return e.concat([t, t + "-" + I, t + "-" + v])
        }, []), je = "beforeRead", Ge = "afterRead", Ve = "beforeMain", qe = "afterMain", Ue = "beforeWrite",
        Ze = "afterWrite", $e = [je, "read", Ge, Ve, "main", qe, Ue, "write", Ze];

    function x(e) {
        return e ? (e.nodeName || "").toLowerCase() : null
    }

    function y(e) {
        var t;
        return null == e ? window : "[object Window]" !== e.toString() ? (t = e.ownerDocument) && t.defaultView || window : e
    }

    function m(e) {
        return e instanceof y(e).Element || e instanceof Element
    }

    function b(e) {
        return e instanceof y(e).HTMLElement || e instanceof HTMLElement
    }

    function Qe(e) {
        return "undefined" != typeof ShadowRoot && (e instanceof y(e).ShadowRoot || e instanceof ShadowRoot)
    }

    var Ke = {
        name: "applyStyles", enabled: !0, phase: "write", fn: function (e) {
            var a = e.state;
            Object.keys(a.elements).forEach(function (e) {
                var t = a.styles[e] || {}, i = a.attributes[e] || {}, s = a.elements[e];
                b(s) && x(s) && (Object.assign(s.style, t), Object.keys(i).forEach(function (e) {
                    var t = i[e];
                    !1 === t ? s.removeAttribute(e) : s.setAttribute(e, !0 === t ? "" : t)
                }))
            })
        }, effect: function (e) {
            var s = e.state, a = {
                popper: {position: s.options.strategy, left: "0", top: "0", margin: "0"},
                arrow: {position: "absolute"},
                reference: {}
            };
            return Object.assign(s.elements.popper.style, a.popper), s.styles = a, s.elements.arrow && Object.assign(s.elements.arrow.style, a.arrow), function () {
                Object.keys(s.elements).forEach(function (e) {
                    var t = s.elements[e], i = s.attributes[e] || {},
                        e = Object.keys((s.styles.hasOwnProperty(e) ? s.styles : a)[e]).reduce(function (e, t) {
                            return e[t] = "", e
                        }, {});
                    b(t) && x(t) && (Object.assign(t.style, e), Object.keys(i).forEach(function (e) {
                        t.removeAttribute(e)
                    }))
                })
            }
        }, requires: ["computeStyles"]
    };

    function O(e) {
        return e.split("-")[0]
    }

    var L = Math.max, Je = Math.min, et = Math.round;

    function tt() {
        var e = navigator.userAgentData;
        return null != e && e.brands && Array.isArray(e.brands) ? e.brands.map(function (e) {
            return e.brand + "/" + e.version
        }).join(" ") : navigator.userAgent
    }

    function it() {
        return !/^((?!chrome|android).)*safari/i.test(tt())
    }

    function st(e, t, i) {
        void 0 === t && (t = !1), void 0 === i && (i = !1);
        var s = e.getBoundingClientRect(), a = 1, n = 1,
            t = (t && b(e) && (a = 0 < e.offsetWidth && et(s.width) / e.offsetWidth || 1, n = 0 < e.offsetHeight && et(s.height) / e.offsetHeight || 1), (m(e) ? y(e) : window).visualViewport),
            e = !it() && i, i = (s.left + (e && t ? t.offsetLeft : 0)) / a,
            e = (s.top + (e && t ? t.offsetTop : 0)) / n, t = s.width / a, a = s.height / n;
        return {width: t, height: a, top: e, right: i + t, bottom: e + a, left: i, x: i, y: e}
    }

    function at(e) {
        var t = st(e), i = e.offsetWidth, s = e.offsetHeight;
        return Math.abs(t.width - i) <= 1 && (i = t.width), Math.abs(t.height - s) <= 1 && (s = t.height), {
            x: e.offsetLeft,
            y: e.offsetTop,
            width: i,
            height: s
        }
    }

    function nt(e, t) {
        var i = t.getRootNode && t.getRootNode();
        if (e.contains(t)) return !0;
        if (i && Qe(i)) {
            var s = t;
            do {
                if (s && e.isSameNode(s)) return !0
            } while (s = s.parentNode || s.host)
        }
        return !1
    }

    function w(e) {
        return y(e).getComputedStyle(e)
    }

    function k(e) {
        return ((m(e) ? e.ownerDocument : e.document) || window.document).documentElement
    }

    function rt(e) {
        return "html" === x(e) ? e : e.assignedSlot || e.parentNode || (Qe(e) ? e.host : null) || k(e)
    }

    function ot(e) {
        return b(e) && "fixed" !== w(e).position ? e.offsetParent : null
    }

    function lt(e) {
        for (var t, i = y(e), s = ot(e); s && (t = s, 0 <= ["table", "td", "th"].indexOf(x(t))) && "static" === w(s).position;) s = ot(s);
        return (!s || "html" !== x(s) && ("body" !== x(s) || "static" !== w(s).position)) && (s || (e => {
            var t = /firefox/i.test(tt());
            if (!/Trident/i.test(tt()) || !b(e) || "fixed" !== w(e).position) {
                var i = rt(e);
                for (Qe(i) && (i = i.host); b(i) && ["html", "body"].indexOf(x(i)) < 0;) {
                    var s = w(i);
                    if ("none" !== s.transform || "none" !== s.perspective || "paint" === s.contain || -1 !== ["transform", "perspective"].indexOf(s.willChange) || t && "filter" === s.willChange || t && s.filter && "none" !== s.filter) return i;
                    i = i.parentNode
                }
            }
            return null
        })(e)) || i
    }

    function ct(e) {
        return 0 <= ["top", "bottom"].indexOf(e) ? "x" : "y"
    }

    function ht(e, t, i) {
        return L(e, Je(t, i))
    }

    function dt(e) {
        return Object.assign({}, {top: 0, right: 0, bottom: 0, left: 0}, e)
    }

    function ut(i, e) {
        return e.reduce(function (e, t) {
            return e[t] = i, e
        }, {})
    }

    var gt = {
        name: "arrow", enabled: !0, phase: "main", fn: function (e) {
            var t, i, s, a, n = e.state, r = e.name, e = e.options, o = n.elements.arrow,
                l = n.modifiersData.popperOffsets, c = O(n.placement), h = ct(c),
                c = 0 <= [_, P].indexOf(c) ? "height" : "width";
            o && l && (e = dt("number" != typeof (e = "function" == typeof (e = e.padding) ? e(Object.assign({}, n.rects, {placement: n.placement})) : e) ? e : ut(e, M)), t = at(o), a = "y" === h ? T : _, s = "y" === h ? E : P, i = n.rects.reference[c] + n.rects.reference[h] - l[h] - n.rects.popper[c], l = l[h] - n.rects.reference[h], o = (o = lt(o)) ? "y" === h ? o.clientHeight || 0 : o.clientWidth || 0 : 0, a = e[a], e = o - t[c] - e[s], a = ht(a, s = o / 2 - t[c] / 2 + (i / 2 - l / 2), e), n.modifiersData[r] = ((o = {})[h] = a, o.centerOffset = a - s, o))
        }, effect: function (e) {
            var t = e.state, e = e.options.element, e = void 0 === e ? "[data-popper-arrow]" : e;
            null != e && ("string" != typeof e || (e = t.elements.popper.querySelector(e))) && nt(t.elements.popper, e) && (t.elements.arrow = e)
        }, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"]
    };

    function pt(e) {
        return e.split("-")[1]
    }

    var ft = {top: "auto", right: "auto", bottom: "auto", left: "auto"};

    function xt(e) {
        var t = e.popper, i = e.popperRect, s = e.placement, a = e.variation, n = e.offsets, r = e.position,
            o = e.gpuAcceleration, l = e.adaptive, c = e.roundOffsets, e = e.isFixed, h = n.x, h = void 0 === h ? 0 : h,
            d = n.y, d = void 0 === d ? 0 : d, u = "function" == typeof c ? c({x: h, y: d}) : {x: h, y: d}, h = u.x,
            d = u.y, u = n.hasOwnProperty("x"), n = n.hasOwnProperty("y"), g = _, p = T, f = window;
        l && (m = "clientHeight", x = "clientWidth", (b = lt(t)) === y(t) && "static" !== w(b = k(t)).position && "absolute" === r && (m = "scrollHeight", x = "scrollWidth"), s !== T && (s !== _ && s !== P || a !== v) || (p = E, d = (d - ((e && b === f && f.visualViewport ? f.visualViewport.height : b[m]) - i.height)) * (o ? 1 : -1)), s !== _ && (s !== T && s !== E || a !== v) || (g = P, h = (h - ((e && b === f && f.visualViewport ? f.visualViewport.width : b[x]) - i.width)) * (o ? 1 : -1)));
        var x, m = Object.assign({position: r}, l && ft),
            b = !0 === c ? (s = {x: h, y: d}, a = y(t), e = s.y, a = a.devicePixelRatio || 1, {
                x: et(s.x * a) / a || 0,
                y: et(e * a) / a || 0
            }) : {x: h, y: d};
        return h = b.x, d = b.y, o ? Object.assign({}, m, ((x = {})[p] = n ? "0" : "", x[g] = u ? "0" : "", x.transform = (f.devicePixelRatio || 1) <= 1 ? "translate(" + h + "px, " + d + "px)" : "translate3d(" + h + "px, " + d + "px, 0)", x)) : Object.assign({}, m, ((i = {})[p] = n ? d + "px" : "", i[g] = u ? h + "px" : "", i.transform = "", i))
    }

    var mt = {
        name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: function (e) {
            var t = e.state, e = e.options, i = e.gpuAcceleration, i = void 0 === i || i, s = e.adaptive,
                s = void 0 === s || s, e = e.roundOffsets, e = void 0 === e || e, i = {
                    placement: O(t.placement),
                    variation: pt(t.placement),
                    popper: t.elements.popper,
                    popperRect: t.rects.popper,
                    gpuAcceleration: i,
                    isFixed: "fixed" === t.options.strategy
                };
            null != t.modifiersData.popperOffsets && (t.styles.popper = Object.assign({}, t.styles.popper, xt(Object.assign({}, i, {
                offsets: t.modifiersData.popperOffsets,
                position: t.options.strategy,
                adaptive: s,
                roundOffsets: e
            })))), null != t.modifiersData.arrow && (t.styles.arrow = Object.assign({}, t.styles.arrow, xt(Object.assign({}, i, {
                offsets: t.modifiersData.arrow,
                position: "absolute",
                adaptive: !1,
                roundOffsets: e
            })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {"data-popper-placement": t.placement})
        }, data: {}
    }, bt = {passive: !0}, vt = {
        name: "eventListeners", enabled: !0, phase: "write", fn: function () {
        }, effect: function (e) {
            var t = e.state, i = e.instance, e = e.options, s = e.scroll, a = void 0 === s || s, s = e.resize,
                n = void 0 === s || s, r = y(t.elements.popper),
                o = [].concat(t.scrollParents.reference, t.scrollParents.popper);
            return a && o.forEach(function (e) {
                e.addEventListener("scroll", i.update, bt)
            }), n && r.addEventListener("resize", i.update, bt), function () {
                a && o.forEach(function (e) {
                    e.removeEventListener("scroll", i.update, bt)
                }), n && r.removeEventListener("resize", i.update, bt)
            }
        }, data: {}
    }, yt = {left: "right", right: "left", bottom: "top", top: "bottom"};

    function wt(e) {
        return e.replace(/left|right|bottom|top/g, function (e) {
            return yt[e]
        })
    }

    var kt = {start: "end", end: "start"};

    function At(e) {
        return e.replace(/start|end/g, function (e) {
            return kt[e]
        })
    }

    function Ct(e) {
        e = y(e);
        return {scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset}
    }

    function St(e) {
        return st(k(e)).left + Ct(e).scrollLeft
    }

    function Lt(e) {
        var e = w(e), t = e.overflow;
        return /auto|scroll|overlay|hidden/.test(t + e.overflowY + e.overflowX)
    }

    function Tt(e, t) {
        void 0 === t && (t = []);
        var i = function e(t) {
                return 0 <= ["html", "body", "#document"].indexOf(x(t)) ? t.ownerDocument.body : b(t) && Lt(t) ? t : e(rt(t))
            }(e), e = i === (null == (e = e.ownerDocument) ? void 0 : e.body), s = y(i),
            s = e ? [s].concat(s.visualViewport || [], Lt(i) ? i : []) : i, i = t.concat(s);
        return e ? i : i.concat(Tt(rt(s)))
    }

    function Et(e) {
        return Object.assign({}, e, {left: e.x, top: e.y, right: e.x + e.width, bottom: e.y + e.height})
    }

    function Pt(e, t, i) {
        return t === He ? Et((a = i, r = y(s = e), o = k(s), r = r.visualViewport, l = o.clientWidth, o = o.clientHeight, h = c = 0, r && (l = r.width, o = r.height, (n = it()) || !n && "fixed" === a) && (c = r.offsetLeft, h = r.offsetTop), {
            width: l,
            height: o,
            x: c + St(s),
            y: h
        })) : m(t) ? ((a = st(n = t, !1, "fixed" === i)).top = a.top + n.clientTop, a.left = a.left + n.clientLeft, a.bottom = a.top + n.clientHeight, a.right = a.left + n.clientWidth, a.width = n.clientWidth, a.height = n.clientHeight, a.x = a.left, a.y = a.top, a) : Et((r = k(e), l = k(r), o = Ct(r), c = null == (c = r.ownerDocument) ? void 0 : c.body, s = L(l.scrollWidth, l.clientWidth, c ? c.scrollWidth : 0, c ? c.clientWidth : 0), h = L(l.scrollHeight, l.clientHeight, c ? c.scrollHeight : 0, c ? c.clientHeight : 0), r = -o.scrollLeft + St(r), o = -o.scrollTop, "rtl" === w(c || l).direction && (r += L(l.clientWidth, c ? c.clientWidth : 0) - s), {
            width: s,
            height: h,
            x: r,
            y: o
        }));
        var s, a, n, r, o, l, c, h
    }

    function _t(e) {
        var t, i = e.reference, s = e.element, e = e.placement, a = e ? O(e) : null, e = e ? pt(e) : null,
            n = i.x + i.width / 2 - s.width / 2, r = i.y + i.height / 2 - s.height / 2;
        switch (a) {
            case T:
                t = {x: n, y: i.y - s.height};
                break;
            case E:
                t = {x: n, y: i.y + i.height};
                break;
            case P:
                t = {x: i.x + i.width, y: r};
                break;
            case _:
                t = {x: i.x - s.width, y: r};
                break;
            default:
                t = {x: i.x, y: i.y}
        }
        var o = a ? ct(a) : null;
        if (null != o) {
            var l = "y" === o ? "height" : "width";
            switch (e) {
                case I:
                    t[o] = t[o] - (i[l] / 2 - s[l] / 2);
                    break;
                case v:
                    t[o] = t[o] + (i[l] / 2 - s[l] / 2)
            }
        }
        return t
    }

    function Mt(e, t) {
        var i, s, a, n, r, o, t = t = void 0 === t ? {} : t, l = t.placement, l = void 0 === l ? e.placement : l,
            c = t.strategy, c = void 0 === c ? e.strategy : c, h = t.boundary, h = void 0 === h ? Fe : h,
            d = t.rootBoundary, d = void 0 === d ? He : d, u = t.elementContext, u = void 0 === u ? Re : u,
            g = t.altBoundary, g = void 0 !== g && g, t = t.padding, t = void 0 === t ? 0 : t,
            t = dt("number" != typeof t ? t : ut(t, M)), p = e.rects.popper, g = e.elements[g ? u === Re ? Ye : Re : u],
            c = (i = m(g) ? g : g.contextElement || k(e.elements.popper), g = d, s = c, n = "clippingParents" === (d = h) ? (r = Tt(rt(n = i)), m(a = 0 <= ["absolute", "fixed"].indexOf(w(n).position) && b(n) ? lt(n) : n) ? r.filter(function (e) {
                return m(e) && nt(e, a) && "body" !== x(e)
            }) : []) : [].concat(d), r = [].concat(n, [g]), d = r[0], (g = r.reduce(function (e, t) {
                t = Pt(i, t, s);
                return e.top = L(t.top, e.top), e.right = Je(t.right, e.right), e.bottom = Je(t.bottom, e.bottom), e.left = L(t.left, e.left), e
            }, Pt(i, d, s))).width = g.right - g.left, g.height = g.bottom - g.top, g.x = g.left, g.y = g.top, g),
            h = st(e.elements.reference), d = _t({reference: h, element: p, strategy: "absolute", placement: l}),
            g = Et(Object.assign({}, p, d)), p = u === Re ? g : h, f = {
                top: c.top - p.top + t.top,
                bottom: p.bottom - c.bottom + t.bottom,
                left: c.left - p.left + t.left,
                right: p.right - c.right + t.right
            }, d = e.modifiersData.offset;
        return u === Re && d && (o = d[l], Object.keys(f).forEach(function (e) {
            var t = 0 <= [P, E].indexOf(e) ? 1 : -1, i = 0 <= [T, E].indexOf(e) ? "y" : "x";
            f[e] += o[i] * t
        })), f
    }

    var It = {
        name: "flip", enabled: !0, phase: "main", fn: function (e) {
            var d = e.state, t = e.options, e = e.name;
            if (!d.modifiersData[e]._skip) {
                for (var i = t.mainAxis, s = void 0 === i || i, i = t.altAxis, a = void 0 === i || i, i = t.fallbackPlacements, u = t.padding, g = t.boundary, p = t.rootBoundary, n = t.altBoundary, r = t.flipVariations, f = void 0 === r || r, x = t.allowedAutoPlacements, r = d.options.placement, t = O(r), i = i || (t !== r && f ? O(i = r) === Ne ? [] : (t = wt(i), [At(i), t, At(t)]) : [wt(r)]), o = [r].concat(i).reduce(function (e, t) {
                    return e.concat(O(t) === Ne ? (i = d, s = (e = e = void 0 === (e = {
                        placement: t,
                        boundary: g,
                        rootBoundary: p,
                        padding: u,
                        flipVariations: f,
                        allowedAutoPlacements: x
                    }) ? {} : e).placement, a = e.boundary, n = e.rootBoundary, r = e.padding, o = e.flipVariations, l = void 0 === (e = e.allowedAutoPlacements) ? Be : e, c = pt(s), e = c ? o ? We : We.filter(function (e) {
                        return pt(e) === c
                    }) : M, h = (s = 0 === (s = e.filter(function (e) {
                        return 0 <= l.indexOf(e)
                    })).length ? e : s).reduce(function (e, t) {
                        return e[t] = Mt(i, {placement: t, boundary: a, rootBoundary: n, padding: r})[O(t)], e
                    }, {}), Object.keys(h).sort(function (e, t) {
                        return h[e] - h[t]
                    })) : t);
                    var i, s, a, n, r, o, l, c, h
                }, []), l = d.rects.reference, c = d.rects.popper, h = new Map, m = !0, b = o[0], v = 0; v < o.length; v++) {
                    var y = o[v], w = O(y), k = pt(y) === I, A = 0 <= [T, E].indexOf(w), C = A ? "width" : "height",
                        S = Mt(d, {placement: y, boundary: g, rootBoundary: p, altBoundary: n, padding: u}),
                        A = A ? k ? P : _ : k ? E : T, k = (l[C] > c[C] && (A = wt(A)), wt(A)), C = [];
                    if (s && C.push(S[w] <= 0), a && C.push(S[A] <= 0, S[k] <= 0), C.every(function (e) {
                        return e
                    })) {
                        b = y, m = !1;
                        break
                    }
                    h.set(y, C)
                }
                if (m) for (var L = f ? 3 : 1; 0 < L && "break" !== (t => {
                    var e = o.find(function (e) {
                        e = h.get(e);
                        if (e) return e.slice(0, t).every(function (e) {
                            return e
                        })
                    });
                    if (e) return b = e, "break"
                })(L); L--) ;
                d.placement !== b && (d.modifiersData[e]._skip = !0, d.placement = b, d.reset = !0)
            }
        }, requiresIfExists: ["offset"], data: {_skip: !1}
    };

    function Ot(e, t, i) {
        return {
            top: e.top - t.height - (i = void 0 === i ? {x: 0, y: 0} : i).y,
            right: e.right - t.width + i.x,
            bottom: e.bottom - t.height + i.y,
            left: e.left - t.width - i.x
        }
    }

    function Dt(t) {
        return [T, P, E, _].some(function (e) {
            return 0 <= t[e]
        })
    }

    var zt = {
        name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: function (e) {
            var t = e.state, e = e.name, i = t.rects.reference, s = t.rects.popper, a = t.modifiersData.preventOverflow,
                n = Mt(t, {elementContext: "reference"}), r = Mt(t, {altBoundary: !0}), n = Ot(n, i), i = Ot(r, s, a),
                r = Dt(n), s = Dt(i);
            t.modifiersData[e] = {
                referenceClippingOffsets: n,
                popperEscapeOffsets: i,
                isReferenceHidden: r,
                hasPopperEscaped: s
            }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
                "data-popper-reference-hidden": r,
                "data-popper-escaped": s
            })
        }
    }, Xt = {
        name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: function (e) {
            var r = e.state, t = e.name, e = e.options.offset, o = void 0 === e ? [0, 0] : e,
                e = Be.reduce(function (e, t) {
                    return e[t] = (t = t, i = r.rects, s = o, a = O(t), n = 0 <= [_, T].indexOf(a) ? -1 : 1, i = "function" == typeof s ? s(Object.assign({}, i, {placement: t})) : s, t = i[0] || 0, s = (i[1] || 0) * n, 0 <= [_, P].indexOf(a) ? {
                        x: s,
                        y: t
                    } : {x: t, y: s}), e;
                    var i, s, a, n
                }, {}), i = e[r.placement], s = i.x, i = i.y;
            null != r.modifiersData.popperOffsets && (r.modifiersData.popperOffsets.x += s, r.modifiersData.popperOffsets.y += i), r.modifiersData[t] = e
        }
    }, Nt = {
        name: "popperOffsets", enabled: !0, phase: "read", fn: function (e) {
            var t = e.state;
            t.modifiersData[e.name] = _t({
                reference: t.rects.reference,
                element: t.rects.popper,
                strategy: "absolute",
                placement: t.placement
            })
        }, data: {}
    }, Ft = {
        name: "preventOverflow", enabled: !0, phase: "main", fn: function (e) {
            var t, i, s, a, n, r, o, l, c, h = e.state, d = e.options, e = e.name, u = d.mainAxis,
                u = void 0 === u || u, g = d.altAxis, g = void 0 !== g && g, p = d.tether, p = void 0 === p || p,
                f = d.tetherOffset, f = void 0 === f ? 0 : f, d = Mt(h, {
                    boundary: d.boundary,
                    rootBoundary: d.rootBoundary,
                    padding: d.padding,
                    altBoundary: d.altBoundary
                }), x = O(h.placement), m = pt(h.placement), b = !m, v = ct(x), y = "x" === v ? "y" : "x",
                w = h.modifiersData.popperOffsets, k = h.rects.reference, A = h.rects.popper,
                f = "function" == typeof f ? f(Object.assign({}, h.rects, {placement: h.placement})) : f,
                f = "number" == typeof f ? {mainAxis: f, altAxis: f} : Object.assign({mainAxis: 0, altAxis: 0}, f),
                C = h.modifiersData.offset ? h.modifiersData.offset[h.placement] : null, S = {x: 0, y: 0};
            w && (u && (u = "y" === v ? "height" : "width", r = (o = w[v]) + d[i = "y" === v ? T : _], l = o - d[c = "y" === v ? E : P], t = p ? -A[u] / 2 : 0, a = (m === I ? k : A)[u], m = m === I ? -A[u] : -k[u], n = h.elements.arrow, n = p && n ? at(n) : {
                width: 0,
                height: 0
            }, i = (s = h.modifiersData["arrow#persistent"] ? h.modifiersData["arrow#persistent"].padding : {
                top: 0,
                right: 0,
                bottom: 0,
                left: 0
            })[i], s = s[c], c = ht(0, k[u], n[u]), n = b ? k[u] / 2 - t - c - i - f.mainAxis : a - c - i - f.mainAxis, a = b ? -k[u] / 2 + t + c + s + f.mainAxis : m + c + s + f.mainAxis, b = (i = h.elements.arrow && lt(h.elements.arrow)) ? "y" === v ? i.clientTop || 0 : i.clientLeft || 0 : 0, m = o + a - (t = null != (u = null == C ? void 0 : C[v]) ? u : 0), c = ht(p ? Je(r, o + n - t - b) : r, o, p ? L(l, m) : l), w[v] = c, S[v] = c - o), g && (s = "y" == y ? "height" : "width", a = (i = w[y]) + d["x" === v ? T : _], u = i - d["x" === v ? E : P], n = -1 !== [T, _].indexOf(x), b = null != (t = null == C ? void 0 : C[y]) ? t : 0, r = n ? a : i - k[s] - A[s] - b + f.altAxis, m = n ? i + k[s] + A[s] - b - f.altAxis : u, o = p && n ? (c = ht(r, i, l = m), l < c ? l : c) : ht(p ? r : a, i, p ? m : u), w[y] = o, S[y] = o - i), h.modifiersData[e] = S)
        }, requiresIfExists: ["offset"]
    };

    function Ht(e) {
        var i = new Map, s = new Set, a = [];
        return e.forEach(function (e) {
            i.set(e.name, e)
        }), e.forEach(function (e) {
            s.has(e.name) || function t(e) {
                s.add(e.name), [].concat(e.requires || [], e.requiresIfExists || []).forEach(function (e) {
                    s.has(e) || (e = i.get(e)) && t(e)
                }), a.push(e)
            }(e)
        }), a
    }

    var Rt = {placement: "bottom", modifiers: [], strategy: "absolute"};

    function Yt() {
        for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
        return !t.some(function (e) {
            return !(e && "function" == typeof e.getBoundingClientRect)
        })
    }

    function Wt(e) {
        var e = e = void 0 === e ? {} : e, t = e.defaultModifiers, l = void 0 === t ? [] : t, t = e.defaultOptions,
            c = void 0 === t ? Rt : t;
        return function (s, a, t) {
            void 0 === t && (t = c);
            var i, n, g = {
                placement: "bottom",
                orderedModifiers: [],
                options: Object.assign({}, Rt, c),
                modifiersData: {},
                elements: {reference: s, popper: a},
                attributes: {},
                styles: {}
            }, r = [], p = !1, f = {
                state: g, setOptions: function (e) {
                    e = "function" == typeof e ? e(g.options) : e;
                    o(), g.options = Object.assign({}, c, g.options, e), g.scrollParents = {
                        reference: m(s) ? Tt(s) : s.contextElement ? Tt(s.contextElement) : [],
                        popper: Tt(a)
                    };
                    e = [].concat(l, g.options.modifiers), t = e.reduce(function (e, t) {
                        var i = e[t.name];
                        return e[t.name] = i ? Object.assign({}, i, t, {
                            options: Object.assign({}, i.options, t.options),
                            data: Object.assign({}, i.data, t.data)
                        }) : t, e
                    }, {}), i = Ht(Object.keys(t).map(function (e) {
                        return t[e]
                    }));
                    var t, i, e = $e.reduce(function (e, t) {
                        return e.concat(i.filter(function (e) {
                            return e.phase === t
                        }))
                    }, []);
                    return g.orderedModifiers = e.filter(function (e) {
                        return e.enabled
                    }), g.orderedModifiers.forEach(function (e) {
                        var t = e.name, i = e.options, e = e.effect;
                        "function" == typeof e && (e = e({
                            state: g,
                            name: t,
                            instance: f,
                            options: void 0 === i ? {} : i
                        }), r.push(e || function () {
                        }))
                    }), f.update()
                }, forceUpdate: function () {
                    if (!p) {
                        var e = g.elements, t = e.reference, e = e.popper;
                        if (Yt(t, e)) {
                            g.rects = {
                                reference: (t = t, r = lt(e), void 0 === (o = "fixed" === g.options.strategy) && (o = !1), l = b(r), c = b(r) && (d = (c = r).getBoundingClientRect(), h = et(d.width) / c.offsetWidth || 1, d = et(d.height) / c.offsetHeight || 1, 1 !== h || 1 !== d), h = k(r), d = st(t, c, o), t = {
                                    scrollLeft: 0,
                                    scrollTop: 0
                                }, u = {
                                    x: 0,
                                    y: 0
                                }, !l && o || ("body" === x(r) && !Lt(h) || (t = (l = r) !== y(l) && b(l) ? {
                                    scrollLeft: l.scrollLeft,
                                    scrollTop: l.scrollTop
                                } : Ct(l)), b(r) ? ((u = st(r, !0)).x += r.clientLeft, u.y += r.clientTop) : h && (u.x = St(h))), {
                                    x: d.left + t.scrollLeft - u.x,
                                    y: d.top + t.scrollTop - u.y,
                                    width: d.width,
                                    height: d.height
                                }), popper: at(e)
                            }, g.reset = !1, g.placement = g.options.placement, g.orderedModifiers.forEach(function (e) {
                                return g.modifiersData[e.name] = Object.assign({}, e.data)
                            });
                            for (var i, s, a, n = 0; n < g.orderedModifiers.length; n++) !0 !== g.reset ? (s = (i = g.orderedModifiers[n]).fn, a = i.options, "function" == typeof s && (g = s({
                                state: g,
                                options: void 0 === a ? {} : a,
                                name: i.name,
                                instance: f
                            }) || g)) : (g.reset = !1, n = -1)
                        }
                    }
                    var r, o, l, c, h, d, u
                }, update: (i = function () {
                    return new Promise(function (e) {
                        f.forceUpdate(), e(g)
                    })
                }, function () {
                    return n = n || new Promise(function (e) {
                        Promise.resolve().then(function () {
                            n = void 0, e(i())
                        })
                    })
                }), destroy: function () {
                    o(), p = !0
                }
            };
            return Yt(s, a) && f.setOptions(t).then(function (e) {
                !p && t.onFirstUpdate && t.onFirstUpdate(e)
            }), f;

            function o() {
                r.forEach(function (e) {
                    return e()
                }), r = []
            }
        }
    }

    var Bt = Wt(), jt = Wt({defaultModifiers: [vt, Nt, mt, Ke]}),
        Gt = Wt({defaultModifiers: [vt, Nt, mt, Ke, Xt, It, Ft, gt, zt]});
    let Vt = Object.freeze(Object.defineProperty({
            __proto__: null,
            afterMain: qe,
            afterRead: Ge,
            afterWrite: Ze,
            applyStyles: Ke,
            arrow: gt,
            auto: Ne,
            basePlacements: M,
            beforeMain: Ve,
            beforeRead: je,
            beforeWrite: Ue,
            bottom: E,
            clippingParents: Fe,
            computeStyles: mt,
            createPopper: Gt,
            createPopperBase: Bt,
            createPopperLite: jt,
            detectOverflow: Mt,
            end: v,
            eventListeners: vt,
            flip: It,
            hide: zt,
            left: _,
            main: "main",
            modifierPhases: $e,
            offset: Xt,
            placements: Be,
            popper: Re,
            popperGenerator: Wt,
            popperOffsets: Nt,
            preventOverflow: Ft,
            read: "read",
            reference: Ye,
            right: P,
            start: I,
            top: T,
            variationPlacements: We,
            viewport: He,
            write: "write"
        }, Symbol.toStringTag, {value: "Module"})), qt = "dropdown", Ut = ".bs.dropdown", Zt = ".data-api",
        $t = "ArrowDown", Qt = "click" + Ut + Zt, Kt = "keydown" + Ut + Zt, Jt = "show",
        A = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)', ei = (A, ".dropdown-menu"),
        ti = l() ? "top-end" : "top-start", ii = l() ? "top-start" : "top-end",
        si = l() ? "bottom-end" : "bottom-start", ai = l() ? "bottom-start" : "bottom-end",
        ni = l() ? "left-start" : "right-start", ri = l() ? "right-start" : "left-start", oi = {
            autoClose: !0,
            boundary: "clippingParents",
            display: "dynamic",
            offset: [0, 2],
            popperConfig: null,
            reference: "toggle"
        }, li = {
            autoClose: "(boolean|string)",
            boundary: "(string|element)",
            display: "string",
            offset: "(array|string|function)",
            popperConfig: "(null|object|function)",
            reference: "(string|element|object)"
        };

    class C extends t {
        constructor(e, t) {
            super(e, t), this._popper = null, this._parent = this._element.parentNode, this._menu = d.next(this._element, ei)[0] || d.prev(this._element, ei)[0] || d.findOne(ei, this._parent), this._inNavbar = this._detectNavbar()
        }

        static get Default() {
            return oi
        }

        static get DefaultType() {
            return li
        }

        static get NAME() {
            return qt
        }

        toggle() {
            return this._isShown() ? this.hide() : this.show()
        }

        show() {
            if (!o(this._element) && !this._isShown()) {
                let e = {relatedTarget: this._element};
                if (!p.trigger(this._element, "show.bs.dropdown", e).defaultPrevented) {
                    if (this._createPopper(), "ontouchstart" in document.documentElement && !this._parent.closest(".navbar-nav")) for (let e of [].concat(...document.body.children)) p.on(e, "mouseover", Y);
                    this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.add(Jt), this._element.classList.add(Jt), p.trigger(this._element, "shown.bs.dropdown", e)
                }
            }
        }

        hide() {
            var e;
            !o(this._element) && this._isShown() && (e = {relatedTarget: this._element}, this._completeHide(e))
        }

        dispose() {
            this._popper && this._popper.destroy(), super.dispose()
        }

        update() {
            this._inNavbar = this._detectNavbar(), this._popper && this._popper.update()
        }

        _completeHide(e) {
            if (!p.trigger(this._element, "hide.bs.dropdown", e).defaultPrevented) {
                if ("ontouchstart" in document.documentElement) for (let e of [].concat(...document.body.children)) p.off(e, "mouseover", Y);
                this._popper && this._popper.destroy(), this._menu.classList.remove(Jt), this._element.classList.remove(Jt), this._element.setAttribute("aria-expanded", "false"), h.removeDataAttribute(this._menu, "popper"), p.trigger(this._element, "hidden.bs.dropdown", e)
            }
        }

        _getConfig(e) {
            if ("object" != typeof (e = super._getConfig(e)).reference || r(e.reference) || "function" == typeof e.reference.getBoundingClientRect) return e;
            throw new TypeError(qt.toUpperCase() + ': Option "reference" provided type "object" without a required "getBoundingClientRect" method.')
        }

        _createPopper() {
            if (void 0 === Vt) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
            let e = this._element;
            "parent" === this._config.reference ? e = this._parent : r(this._config.reference) ? e = a(this._config.reference) : "object" == typeof this._config.reference && (e = this._config.reference);
            var t = this._getPopperConfig();
            this._popper = Gt(e, this._menu, t)
        }

        _isShown() {
            return this._menu.classList.contains(Jt)
        }

        _getPlacement() {
            var e, t = this._parent;
            return t.classList.contains("dropend") ? ni : t.classList.contains("dropstart") ? ri : t.classList.contains("dropup-center") ? "top" : t.classList.contains("dropdown-center") ? "bottom" : (e = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim(), t.classList.contains("dropup") ? e ? ii : ti : e ? ai : si)
        }

        _detectNavbar() {
            return null !== this._element.closest(".navbar")
        }

        _getOffset() {
            let t = this._config.offset;
            return "string" == typeof t ? t.split(",").map(e => Number.parseInt(e, 10)) : "function" == typeof t ? e => t(e, this._element) : t
        }

        _getPopperConfig() {
            var e = {
                placement: this._getPlacement(),
                modifiers: [{name: "preventOverflow", options: {boundary: this._config.boundary}}, {
                    name: "offset",
                    options: {offset: this._getOffset()}
                }]
            };
            return !this._inNavbar && "static" !== this._config.display || (h.setDataAttribute(this._menu, "popper", "static"), e.modifiers = [{
                name: "applyStyles",
                enabled: !1
            }]), {...e, ...c(this._config.popperConfig, [e])}
        }

        _selectMenuItem({key: e, target: t}) {
            var i = d.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", this._menu).filter(e => n(e));
            i.length && V(i, t, e === $t, !i.includes(t)).focus()
        }

        static jQueryInterface(t) {
            return this.each(function () {
                var e = C.getOrCreateInstance(this, t);
                if ("string" == typeof t) {
                    if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
                    e[t]()
                }
            })
        }

        static clearMenus(t) {
            if (2 !== t.button && ("keyup" !== t.type || "Tab" === t.key)) {
                let e = d.find('[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled).show');
                for (var i of e) {
                    let e = C.getInstance(i);
                    var s;
                    e && !1 !== e._config.autoClose && (s = (i = t.composedPath()).includes(e._menu), i.includes(e._element) || "inside" === e._config.autoClose && !s || "outside" === e._config.autoClose && s || e._menu.contains(t.target) && ("keyup" === t.type && "Tab" === t.key || /input|select|option|textarea|form/i.test(t.target.tagName)) || (i = {relatedTarget: e._element}, "click" === t.type && (i.clickEvent = t), e._completeHide(i)))
                }
            }
        }

        static dataApiKeydownHandler(e) {
            var t = /input|textarea/i.test(e.target.tagName), i = "Escape" === e.key,
                s = ["ArrowUp", $t].includes(e.key);
            !s && !i || t && !i || (e.preventDefault(), t = this.matches(A) ? this : d.prev(this, A)[0] || d.next(this, A)[0] || d.findOne(A, e.delegateTarget.parentNode), i = C.getOrCreateInstance(t), s ? (e.stopPropagation(), i.show(), i._selectMenuItem(e)) : i._isShown() && (e.stopPropagation(), i.hide(), t.focus()))
        }
    }

    p.on(document, Kt, A, C.dataApiKeydownHandler), p.on(document, Kt, ei, C.dataApiKeydownHandler), p.on(document, Qt, C.clearMenus), p.on(document, "keyup.bs.dropdown.data-api", C.clearMenus), p.on(document, Qt, A, function (e) {
        e.preventDefault(), C.getOrCreateInstance(this).toggle()
    }), e(C);
    let ci = "backdrop", hi = "mousedown.bs." + ci,
        di = {className: "modal-backdrop", clickCallback: null, isAnimated: !1, isVisible: !0, rootElement: "body"},
        ui = {
            className: "string",
            clickCallback: "(function|null)",
            isAnimated: "boolean",
            isVisible: "boolean",
            rootElement: "(element|string)"
        };

    class gi extends he {
        constructor(e) {
            super(), this._config = this._getConfig(e), this._isAppended = !1, this._element = null
        }

        static get Default() {
            return di
        }

        static get DefaultType() {
            return ui
        }

        static get NAME() {
            return ci
        }

        show(e) {
            var t;
            this._config.isVisible ? (this._append(), t = this._getElement(), this._config.isAnimated && W(t), t.classList.add("show"), this._emulateAnimation(() => {
                c(e)
            })) : c(e)
        }

        hide(e) {
            this._config.isVisible ? (this._getElement().classList.remove("show"), this._emulateAnimation(() => {
                this.dispose(), c(e)
            })) : c(e)
        }

        dispose() {
            this._isAppended && (p.off(this._element, hi), this._element.remove(), this._isAppended = !1)
        }

        _getElement() {
            var e;
            return this._element || ((e = document.createElement("div")).className = this._config.className, this._config.isAnimated && e.classList.add("fade"), this._element = e), this._element
        }

        _configAfterMerge(e) {
            return e.rootElement = a(e.rootElement), e
        }

        _append() {
            var e;
            this._isAppended || (e = this._getElement(), this._config.rootElement.append(e), p.on(e, hi, () => {
                c(this._config.clickCallback)
            }), this._isAppended = !0)
        }

        _emulateAnimation(e) {
            G(e, this._getElement(), this._config.isAnimated)
        }
    }

    let pi = ".bs.focustrap", fi = (pi, pi, "backward"), xi = {autofocus: !0, trapElement: null},
        mi = {autofocus: "boolean", trapElement: "element"};

    class bi extends he {
        constructor(e) {
            super(), this._config = this._getConfig(e), this._isActive = !1, this._lastTabNavDirection = null
        }

        static get Default() {
            return xi
        }

        static get DefaultType() {
            return mi
        }

        static get NAME() {
            return "focustrap"
        }

        activate() {
            this._isActive || (this._config.autofocus && this._config.trapElement.focus(), p.off(document, pi), p.on(document, "focusin.bs.focustrap", e => this._handleFocusin(e)), p.on(document, "keydown.tab.bs.focustrap", e => this._handleKeydown(e)), this._isActive = !0)
        }

        deactivate() {
            this._isActive && (this._isActive = !1, p.off(document, pi))
        }

        _handleFocusin(e) {
            var t = this._config.trapElement;
            e.target === document || e.target === t || t.contains(e.target) || (0 === (e = d.focusableChildren(t)).length ? t : this._lastTabNavDirection === fi ? e[e.length - 1] : e[0]).focus()
        }

        _handleKeydown(e) {
            "Tab" === e.key && (this._lastTabNavDirection = e.shiftKey ? fi : "forward")
        }
    }

    let vi = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", yi = ".sticky-top", wi = "padding-right",
        ki = "margin-right";

    class Ai {
        constructor() {
            this._element = document.body
        }

        getWidth() {
            var e = document.documentElement.clientWidth;
            return Math.abs(window.innerWidth - e)
        }

        hide() {
            let t = this.getWidth();
            this._disableOverFlow(), this._setElementAttributes(this._element, wi, e => e + t), this._setElementAttributes(vi, wi, e => e + t), this._setElementAttributes(yi, ki, e => e - t)
        }

        reset() {
            this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, wi), this._resetElementAttributes(vi, wi), this._resetElementAttributes(yi, ki)
        }

        isOverflowing() {
            return 0 < this.getWidth()
        }

        _disableOverFlow() {
            this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden"
        }

        _setElementAttributes(e, i, s) {
            let a = this.getWidth();
            this._applyManipulationCallback(e, e => {
                var t;
                e !== this._element && window.innerWidth > e.clientWidth + a || (this._saveInitialAttribute(e, i), t = window.getComputedStyle(e).getPropertyValue(i), e.style.setProperty(i, s(Number.parseFloat(t)) + "px"))
            })
        }

        _saveInitialAttribute(e, t) {
            var i = e.style.getPropertyValue(t);
            i && h.setDataAttribute(e, t, i)
        }

        _resetElementAttributes(e, i) {
            this._applyManipulationCallback(e, e => {
                var t = h.getDataAttribute(e, i);
                null !== t ? (h.removeDataAttribute(e, i), e.style.setProperty(i, t)) : e.style.removeProperty(i)
            })
        }

        _applyManipulationCallback(e, t) {
            if (r(e)) t(e); else for (var i of d.find(e, this._element)) t(i)
        }
    }

    let S = ".bs.modal", Ci = (S, S, "hidden" + S), Si = "show" + S, Li = (S, S, S, S, S, S, "modal-open"),
        Ti = "modal-static", Ei = {backdrop: !0, focus: !0, keyboard: !0},
        Pi = {backdrop: "(boolean|string)", focus: "boolean", keyboard: "boolean"};

    class _i extends t {
        constructor(e, t) {
            super(e, t), this._dialog = d.findOne(".modal-dialog", this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._isTransitioning = !1, this._scrollBar = new Ai, this._addEventListeners()
        }

        static get Default() {
            return Ei
        }

        static get DefaultType() {
            return Pi
        }

        static get NAME() {
            return "modal"
        }

        toggle(e) {
            return this._isShown ? this.hide() : this.show(e)
        }

        show(e) {
            this._isShown || this._isTransitioning || p.trigger(this._element, Si, {relatedTarget: e}).defaultPrevented || (this._isShown = !0, this._isTransitioning = !0, this._scrollBar.hide(), document.body.classList.add(Li), this._adjustDialog(), this._backdrop.show(() => this._showElement(e)))
        }

        hide() {
            !this._isShown || this._isTransitioning || p.trigger(this._element, "hide.bs.modal").defaultPrevented || (this._isShown = !1, this._isTransitioning = !0, this._focustrap.deactivate(), this._element.classList.remove("show"), this._queueCallback(() => this._hideModal(), this._element, this._isAnimated()))
        }

        dispose() {
            p.off(window, S), p.off(this._dialog, S), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose()
        }

        handleUpdate() {
            this._adjustDialog()
        }

        _initializeBackDrop() {
            return new gi({isVisible: Boolean(this._config.backdrop), isAnimated: this._isAnimated()})
        }

        _initializeFocusTrap() {
            return new bi({trapElement: this._element})
        }

        _showElement(e) {
            document.body.contains(this._element) || document.body.append(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0;
            var t = d.findOne(".modal-body", this._dialog);
            t && (t.scrollTop = 0), W(this._element), this._element.classList.add("show"), this._queueCallback(() => {
                this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, p.trigger(this._element, "shown.bs.modal", {relatedTarget: e})
            }, this._dialog, this._isAnimated())
        }

        _addEventListeners() {
            p.on(this._element, "keydown.dismiss.bs.modal", e => {
                "Escape" === e.key && (this._config.keyboard ? this.hide() : this._triggerBackdropTransition())
            }), p.on(window, "resize.bs.modal", () => {
                this._isShown && !this._isTransitioning && this._adjustDialog()
            }), p.on(this._element, "mousedown.dismiss.bs.modal", t => {
                p.one(this._element, "click.dismiss.bs.modal", e => {
                    this._element === t.target && this._element === e.target && ("static" !== this._config.backdrop ? this._config.backdrop && this.hide() : this._triggerBackdropTransition())
                })
            })
        }

        _hideModal() {
            this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop.hide(() => {
                document.body.classList.remove(Li), this._resetAdjustments(), this._scrollBar.reset(), p.trigger(this._element, Ci)
            })
        }

        _isAnimated() {
            return this._element.classList.contains("fade")
        }

        _triggerBackdropTransition() {
            if (!p.trigger(this._element, "hidePrevented.bs.modal").defaultPrevented) {
                let e = this._element.scrollHeight > document.documentElement.clientHeight,
                    t = this._element.style.overflowY;
                "hidden" === t || this._element.classList.contains(Ti) || (e || (this._element.style.overflowY = "hidden"), this._element.classList.add(Ti), this._queueCallback(() => {
                    this._element.classList.remove(Ti), this._queueCallback(() => {
                        this._element.style.overflowY = t
                    }, this._dialog)
                }, this._dialog), this._element.focus())
            }
        }

        _adjustDialog() {
            let e = this._element.scrollHeight > document.documentElement.clientHeight, t = this._scrollBar.getWidth(),
                i = 0 < t;
            if (i && !e) {
                let e = l() ? "paddingLeft" : "paddingRight";
                this._element.style[e] = t + "px"
            }
            if (!i && e) {
                let e = l() ? "paddingRight" : "paddingLeft";
                this._element.style[e] = t + "px"
            }
        }

        _resetAdjustments() {
            this._element.style.paddingLeft = "", this._element.style.paddingRight = ""
        }

        static jQueryInterface(t, i) {
            return this.each(function () {
                var e = _i.getOrCreateInstance(this, t);
                if ("string" == typeof t) {
                    if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
                    e[t](i)
                }
            })
        }
    }

    p.on(document, "click.bs.modal.data-api", '[data-bs-toggle="modal"]', function (e) {
        let t = d.getElementFromSelector(this);
        ["A", "AREA"].includes(this.tagName) && e.preventDefault(), p.one(t, Si, e => {
            e.defaultPrevented || p.one(t, Ci, () => {
                n(this) && this.focus()
            })
        });
        e = d.findOne(".modal.show");
        e && _i.getInstance(e).hide(), _i.getOrCreateInstance(t).toggle(this)
    }), ue(_i), e(_i);
    let Mi = ".bs.offcanvas", Ii = "showing", Oi = ".offcanvas.show", Di = "hidePrevented" + Mi, zi = "hidden" + Mi,
        Xi = {backdrop: !0, keyboard: !0, scroll: !1},
        Ni = {backdrop: "(boolean|string)", keyboard: "boolean", scroll: "boolean"};

    class D extends t {
        constructor(e, t) {
            super(e, t), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners()
        }

        static get Default() {
            return Xi
        }

        static get DefaultType() {
            return Ni
        }

        static get NAME() {
            return "offcanvas"
        }

        toggle(e) {
            return this._isShown ? this.hide() : this.show(e)
        }

        show(e) {
            this._isShown || p.trigger(this._element, "show.bs.offcanvas", {relatedTarget: e}).defaultPrevented || (this._isShown = !0, this._backdrop.show(), this._config.scroll || (new Ai).hide(), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.classList.add(Ii), this._queueCallback(() => {
                this._config.scroll && !this._config.backdrop || this._focustrap.activate(), this._element.classList.add("show"), this._element.classList.remove(Ii), p.trigger(this._element, "shown.bs.offcanvas", {relatedTarget: e})
            }, this._element, !0))
        }

        hide() {
            !this._isShown || p.trigger(this._element, "hide.bs.offcanvas").defaultPrevented || (this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.add("hiding"), this._backdrop.hide(), this._queueCallback(() => {
                this._element.classList.remove("show", "hiding"), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._config.scroll || (new Ai).reset(), p.trigger(this._element, zi)
            }, this._element, !0))
        }

        dispose() {
            this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose()
        }

        _initializeBackDrop() {
            var e = Boolean(this._config.backdrop);
            return new gi({
                className: "offcanvas-backdrop",
                isVisible: e,
                isAnimated: !0,
                rootElement: this._element.parentNode,
                clickCallback: e ? () => {
                    "static" !== this._config.backdrop ? this.hide() : p.trigger(this._element, Di)
                } : null
            })
        }

        _initializeFocusTrap() {
            return new bi({trapElement: this._element})
        }

        _addEventListeners() {
            p.on(this._element, "keydown.dismiss.bs.offcanvas", e => {
                "Escape" === e.key && (this._config.keyboard ? this.hide() : p.trigger(this._element, Di))
            })
        }

        static jQueryInterface(t) {
            return this.each(function () {
                var e = D.getOrCreateInstance(this, t);
                if ("string" == typeof t) {
                    if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
                    e[t](this)
                }
            })
        }
    }

    p.on(document, "click.bs.offcanvas.data-api", '[data-bs-toggle="offcanvas"]', function (e) {
        var t = d.getElementFromSelector(this);
        ["A", "AREA"].includes(this.tagName) && e.preventDefault(), o(this) || (p.one(t, zi, () => {
            n(this) && this.focus()
        }), (e = d.findOne(Oi)) && e !== t && D.getInstance(e).hide(), D.getOrCreateInstance(t).toggle(this))
    }), p.on(window, "load.bs.offcanvas.data-api", () => {
        for (var e of d.find(Oi)) D.getOrCreateInstance(e).show()
    }), p.on(window, "resize.bs.offcanvas", () => {
        for (var e of d.find("[aria-modal][class*=show][class*=offcanvas-]")) "fixed" !== getComputedStyle(e).position && D.getOrCreateInstance(e).hide()
    }), ue(D), e(D);
    let Fi = {
            "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i],
            a: ["target", "href", "title", "rel"],
            area: [],
            b: [],
            br: [],
            col: [],
            code: [],
            dd: [],
            div: [],
            dl: [],
            dt: [],
            em: [],
            hr: [],
            h1: [],
            h2: [],
            h3: [],
            h4: [],
            h5: [],
            h6: [],
            i: [],
            img: ["src", "srcset", "alt", "title", "width", "height"],
            li: [],
            ol: [],
            p: [],
            pre: [],
            s: [],
            small: [],
            span: [],
            sub: [],
            sup: [],
            strong: [],
            u: [],
            ul: []
        }, Hi = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]),
        Ri = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i, Yi = {
            allowList: Fi,
            content: {},
            extraClass: "",
            html: !1,
            sanitize: !0,
            sanitizeFn: null,
            template: "<div></div>"
        }, Wi = {
            allowList: "object",
            content: "object",
            extraClass: "(string|function)",
            html: "boolean",
            sanitize: "boolean",
            sanitizeFn: "(null|function)",
            template: "string"
        }, Bi = {entry: "(string|element|function|null)", selector: "(string|element)"};

    class ji extends he {
        constructor(e) {
            super(), this._config = this._getConfig(e)
        }

        static get Default() {
            return Yi
        }

        static get DefaultType() {
            return Wi
        }

        static get NAME() {
            return "TemplateFactory"
        }

        getContent() {
            return Object.values(this._config.content).map(e => this._resolvePossibleFunction(e)).filter(Boolean)
        }

        hasContent() {
            return 0 < this.getContent().length
        }

        changeContent(e) {
            return this._checkContent(e), this._config.content = {...this._config.content, ...e}, this
        }

        toHtml() {
            var i = document.createElement("div");
            i.innerHTML = this._maybeSanitize(this._config.template);
            for (let [e, t] of Object.entries(this._config.content)) this._setContent(i, t, e);
            let e = i.children[0], t = this._resolvePossibleFunction(this._config.extraClass);
            return t && e.classList.add(...t.split(" ")), e
        }

        _typeCheckConfig(e) {
            super._typeCheckConfig(e), this._checkContent(e.content)
        }

        _checkContent(e) {
            for (var [t, i] of Object.entries(e)) super._typeCheckConfig({selector: t, entry: i}, Bi)
        }

        _setContent(e, t, i) {
            i = d.findOne(i, e);
            i && ((t = this._resolvePossibleFunction(t)) ? r(t) ? this._putElementInTemplate(a(t), i) : this._config.html ? i.innerHTML = this._maybeSanitize(t) : i.textContent = t : i.remove())
        }

        _maybeSanitize(i) {
            if (this._config.sanitize) {
                var s = i, a = this._config.allowList, n = this._config.sanitizeFn;
                if (!s.length) return s;
                if (n && "function" == typeof n) return n(s);
                let e = (new window.DOMParser).parseFromString(s, "text/html"),
                    t = [].concat(...e.body.querySelectorAll("*"));
                for (let s of t) {
                    let e = s.nodeName.toLowerCase();
                    if (Object.keys(a).includes(e)) {
                        let t = [].concat(...s.attributes), i = [].concat(a["*"] || [], a[e] || []);
                        for (let e of t) ((e, t) => {
                            let i = e.nodeName.toLowerCase();
                            return t.includes(i) ? !Hi.has(i) || Boolean(Ri.test(e.nodeValue)) : t.filter(e => e instanceof RegExp).some(e => e.test(i))
                        })(e, i) || s.removeAttribute(e.nodeName)
                    } else s.remove()
                }
                return e.body.innerHTML
            }
            return i
        }

        _resolvePossibleFunction(e) {
            return c(e, [this])
        }

        _putElementInTemplate(e, t) {
            this._config.html ? (t.innerHTML = "", t.append(e)) : t.textContent = e.textContent
        }
    }

    let Gi = new Set(["sanitize", "allowList", "sanitizeFn"]), Vi = "fade", qi = "show", Ui = "hide.bs.modal",
        Zi = "hover", $i = "focus",
        Qi = {AUTO: "auto", TOP: "top", RIGHT: l() ? "left" : "right", BOTTOM: "bottom", LEFT: l() ? "right" : "left"},
        Ki = {
            allowList: Fi,
            animation: !0,
            boundary: "clippingParents",
            container: !1,
            customClass: "",
            delay: 0,
            fallbackPlacements: ["top", "right", "bottom", "left"],
            html: !1,
            offset: [0, 6],
            placement: "top",
            popperConfig: null,
            sanitize: !0,
            sanitizeFn: null,
            selector: !1,
            template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
            title: "",
            trigger: "hover focus"
        }, Ji = {
            allowList: "object",
            animation: "boolean",
            boundary: "(string|element)",
            container: "(string|element|boolean)",
            customClass: "(string|function)",
            delay: "(number|object)",
            fallbackPlacements: "array",
            html: "boolean",
            offset: "(array|string|function)",
            placement: "(string|function)",
            popperConfig: "(null|object|function)",
            sanitize: "boolean",
            sanitizeFn: "(null|function)",
            selector: "(string|boolean)",
            template: "string",
            title: "(string|element|function)",
            trigger: "string"
        };

    class es extends t {
        constructor(e, t) {
            if (void 0 === Vt) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
            super(e, t), this._isEnabled = !0, this._timeout = 0, this._isHovered = null, this._activeTrigger = {}, this._popper = null, this._templateFactory = null, this._newContent = null, this.tip = null, this._setListeners(), this._config.selector || this._fixTitle()
        }

        static get Default() {
            return Ki
        }

        static get DefaultType() {
            return Ji
        }

        static get NAME() {
            return "tooltip"
        }

        enable() {
            this._isEnabled = !0
        }

        disable() {
            this._isEnabled = !1
        }

        toggleEnabled() {
            this._isEnabled = !this._isEnabled
        }

        toggle() {
            this._isEnabled && (this._activeTrigger.click = !this._activeTrigger.click, this._isShown() ? this._leave() : this._enter())
        }

        dispose() {
            clearTimeout(this._timeout), p.off(this._element.closest(".modal"), Ui, this._hideModalHandler), this._element.getAttribute("data-bs-original-title") && this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title")), this._disposePopper(), super.dispose()
        }

        show() {
            if ("none" === this._element.style.display) throw new Error("Please use show on visible elements");
            if (this._isWithContent() && this._isEnabled) {
                let e = p.trigger(this._element, this.constructor.eventName("show")),
                    t = (R(this._element) || this._element.ownerDocument.documentElement).contains(this._element);
                if (!e.defaultPrevented && t) {
                    this._disposePopper();
                    var i = this._getTipElement(),
                        s = (this._element.setAttribute("aria-describedby", i.getAttribute("id")), this._config).container;
                    if (this._element.ownerDocument.documentElement.contains(this.tip) || (s.append(i), p.trigger(this._element, this.constructor.eventName("inserted"))), this._popper = this._createPopper(i), i.classList.add(qi), "ontouchstart" in document.documentElement) for (let e of [].concat(...document.body.children)) p.on(e, "mouseover", Y);
                    this._queueCallback(() => {
                        p.trigger(this._element, this.constructor.eventName("shown")), !1 === this._isHovered && this._leave(), this._isHovered = !1
                    }, this.tip, this._isAnimated())
                }
            }
        }

        hide() {
            if (this._isShown() && !p.trigger(this._element, this.constructor.eventName("hide")).defaultPrevented) {
                if (this._getTipElement().classList.remove(qi), "ontouchstart" in document.documentElement) for (var e of [].concat(...document.body.children)) p.off(e, "mouseover", Y);
                this._activeTrigger.click = !1, this._activeTrigger[$i] = !1, this._activeTrigger[Zi] = !1, this._isHovered = null, this._queueCallback(() => {
                    this._isWithActiveTrigger() || (this._isHovered || this._disposePopper(), this._element.removeAttribute("aria-describedby"), p.trigger(this._element, this.constructor.eventName("hidden")))
                }, this.tip, this._isAnimated())
            }
        }

        update() {
            this._popper && this._popper.update()
        }

        _isWithContent() {
            return Boolean(this._getTitle())
        }

        _getTipElement() {
            return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())), this.tip
        }

        _createTipElement(e) {
            e = this._getTemplateFactory(e).toHtml();
            if (!e) return null;
            e.classList.remove(Vi, qi), e.classList.add(`bs-${this.constructor.NAME}-auto`);
            var t = (e => {
                for (; e += Math.floor(1e6 * Math.random()), document.getElementById(e);) ;
                return e
            })(this.constructor.NAME).toString();
            return e.setAttribute("id", t), this._isAnimated() && e.classList.add(Vi), e
        }

        setContent(e) {
            this._newContent = e, this._isShown() && (this._disposePopper(), this.show())
        }

        _getTemplateFactory(e) {
            return this._templateFactory ? this._templateFactory.changeContent(e) : this._templateFactory = new ji({
                ...this._config,
                content: e,
                extraClass: this._resolvePossibleFunction(this._config.customClass)
            }), this._templateFactory
        }

        _getContentForTemplate() {
            return {".tooltip-inner": this._getTitle()}
        }

        _getTitle() {
            return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title")
        }

        _initializeOnDelegatedTarget(e) {
            return this.constructor.getOrCreateInstance(e.delegateTarget, this._getDelegateConfig())
        }

        _isAnimated() {
            return this._config.animation || this.tip && this.tip.classList.contains(Vi)
        }

        _isShown() {
            return this.tip && this.tip.classList.contains(qi)
        }

        _createPopper(e) {
            var t = c(this._config.placement, [this, e, this._element]), t = Qi[t.toUpperCase()];
            return Gt(this._element, e, this._getPopperConfig(t))
        }

        _getOffset() {
            let t = this._config.offset;
            return "string" == typeof t ? t.split(",").map(e => Number.parseInt(e, 10)) : "function" == typeof t ? e => t(e, this._element) : t
        }

        _resolvePossibleFunction(e) {
            return c(e, [this._element])
        }

        _getPopperConfig(e) {
            e = {
                placement: e,
                modifiers: [{
                    name: "flip",
                    options: {fallbackPlacements: this._config.fallbackPlacements}
                }, {name: "offset", options: {offset: this._getOffset()}}, {
                    name: "preventOverflow",
                    options: {boundary: this._config.boundary}
                }, {name: "arrow", options: {element: `.${this.constructor.NAME}-arrow`}}, {
                    name: "preSetPlacement",
                    enabled: !0,
                    phase: "beforeMain",
                    fn: e => {
                        this._getTipElement().setAttribute("data-popper-placement", e.state.placement)
                    }
                }]
            };
            return {...e, ...c(this._config.popperConfig, [e])}
        }

        _setListeners() {
            let e = this._config.trigger.split(" ");
            for (var i of e) if ("click" === i) p.on(this._element, this.constructor.eventName("click"), this._config.selector, e => {
                this._initializeOnDelegatedTarget(e).toggle()
            }); else if ("manual" !== i) {
                let e = i === Zi ? this.constructor.eventName("mouseenter") : this.constructor.eventName("focusin"),
                    t = i === Zi ? this.constructor.eventName("mouseleave") : this.constructor.eventName("focusout");
                p.on(this._element, e, this._config.selector, e => {
                    var t = this._initializeOnDelegatedTarget(e);
                    t._activeTrigger["focusin" === e.type ? $i : Zi] = !0, t._enter()
                }), p.on(this._element, t, this._config.selector, e => {
                    var t = this._initializeOnDelegatedTarget(e);
                    t._activeTrigger["focusout" === e.type ? $i : Zi] = t._element.contains(e.relatedTarget), t._leave()
                })
            }
            this._hideModalHandler = () => {
                this._element && this.hide()
            }, p.on(this._element.closest(".modal"), Ui, this._hideModalHandler)
        }

        _fixTitle() {
            var e = this._element.getAttribute("title");
            e && (this._element.getAttribute("aria-label") || this._element.textContent.trim() || this._element.setAttribute("aria-label", e), this._element.setAttribute("data-bs-original-title", e), this._element.removeAttribute("title"))
        }

        _enter() {
            this._isShown() || this._isHovered ? this._isHovered = !0 : (this._isHovered = !0, this._setTimeout(() => {
                this._isHovered && this.show()
            }, this._config.delay.show))
        }

        _leave() {
            this._isWithActiveTrigger() || (this._isHovered = !1, this._setTimeout(() => {
                this._isHovered || this.hide()
            }, this._config.delay.hide))
        }

        _setTimeout(e, t) {
            clearTimeout(this._timeout), this._timeout = setTimeout(e, t)
        }

        _isWithActiveTrigger() {
            return Object.values(this._activeTrigger).includes(!0)
        }

        _getConfig(e) {
            var t = h.getDataAttributes(this._element);
            for (let e of Object.keys(t)) Gi.has(e) && delete t[e];
            return e = {...t, ..."object" == typeof e && e ? e : {}}, e = this._mergeConfigObj(e), e = this._configAfterMerge(e), this._typeCheckConfig(e), e
        }

        _configAfterMerge(e) {
            return e.container = !1 === e.container ? document.body : a(e.container), "number" == typeof e.delay && (e.delay = {
                show: e.delay,
                hide: e.delay
            }), "number" == typeof e.title && (e.title = e.title.toString()), "number" == typeof e.content && (e.content = e.content.toString()), e
        }

        _getDelegateConfig() {
            var e, t, i = {};
            for ([e, t] of Object.entries(this._config)) this.constructor.Default[e] !== t && (i[e] = t);
            return i.selector = !1, i.trigger = "manual", i
        }

        _disposePopper() {
            this._popper && (this._popper.destroy(), this._popper = null), this.tip && (this.tip.remove(), this.tip = null)
        }

        static jQueryInterface(t) {
            return this.each(function () {
                var e = es.getOrCreateInstance(this, t);
                if ("string" == typeof t) {
                    if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
                    e[t]()
                }
            })
        }
    }

    e(es);
    let ts = {
        ...es.Default,
        content: "",
        offset: [0, 8],
        placement: "right",
        template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
        trigger: "click"
    }, is = {...es.DefaultType, content: "(null|string|element|function)"};

    class ss extends es {
        static get Default() {
            return ts
        }

        static get DefaultType() {
            return is
        }

        static get NAME() {
            return "popover"
        }

        _isWithContent() {
            return this._getTitle() || this._getContent()
        }

        _getContentForTemplate() {
            return {".popover-header": this._getTitle(), ".popover-body": this._getContent()}
        }

        _getContent() {
            return this._resolvePossibleFunction(this._config.content)
        }

        static jQueryInterface(t) {
            return this.each(function () {
                var e = ss.getOrCreateInstance(this, t);
                if ("string" == typeof t) {
                    if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
                    e[t]()
                }
            })
        }
    }

    e(ss);
    let as = ".bs.scrollspy", ns = "click" + as, rs = "active", os = "[href]",
        ls = {offset: null, rootMargin: "0px 0px -25%", smoothScroll: !1, target: null, threshold: [.1, .5, 1]}, cs = {
            offset: "(number|null)",
            rootMargin: "string",
            smoothScroll: "boolean",
            target: "element",
            threshold: "array"
        };

    class hs extends t {
        constructor(e, t) {
            super(e, t), this._targetLinks = new Map, this._observableSections = new Map, this._rootElement = "visible" === getComputedStyle(this._element).overflowY ? null : this._element, this._activeTarget = null, this._observer = null, this._previousScrollData = {
                visibleEntryTop: 0,
                parentScrollTop: 0
            }, this.refresh()
        }

        static get Default() {
            return ls
        }

        static get DefaultType() {
            return cs
        }

        static get NAME() {
            return "scrollspy"
        }

        refresh() {
            this._initializeTargetsAndObservables(), this._maybeEnableSmoothScroll(), this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver();
            for (var e of this._observableSections.values()) this._observer.observe(e)
        }

        dispose() {
            this._observer.disconnect(), super.dispose()
        }

        _configAfterMerge(e) {
            return e.target = a(e.target) || document.body, e.rootMargin = e.offset ? e.offset + "px 0px -30%" : e.rootMargin, "string" == typeof e.threshold && (e.threshold = e.threshold.split(",").map(e => Number.parseFloat(e))), e
        }

        _maybeEnableSmoothScroll() {
            this._config.smoothScroll && (p.off(this._config.target, ns), p.on(this._config.target, ns, os, e => {
                var t = this._observableSections.get(e.target.hash);
                t && (e.preventDefault(), e = this._rootElement || window, t = t.offsetTop - this._element.offsetTop, e.scrollTo ? e.scrollTo({
                    top: t,
                    behavior: "smooth"
                }) : e.scrollTop = t)
            }))
        }

        _getNewObserver() {
            var e = {root: this._rootElement, threshold: this._config.threshold, rootMargin: this._config.rootMargin};
            return new IntersectionObserver(e => this._observerCallback(e), e)
        }

        _observerCallback(e) {
            let t = e => this._targetLinks.get("#" + e.target.id), i = e => {
                    this._previousScrollData.visibleEntryTop = e.target.offsetTop, this._process(t(e))
                }, s = (this._rootElement || document.documentElement).scrollTop,
                a = s >= this._previousScrollData.parentScrollTop;
            this._previousScrollData.parentScrollTop = s;
            for (var n of e) if (n.isIntersecting) {
                let e = n.target.offsetTop >= this._previousScrollData.visibleEntryTop;
                if (a && e) {
                    if (i(n), !s) return
                } else a || e || i(n)
            } else this._activeTarget = null, this._clearActiveClass(t(n))
        }

        _initializeTargetsAndObservables() {
            this._targetLinks = new Map, this._observableSections = new Map;
            let e = d.find(os, this._config.target);
            for (var t of e) if (t.hash && !o(t)) {
                let e = d.findOne(decodeURI(t.hash), this._element);
                n(e) && (this._targetLinks.set(decodeURI(t.hash), t), this._observableSections.set(t.hash, e))
            }
        }

        _process(e) {
            this._activeTarget !== e && (this._clearActiveClass(this._config.target), (this._activeTarget = e).classList.add(rs), this._activateParents(e), p.trigger(this._element, "activate.bs.scrollspy", {relatedTarget: e}))
        }

        _activateParents(e) {
            if (e.classList.contains("dropdown-item")) d.findOne(".dropdown-toggle", e.closest(".dropdown")).classList.add(rs); else for (var t of d.parents(e, ".nav, .list-group")) for (let e of d.prev(t, ".nav-link, .nav-item > .nav-link, .list-group-item")) e.classList.add(rs)
        }

        _clearActiveClass(e) {
            e.classList.remove(rs);
            var t = d.find(os + "." + rs, e);
            for (let e of t) e.classList.remove(rs)
        }

        static jQueryInterface(t) {
            return this.each(function () {
                var e = hs.getOrCreateInstance(this, t);
                if ("string" == typeof t) {
                    if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
                    e[t]()
                }
            })
        }
    }

    p.on(window, "load.bs.scrollspy.data-api", () => {
        for (var e of d.find('[data-bs-spy="scroll"]')) hs.getOrCreateInstance(e)
    }), e(hs);
    let ds = "ArrowRight", us = "ArrowDown", gs = "Home", z = "active", ps = "show", fs = ".dropdown-toggle",
        xs = `:not(${fs})`, ms = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]',
        bs = `.nav-link${xs}, .list-group-item${xs}, [role="tab"]${xs}, ` + ms;
    z, z, z;

    class vs extends t {
        constructor(e) {
            super(e), this._parent = this._element.closest('.list-group, .nav, [role="tablist"]'), this._parent && (this._setInitialAttributes(this._parent, this._getChildren()), p.on(this._element, "keydown.bs.tab", e => this._keydown(e)))
        }

        static get NAME() {
            return "tab"
        }

        show() {
            var e, t, i = this._element;
            this._elemIsActive(i) || (t = (e = this._getActiveElem()) ? p.trigger(e, "hide.bs.tab", {relatedTarget: i}) : null, p.trigger(i, "show.bs.tab", {relatedTarget: e}).defaultPrevented) || t && t.defaultPrevented || (this._deactivate(e, i), this._activate(i, e))
        }

        _activate(e, t) {
            e && (e.classList.add(z), this._activate(d.getElementFromSelector(e)), this._queueCallback(() => {
                "tab" === e.getAttribute("role") ? (e.removeAttribute("tabindex"), e.setAttribute("aria-selected", !0), this._toggleDropDown(e, !0), p.trigger(e, "shown.bs.tab", {relatedTarget: t})) : e.classList.add(ps)
            }, e, e.classList.contains("fade")))
        }

        _deactivate(e, t) {
            e && (e.classList.remove(z), e.blur(), this._deactivate(d.getElementFromSelector(e)), this._queueCallback(() => {
                "tab" === e.getAttribute("role") ? (e.setAttribute("aria-selected", !1), e.setAttribute("tabindex", "-1"), this._toggleDropDown(e, !1), p.trigger(e, "hidden.bs.tab", {relatedTarget: t})) : e.classList.remove(ps)
            }, e, e.classList.contains("fade")))
        }

        _keydown(t) {
            if (["ArrowLeft", ds, "ArrowUp", us, gs, "End"].includes(t.key)) {
                t.stopPropagation(), t.preventDefault();
                var i, s = this._getChildren().filter(e => !o(e));
                let e;
                (e = [gs, "End"].includes(t.key) ? s[t.key === gs ? 0 : s.length - 1] : (i = [ds, us].includes(t.key), V(s, t.target, i, !0))) && (e.focus({preventScroll: !0}), vs.getOrCreateInstance(e).show())
            }
        }

        _getChildren() {
            return d.find(bs, this._parent)
        }

        _getActiveElem() {
            return this._getChildren().find(e => this._elemIsActive(e)) || null
        }

        _setInitialAttributes(e, t) {
            this._setAttributeIfNotExists(e, "role", "tablist");
            for (let e of t) this._setInitialAttributesOnChild(e)
        }

        _setInitialAttributesOnChild(e) {
            e = this._getInnerElement(e);
            var t = this._elemIsActive(e), i = this._getOuterElement(e);
            e.setAttribute("aria-selected", t), i !== e && this._setAttributeIfNotExists(i, "role", "presentation"), t || e.setAttribute("tabindex", "-1"), this._setAttributeIfNotExists(e, "role", "tab"), this._setInitialAttributesOnTargetPanel(e)
        }

        _setInitialAttributesOnTargetPanel(e) {
            var t = d.getElementFromSelector(e);
            t && (this._setAttributeIfNotExists(t, "role", "tabpanel"), e.id) && this._setAttributeIfNotExists(t, "aria-labelledby", "" + e.id)
        }

        _toggleDropDown(e, i) {
            let s = this._getOuterElement(e);
            s.classList.contains("dropdown") && ((e = (e, t) => {
                e = d.findOne(e, s);
                e && e.classList.toggle(t, i)
            })(fs, z), e(".dropdown-menu", ps), s.setAttribute("aria-expanded", i))
        }

        _setAttributeIfNotExists(e, t, i) {
            e.hasAttribute(t) || e.setAttribute(t, i)
        }

        _elemIsActive(e) {
            return e.classList.contains(z)
        }

        _getInnerElement(e) {
            return e.matches(bs) ? e : d.findOne(bs, e)
        }

        _getOuterElement(e) {
            return e.closest(".nav-item, .list-group-item") || e
        }

        static jQueryInterface(t) {
            return this.each(function () {
                var e = vs.getOrCreateInstance(this);
                if ("string" == typeof t) {
                    if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
                    e[t]()
                }
            })
        }
    }

    p.on(document, "click.bs.tab", ms, function (e) {
        ["A", "AREA"].includes(this.tagName) && e.preventDefault(), o(this) || vs.getOrCreateInstance(this).show()
    }), p.on(window, "load.bs.tab", () => {
        for (var e of d.find('.active[data-bs-toggle="tab"], .active[data-bs-toggle="pill"], .active[data-bs-toggle="list"]')) vs.getOrCreateInstance(e)
    }), e(vs);
    let ys = "show", ws = "showing", ks = {animation: "boolean", autohide: "boolean", delay: "number"},
        As = {animation: !0, autohide: !0, delay: 5e3};

    class Cs extends t {
        constructor(e, t) {
            super(e, t), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners()
        }

        static get Default() {
            return As
        }

        static get DefaultType() {
            return ks
        }

        static get NAME() {
            return "toast"
        }

        show() {
            p.trigger(this._element, "show.bs.toast").defaultPrevented || (this._clearTimeout(), this._config.animation && this._element.classList.add("fade"), this._element.classList.remove("hide"), W(this._element), this._element.classList.add(ys, ws), this._queueCallback(() => {
                this._element.classList.remove(ws), p.trigger(this._element, "shown.bs.toast"), this._maybeScheduleHide()
            }, this._element, this._config.animation))
        }

        hide() {
            !this.isShown() || p.trigger(this._element, "hide.bs.toast").defaultPrevented || (this._element.classList.add(ws), this._queueCallback(() => {
                this._element.classList.add("hide"), this._element.classList.remove(ws, ys), p.trigger(this._element, "hidden.bs.toast")
            }, this._element, this._config.animation))
        }

        dispose() {
            this._clearTimeout(), this.isShown() && this._element.classList.remove(ys), super.dispose()
        }

        isShown() {
            return this._element.classList.contains(ys)
        }

        _maybeScheduleHide() {
            !this._config.autohide || this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => {
                this.hide()
            }, this._config.delay))
        }

        _onInteraction(e, t) {
            switch (e.type) {
                case"mouseover":
                case"mouseout":
                    this._hasMouseInteraction = t;
                    break;
                case"focusin":
                case"focusout":
                    this._hasKeyboardInteraction = t
            }
            t ? this._clearTimeout() : this._element === (e = e.relatedTarget) || this._element.contains(e) || this._maybeScheduleHide()
        }

        _setListeners() {
            p.on(this._element, "mouseover.bs.toast", e => this._onInteraction(e, !0)), p.on(this._element, "mouseout.bs.toast", e => this._onInteraction(e, !1)), p.on(this._element, "focusin.bs.toast", e => this._onInteraction(e, !0)), p.on(this._element, "focusout.bs.toast", e => this._onInteraction(e, !1))
        }

        _clearTimeout() {
            clearTimeout(this._timeout), this._timeout = null
        }

        static jQueryInterface(t) {
            return this.each(function () {
                var e = Cs.getOrCreateInstance(this, t);
                if ("string" == typeof t) {
                    if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
                    e[t](this)
                }
            })
        }
    }

    return ue(Cs), e(Cs), {
        Alert: ge,
        Button: fe,
        Carousel: _e,
        Collapse: Xe,
        Dropdown: C,
        Modal: _i,
        Offcanvas: D,
        Popover: ss,
        ScrollSpy: hs,
        Tab: vs,
        Toast: Cs,
        Tooltip: es
    }
}), ((e, t) => {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).ApexCharts = t()
})(this, function () {
    function D(e, t) {
        (null == t || t > e.length) && (t = e.length);
        for (var i = 0, s = Array(t); i < t; i++) s[i] = e[i];
        return s
    }

    function z(e) {
        if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e
    }

    function s(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    function X(e, t) {
        for (var i = 0; i < t.length; i++) {
            var s = t[i];
            s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(e, j(s.key), s)
        }
    }

    function e(e, t, i) {
        t && X(e.prototype, t), i && X(e, i), Object.defineProperty(e, "prototype", {writable: !1})
    }

    function t(i) {
        var s = F();
        return function () {
            var e, t = N(i),
                t = (e = s ? (e = N(this).constructor, Reflect.construct(t, arguments, e)) : t.apply(this, arguments), this);
            if (e && ("object" == typeof e || "function" == typeof e)) return e;
            if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            return z(t)
        }
    }

    function u(e, t, i) {
        return (t = j(t)) in e ? Object.defineProperty(e, t, {
            value: i,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = i, e
    }

    function N(e) {
        return (N = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function i(e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
        e.prototype = Object.create(t && t.prototype, {
            constructor: {
                value: e,
                writable: !0,
                configurable: !0
            }
        }), Object.defineProperty(e, "prototype", {writable: !1}), t && W(e, t)
    }

    function F() {
        try {
            var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {
            }))
        } catch (e) {
        }
        return (F = function () {
            return !!e
        })()
    }

    function H(t, e) {
        var i, s = Object.keys(t);
        return Object.getOwnPropertySymbols && (i = Object.getOwnPropertySymbols(t), e && (i = i.filter(function (e) {
            return Object.getOwnPropertyDescriptor(t, e).enumerable
        })), s.push.apply(s, i)), s
    }

    function M(t) {
        for (var e = 1; e < arguments.length; e++) {
            var i = null != arguments[e] ? arguments[e] : {};
            e % 2 ? H(Object(i), !0).forEach(function (e) {
                u(t, e, i[e])
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : H(Object(i)).forEach(function (e) {
                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e))
            })
        }
        return t
    }

    function W(e, t) {
        return (W = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }

    function B(e, t) {
        return (e => {
            if (Array.isArray(e)) return e
        })(e) || ((e, t) => {
            var i = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
            if (null != i) {
                var s, a, n, r, o = [], l = !0, c = !1;
                try {
                    if (n = (i = i.call(e)).next, 0 === t) {
                        if (Object(i) !== i) return;
                        l = !1
                    } else for (; !(l = (s = n.call(i)).done) && (o.push(s.value), o.length !== t); l = !0) ;
                } catch (e) {
                    c = !0, a = e
                } finally {
                    try {
                        if (!l && null != i.return && (r = i.return(), Object(r) !== r)) return
                    } finally {
                        if (c) throw a
                    }
                }
                return o
            }
        })(e, t) || G(e, t) || (() => {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        })()
    }

    function C(e) {
        return (e => {
            if (Array.isArray(e)) return D(e)
        })(e) || (() => {
            if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e)
        })() || G(e) || (() => {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        })()
    }

    function j(e) {
        e = (e => {
            if ("object" != typeof e || !e) return e;
            var t = e[Symbol.toPrimitive];
            if (void 0 === t) return String(e);
            if ("object" != typeof (t = t.call(e, "string"))) return t;
            throw new TypeError("@@toPrimitive must return a primitive value.")
        })(e);
        return "symbol" == typeof e ? e : e + ""
    }

    function v(e) {
        return (v = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
            return typeof e
        } : function (e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        })(e)
    }

    function G(e, t) {
        var i;
        if (e) return "string" == typeof e ? D(e, t) : "Map" === (i = "Object" === (i = {}.toString.call(e).slice(8, -1)) && e.constructor ? e.constructor.name : i) || "Set" === i ? Array.from(e) : "Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? D(e, t) : void 0
    }

    e(n, [{
        key: "shadeRGBColor", value: function (e, t) {
            var t = t.split(","), i = e < 0 ? 0 : 255, e = e < 0 ? -1 * e : e, s = parseInt(t[0].slice(4), 10),
                a = parseInt(t[1], 10), t = parseInt(t[2], 10);
            return "rgb(" + (Math.round((i - s) * e) + s) + "," + (Math.round((i - a) * e) + a) + "," + (Math.round((i - t) * e) + t) + ")"
        }
    }, {
        key: "shadeHexColor", value: function (e, t) {
            var t = parseInt(t.slice(1), 16), i = e < 0 ? 0 : 255, e = e < 0 ? -1 * e : e, s = t >> 16,
                a = t >> 8 & 255, t = 255 & t;
            return "#" + (16777216 + 65536 * (Math.round((i - s) * e) + s) + 256 * (Math.round((i - a) * e) + a) + (Math.round((i - t) * e) + t)).toString(16).slice(1)
        }
    }, {
        key: "shadeColor", value: function (e, t) {
            return n.isColorHex(t) ? this.shadeHexColor(e, t) : this.shadeRGBColor(e, t)
        }
    }], [{
        key: "bind", value: function (e, t) {
            return function () {
                return e.apply(t, arguments)
            }
        }
    }, {
        key: "isObject", value: function (e) {
            return e && "object" === v(e) && !Array.isArray(e) && null != e
        }
    }, {
        key: "is", value: function (e, t) {
            return Object.prototype.toString.call(t) === "[object " + e + "]"
        }
    }, {
        key: "listToArray", value: function (e) {
            for (var t = [], i = 0; i < e.length; i++) t[i] = e[i];
            return t
        }
    }, {
        key: "extend", value: function (t, i) {
            var s = this, a = ("function" != typeof Object.assign && (Object.assign = function (e) {
                if (null == e) throw new TypeError("Cannot convert undefined or null to object");
                for (var t = Object(e), i = 1; i < arguments.length; i++) {
                    var s = arguments[i];
                    if (null != s) for (var a in s) s.hasOwnProperty(a) && (t[a] = s[a])
                }
                return t
            }), Object.assign({}, t));
            return this.isObject(t) && this.isObject(i) && Object.keys(i).forEach(function (e) {
                s.isObject(i[e]) && e in t ? a[e] = s.extend(t[e], i[e]) : Object.assign(a, u({}, e, i[e]))
            }), a
        }
    }, {
        key: "extendArray", value: function (e, t) {
            var i = [];
            return e.map(function (e) {
                i.push(n.extend(t, e))
            }), i
        }
    }, {
        key: "monthMod", value: function (e) {
            return e % 12
        }
    }, {
        key: "clone", value: function (e) {
            if (n.is("Array", e)) {
                for (var t = [], i = 0; i < e.length; i++) t[i] = this.clone(e[i]);
                return t
            }
            if (n.is("Null", e)) return null;
            if (n.is("Date", e)) return e;
            if ("object" !== v(e)) return e;
            var s, a = {};
            for (s in e) e.hasOwnProperty(s) && (a[s] = this.clone(e[s]));
            return a
        }
    }, {
        key: "log10", value: function (e) {
            return Math.log(e) / Math.LN10
        }
    }, {
        key: "roundToBase10", value: function (e) {
            return Math.pow(10, Math.floor(Math.log10(e)))
        }
    }, {
        key: "roundToBase", value: function (e, t) {
            return Math.pow(t, Math.floor(Math.log(e) / Math.log(t)))
        }
    }, {
        key: "parseNumber", value: function (e) {
            return null === e ? e : parseFloat(e)
        }
    }, {
        key: "stripNumber", value: function (e) {
            var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 2;
            return Number.isInteger(e) ? e : parseFloat(e.toPrecision(t))
        }
    }, {
        key: "randomId", value: function () {
            return (Math.random() + 1).toString(36).substring(4)
        }
    }, {
        key: "noExponents", value: function (e) {
            var t = String(e).split(/[eE]/);
            if (1 === t.length) return t[0];
            var i = "", e = e < 0 ? "-" : "", s = t[0].replace(".", ""), a = Number(t[1]) + 1;
            if (a < 0) {
                for (i = e + "0."; a++;) i += "0";
                return i + s.replace(/^-/, "")
            }
            for (a -= s.length; a--;) i += "0";
            return s + i
        }
    }, {
        key: "getDimensions", value: function (e) {
            var t = getComputedStyle(e, null), i = e.clientHeight, e = e.clientWidth;
            return i -= parseFloat(t.paddingTop) + parseFloat(t.paddingBottom), [e -= parseFloat(t.paddingLeft) + parseFloat(t.paddingRight), i]
        }
    }, {
        key: "getBoundingClientRect", value: function (e) {
            var t = e.getBoundingClientRect();
            return {
                top: t.top,
                right: t.right,
                bottom: t.bottom,
                left: t.left,
                width: e.clientWidth,
                height: e.clientHeight,
                x: t.left,
                y: t.top
            }
        }
    }, {
        key: "getLargestStringFromArr", value: function (e) {
            return e.reduce(function (e, t) {
                return Array.isArray(t) && (t = t.reduce(function (e, t) {
                    return e.length > t.length ? e : t
                })), e.length > t.length ? e : t
            }, 0)
        }
    }, {
        key: "hexToRgba", value: function () {
            for (var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : "#999999", t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : .6, i = (i = (e = "#" !== e.substring(0, 1) ? "#999999" : e).replace("#", "")).match(new RegExp("(.{" + i.length / 3 + "})", "g")), s = 0; s < i.length; s++) i[s] = parseInt(1 === i[s].length ? i[s] + i[s] : i[s], 16);
            return void 0 !== t && i.push(t), "rgba(" + i.join(",") + ")"
        }
    }, {
        key: "getOpacityFromRGBA", value: function (e) {
            return parseFloat(e.replace(/^.*,(.+)\)/, "$1"))
        }
    }, {
        key: "rgb2hex", value: function (e) {
            return (e = e.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && 4 === e.length ? "#" + ("0" + parseInt(e[1], 10).toString(16)).slice(-2) + ("0" + parseInt(e[2], 10).toString(16)).slice(-2) + ("0" + parseInt(e[3], 10).toString(16)).slice(-2) : ""
        }
    }, {
        key: "isColorHex", value: function (e) {
            return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(e)
        }
    }, {
        key: "getPolygonPos", value: function (e, t) {
            for (var i = [], s = 2 * Math.PI / t, a = 0; a < t; a++) {
                var n = {};
                n.x = e * Math.sin(a * s), n.y = -e * Math.cos(a * s), i.push(n)
            }
            return i
        }
    }, {
        key: "polarToCartesian", value: function (e, t, i, s) {
            s = (s - 90) * Math.PI / 180;
            return {x: e + i * Math.cos(s), y: t + i * Math.sin(s)}
        }
    }, {
        key: "escapeString", value: function (e) {
            var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "x", e = e.toString().slice();
            return e.replace(/[` ~!@#$%^&*()|+\=?;:'",.<>{}[\]\\/]/gi, t)
        }
    }, {
        key: "negToZero", value: function (e) {
            return e < 0 ? 0 : e
        }
    }, {
        key: "moveIndexInArray", value: function (e, t, i) {
            if (i >= e.length) for (var s = i - e.length + 1; s--;) e.push(void 0);
            return e.splice(i, 0, e.splice(t, 1)[0]), e
        }
    }, {
        key: "extractNumber", value: function (e) {
            return parseFloat(e.replace(/[^\d.]*/g, ""))
        }
    }, {
        key: "findAncestor", value: function (e, t) {
            for (; (e = e.parentElement) && !e.classList.contains(t);) ;
            return e
        }
    }, {
        key: "setELstyles", value: function (e, t) {
            for (var i in t) t.hasOwnProperty(i) && (e.style.key = t[i])
        }
    }, {
        key: "preciseAddition", value: function (e, t) {
            var i = (String(e).split(".")[1] || "").length, s = (String(t).split(".")[1] || "").length,
                i = Math.pow(10, Math.max(i, s));
            return (Math.round(e * i) + Math.round(t * i)) / i
        }
    }, {
        key: "isNumber", value: function (e) {
            return !isNaN(e) && parseFloat(Number(e)) === e && !isNaN(parseInt(e, 10))
        }
    }, {
        key: "isFloat", value: function (e) {
            return Number(e) === e && e % 1 != 0
        }
    }, {
        key: "isSafari", value: function () {
            return /^((?!chrome|android).)*safari/i.test(navigator.userAgent)
        }
    }, {
        key: "isFirefox", value: function () {
            return -1 < navigator.userAgent.toLowerCase().indexOf("firefox")
        }
    }, {
        key: "isMsEdge", value: function () {
            var e = window.navigator.userAgent, t = e.indexOf("Edge/");
            return 0 < t && parseInt(e.substring(t + 5, e.indexOf(".", t)), 10)
        }
    }, {
        key: "getGCD", value: function (e, t) {
            var i = Math.pow(10, (2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 7) - Math.floor(Math.log10(Math.max(e, t))));
            for (e = Math.round(Math.abs(e) * i), t = Math.round(Math.abs(t) * i); t;) {
                var s = t;
                t = e % t, e = s
            }
            return e / i
        }
    }, {
        key: "getPrimeFactors", value: function (e) {
            for (var t = [], i = 2; 2 <= e;) e % i == 0 ? (t.push(i), e /= i) : i++;
            return t
        }
    }, {
        key: "mod", value: function (e, t) {
            var i = Math.pow(10, (2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 7) - Math.floor(Math.log10(Math.max(e, t))));
            return (e = Math.round(Math.abs(e) * i)) % (t = Math.round(Math.abs(t) * i)) / i
        }
    }]);
    var R = n, A = (e(ne, [{
        key: "setEasingFunctions", value: function () {
            var e;
            if (!this.w.globals.easing) {
                switch (this.w.config.chart.animations.easing) {
                    case"linear":
                        e = "-";
                        break;
                    case"easein":
                        e = "<";
                        break;
                    case"easeout":
                        e = ">";
                        break;
                    case"easeinout":
                    default:
                        e = "<>";
                        break;
                    case"swing":
                        e = function (e) {
                            return --e * e * (2.70158 * e + 1.70158) + 1
                        };
                        break;
                    case"bounce":
                        e = function (e) {
                            return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375
                        };
                        break;
                    case"elastic":
                        e = function (e) {
                            return e === !!e ? e : Math.pow(2, -10 * e) * Math.sin(2 * Math.PI * (e - .075) / .3) + 1
                        }
                }
                this.w.globals.easing = e
            }
        }
    }, {
        key: "animateLine", value: function (e, t, i, s) {
            e.attr(t).animate(s).attr(i)
        }
    }, {
        key: "animateMarker", value: function (e, t, i, s) {
            e.attr({opacity: 0}).animate(t, i).attr({opacity: 1}).afterAll(function () {
                s()
            })
        }
    }, {
        key: "animateRect", value: function (e, t, i, s, a) {
            e.attr(t).animate(s).attr(i).afterAll(function () {
                return a()
            })
        }
    }, {
        key: "animatePathsGradually", value: function (e) {
            var t = e.el, i = this.w, s = 0;
            i.config.chart.animations.animateGradually.enabled && (s = i.config.chart.animations.animateGradually.delay), i.config.chart.animations.dynamicAnimation.enabled && i.globals.dataChanged && "bar" !== i.config.chart.type && (s = 0), this.morphSVG(t, e.realIndex, e.j, "line" !== i.config.chart.type || i.globals.comboCharts ? e.fill : "stroke", e.pathFrom, e.pathTo, e.speed, e.delay * s)
        }
    }, {
        key: "showDelayedElements", value: function () {
            this.w.globals.delayedElements.forEach(function (e) {
                e = e.el;
                e.classList.remove("apexcharts-element-hidden"), e.classList.add("apexcharts-hidden-element-shown")
            })
        }
    }, {
        key: "animationCompleted", value: function (e) {
            var t = this.w;
            t.globals.animationEnded || (t.globals.animationEnded = !0, this.showDelayedElements(), "function" == typeof t.config.chart.events.animationEnd && t.config.chart.events.animationEnd(this.ctx, {
                el: e,
                w: t
            }))
        }
    }, {
        key: "morphSVG", value: function (e, t, i, s, a, n, r, o) {
            function l(e) {
                return "radar" === h.config.chart.type && (r = 1), "M 0 ".concat(h.globals.gridHeight)
            }

            var c = this, h = this.w;
            a = a || e.attr("pathFrom"), n = n || e.attr("pathTo");
            (!a || -1 < a.indexOf("undefined") || -1 < a.indexOf("NaN")) && (a = l()), (!n || -1 < n.indexOf("undefined") || -1 < n.indexOf("NaN")) && (n = l()), h.globals.shouldAnimate || (r = 1), e.plot(a).animate(1, h.globals.easing, o).plot(a).animate(r, h.globals.easing, o).plot(n).afterAll(function () {
                R.isNumber(i) ? i === h.globals.series[h.globals.maxValsInArrayIndex].length - 2 && h.globals.shouldAnimate && c.animationCompleted(e) : "none" !== s && h.globals.shouldAnimate && (!h.globals.comboCharts && t === h.globals.series.length - 1 || h.globals.comboCharts) && c.animationCompleted(e), c.showDelayedElements()
            })
        }
    }]), ne), P = (e(ae, [{
        key: "getDefaultFilter", value: function (e, t) {
            var i = this.w;
            e.unfilter(!0), (new window.SVG.Filter).size("120%", "180%", "-5%", "-40%"), "none" !== i.config.states.normal.filter ? this.applyFilter(e, t, i.config.states.normal.filter.type, i.config.states.normal.filter.value) : i.config.chart.dropShadow.enabled && this.dropShadow(e, i.config.chart.dropShadow, t)
        }
    }, {
        key: "addNormalFilter", value: function (e, t) {
            var i = this.w;
            i.config.chart.dropShadow.enabled && !e.node.classList.contains("apexcharts-marker") && this.dropShadow(e, i.config.chart.dropShadow, t)
        }
    }, {
        key: "addLightenFilter", value: function (e, i, t) {
            var s = this, a = this.w, n = t.intensity;
            e.unfilter(!0), new window.SVG.Filter, e.filter(function (e) {
                var t = a.config.chart.dropShadow;
                (t.enabled ? s.addShadow(e, i, t) : e).componentTransfer({
                    rgb: {
                        type: "linear",
                        slope: 1.5,
                        intercept: n
                    }
                })
            }), e.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(e.filterer.node)
        }
    }, {
        key: "addDarkenFilter", value: function (e, i, t) {
            var s = this, a = this.w, n = t.intensity;
            e.unfilter(!0), new window.SVG.Filter, e.filter(function (e) {
                var t = a.config.chart.dropShadow;
                (t.enabled ? s.addShadow(e, i, t) : e).componentTransfer({rgb: {type: "linear", slope: n}})
            }), e.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(e.filterer.node)
        }
    }, {
        key: "applyFilter", value: function (e, t, i) {
            var s = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : .5;
            switch (i) {
                case"none":
                    this.addNormalFilter(e, t);
                    break;
                case"lighten":
                    this.addLightenFilter(e, t, {intensity: s});
                    break;
                case"darken":
                    this.addDarkenFilter(e, t, {intensity: s})
            }
        }
    }, {
        key: "addShadow", value: function (e, t, i) {
            var s, a = this.w, n = i.blur, r = i.top, o = i.left, l = i.color, i = i.opacity;
            return 0 < (null == (s = a.config.chart.dropShadow.enabledOnSeries) ? void 0 : s.length) && -1 === a.config.chart.dropShadow.enabledOnSeries.indexOf(t) ? e : (s = e.flood(Array.isArray(l) ? l[t] : l, i).composite(e.sourceAlpha, "in").offset(o, r).gaussianBlur(n).merge(e.source), e.blend(e.source, s))
        }
    }, {
        key: "dropShadow", value: function (e, t) {
            var i, s = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, a = t.top, n = t.left,
                r = t.blur, o = t.color, l = t.opacity, t = t.noUserSpaceOnUse, c = this.w;
            return e.unfilter(!0), R.isMsEdge() && "radialBar" === c.config.chart.type || (0 < (null == (i = c.config.chart.dropShadow.enabledOnSeries) ? void 0 : i.length) && -1 === (null == (i = c.config.chart.dropShadow.enabledOnSeries) ? void 0 : i.indexOf(s)) || (o = Array.isArray(o) ? o[s] : o, e.filter(function (e) {
                var t = R.isSafari() || R.isFirefox() || R.isMsEdge() ? e.flood(o, l).composite(e.sourceAlpha, "in").offset(n, a).gaussianBlur(r) : e.flood(o, l).composite(e.sourceAlpha, "in").offset(n, a).gaussianBlur(r).merge(e.source);
                e.blend(e.source, t)
            }), t || e.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(e.filterer.node))), e
        }
    }, {
        key: "setSelectionFilter", value: function (e, t, i) {
            var s = this.w;
            void 0 !== s.globals.selectedDataPoints[t] && -1 < s.globals.selectedDataPoints[t].indexOf(i) && (e.node.setAttribute("selected", !0), "none" !== (i = s.config.states.active.filter)) && this.applyFilter(e, t, i.type, i.value)
        }
    }, {
        key: "_scaleFilterSize", value: function (e) {
            var t, i = {width: "200%", height: "200%", x: "-50%", y: "-50%"};
            for (t in i) i.hasOwnProperty(t) && e.setAttribute(t, i[t])
        }
    }]), ae), Y = (e(se, [{
        key: "roundPathCorners", value: function (e, t) {
            function i(e, t, i) {
                var s = t.x - e.x, a = t.y - e.y, s = Math.sqrt(s * s + a * a);
                return n(e, t, Math.min(1, i / s))
            }

            function n(e, t, i) {
                return {x: e.x + (t.x - e.x) * i, y: e.y + (t.y - e.y) * i}
            }

            function s(e, t) {
                2 < e.length && (e[e.length - 2] = t.x, e[e.length - 1] = t.y)
            }

            function a(e) {
                return {x: parseFloat(e[e.length - 2]), y: parseFloat(e[e.length - 1])}
            }

            var r = (e = -1 < e.indexOf("NaN") ? "" : e).split(/[,\s]/).reduce(function (e, t) {
                var i = t.match("([a-zA-Z])(.+)");
                return i ? (e.push(i[1]), e.push(i[2])) : e.push(t), e
            }, []).reduce(function (e, t) {
                return parseFloat(t) == t && e.length ? e[e.length - 1].push(t) : e.push([t]), e
            }, []), o = [];
            if (1 < r.length) {
                var e = a(r[0]), l = null;
                "Z" == r[r.length - 1][0] && 2 < r[0].length && (l = ["L", e.x, e.y], r[r.length - 1] = l), o.push(r[0]);
                for (var c = 1; c < r.length; c++) {
                    var h, d, u = o[o.length - 1], g = r[c], p = g == l ? r[1] : r[c + 1];
                    p && u && 2 < u.length && "L" == g[0] && 2 < p.length && "L" == p[0] ? (u = a(u), h = a(g), p = a(p), u = i(h, u, t), p = i(h, p, t), s(g, u), g.origPoint = h, o.push(g), u = n(u, h, .5), d = n(h, p, .5), (u = ["C", u.x, u.y, d.x, d.y, p.x, p.y]).origPoint = h, o.push(u)) : o.push(g)
                }
                l && (e = a(o[o.length - 1]), o.push(["Z"]), s(o[0], e))
            } else o = r;
            return o.reduce(function (e, t) {
                return e + t.join(" ") + " "
            }, "")
        }
    }, {
        key: "drawLine", value: function (e, t, i, s) {
            var a = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : "#a8a8a8",
                n = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 0,
                r = 6 < arguments.length && void 0 !== arguments[6] ? arguments[6] : null,
                o = 7 < arguments.length && void 0 !== arguments[7] ? arguments[7] : "butt";
            return this.w.globals.dom.Paper.line().attr({
                x1: e,
                y1: t,
                x2: i,
                y2: s,
                stroke: a,
                "stroke-dasharray": n,
                "stroke-width": r,
                "stroke-linecap": o
            })
        }
    }, {
        key: "drawRect", value: function () {
            var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0,
                t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0,
                i = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0,
                s = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0,
                a = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0,
                n = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : "#fefefe",
                r = 6 < arguments.length && void 0 !== arguments[6] ? arguments[6] : 1,
                o = 7 < arguments.length && void 0 !== arguments[7] ? arguments[7] : null,
                l = 8 < arguments.length && void 0 !== arguments[8] ? arguments[8] : null,
                c = 9 < arguments.length && void 0 !== arguments[9] ? arguments[9] : 0,
                h = this.w.globals.dom.Paper.rect();
            return h.attr({
                x: e,
                y: t,
                width: 0 < i ? i : 0,
                height: 0 < s ? s : 0,
                rx: a,
                ry: a,
                opacity: r,
                "stroke-width": null !== o ? o : 0,
                stroke: null !== l ? l : "none",
                "stroke-dasharray": c
            }), h.node.setAttribute("fill", n), h
        }
    }, {
        key: "drawPolygon", value: function (e) {
            var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "#e1e1e1",
                i = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 1,
                s = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : "none";
            return this.w.globals.dom.Paper.polygon(e).attr({fill: s, stroke: t, "stroke-width": i})
        }
    }, {
        key: "drawCircle", value: function (e) {
            var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : null,
                e = this.w.globals.dom.Paper.circle(2 * (e = e < 0 ? 0 : e));
            return null !== t && e.attr(t), e
        }
    }, {
        key: "drawPath", value: function (e) {
            var t = e.d, t = void 0 === t ? "" : t, i = e.stroke, i = void 0 === i ? "#a8a8a8" : i, s = e.strokeWidth,
                s = void 0 === s ? 1 : s, a = e.fill, n = e.fillOpacity, n = void 0 === n ? 1 : n, r = e.strokeOpacity,
                r = void 0 === r ? 1 : r, o = e.classes, l = e.strokeLinecap, l = void 0 === l ? null : l,
                e = e.strokeDashArray, e = void 0 === e ? 0 : e, c = this.w;
            return null === l && (l = c.config.stroke.lineCap), (-1 < t.indexOf("undefined") || -1 < t.indexOf("NaN")) && (t = "M 0 ".concat(c.globals.gridHeight)), c.globals.dom.Paper.path(t).attr({
                fill: a,
                "fill-opacity": n,
                stroke: i,
                "stroke-opacity": r,
                "stroke-linecap": l,
                "stroke-width": s,
                "stroke-dasharray": e,
                class: o
            })
        }
    }, {
        key: "group", value: function () {
            var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : null,
                t = this.w.globals.dom.Paper.group();
            return null !== e && t.attr(e), t
        }
    }, {
        key: "move", value: function (e, t) {
            return ["M", e, t].join(" ")
        }
    }, {
        key: "line", value: function (e, t) {
            var i = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null, s = null;
            return null === i ? s = [" L", e, t].join(" ") : "H" === i ? s = [" H", e].join(" ") : "V" === i && (s = [" V", t].join(" ")), s
        }
    }, {
        key: "curve", value: function (e, t, i, s, a, n) {
            return ["C", e, t, i, s, a, n].join(" ")
        }
    }, {
        key: "quadraticCurve", value: function (e, t, i, s) {
            return ["Q", e, t, i, s].join(" ")
        }
    }, {
        key: "arc", value: function (e, t, i, s, a, n, r) {
            var o = "A";
            return [o = 7 < arguments.length && void 0 !== arguments[7] && arguments[7] ? "a" : o, e, t, i, s, a, n, r].join(" ")
        }
    }, {
        key: "renderPaths", value: function (e) {
            var t = e.j, i = e.realIndex, s = e.pathFrom, a = e.pathTo, n = e.stroke, r = e.strokeWidth,
                o = e.strokeLinecap, l = e.fill, c = e.animationDelay, h = e.initialSpeed, d = e.dataChangeSpeed,
                u = e.className, g = e.shouldClipToGrid, g = void 0 === g || g, p = e.bindEventsOnPaths,
                p = void 0 === p || p, e = e.drawShadow, e = void 0 === e || e, f = this.w, x = new P(this.ctx),
                m = new A(this.ctx), b = this.w.config.chart.animations.enabled,
                v = b && this.w.config.chart.animations.dynamicAnimation.enabled,
                y = !!(b && !f.globals.resized || v && f.globals.dataChanged && f.globals.shouldAnimate),
                w = (y ? k = s : (k = a, f.globals.animationEnded = !0), f.config.stroke.dashArray),
                w = Array.isArray(w) ? w[i] : f.config.stroke.dashArray, k = this.drawPath({
                    d: k,
                    stroke: n,
                    strokeWidth: r,
                    fill: l,
                    fillOpacity: 1,
                    classes: u,
                    strokeLinecap: o,
                    strokeDashArray: w
                }),
                u = (k.attr("index", i), g && k.attr({"clip-path": "url(#gridRectMask".concat(f.globals.cuid, ")")}), "none" !== f.config.states.normal.filter.type ? x.getDefaultFilter(k, i) : f.config.chart.dropShadow.enabled && e && (n = f.config.chart.dropShadow, x.dropShadow(k, n, i)), p && (k.node.addEventListener("mouseenter", this.pathMouseEnter.bind(this, k)), k.node.addEventListener("mouseleave", this.pathMouseLeave.bind(this, k)), k.node.addEventListener("mousedown", this.pathMouseDown.bind(this, k))), k.attr({
                    pathTo: a,
                    pathFrom: s
                }), {el: k, j: t, realIndex: i, pathFrom: s, pathTo: a, fill: l, strokeWidth: r, delay: c});
            return !b || f.globals.resized || f.globals.dataChanged ? !f.globals.resized && f.globals.dataChanged || m.showDelayedElements() : m.animatePathsGradually(M(M({}, u), {}, {speed: h})), f.globals.dataChanged && v && y && m.animatePathsGradually(M(M({}, u), {}, {speed: d})), k
        }
    }, {
        key: "drawPattern", value: function (t, i, s) {
            var a = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : "#a8a8a8",
                n = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0;
            return this.w.globals.dom.Paper.pattern(i, s, function (e) {
                "horizontalLines" === t ? e.line(0, 0, s, 0).stroke({
                    color: a,
                    width: n + 1
                }) : "verticalLines" === t ? e.line(0, 0, 0, i).stroke({
                    color: a,
                    width: n + 1
                }) : "slantedLines" === t ? e.line(0, 0, i, s).stroke({
                    color: a,
                    width: n
                }) : "squares" === t ? e.rect(i, s).fill("none").stroke({
                    color: a,
                    width: n
                }) : "circles" === t && e.circle(i).fill("none").stroke({color: a, width: n})
            })
        }
    }, {
        key: "drawGradient", value: function (e, t, i, s, a) {
            var n, r = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : null,
                o = 6 < arguments.length && void 0 !== arguments[6] ? arguments[6] : null,
                l = 7 < arguments.length && void 0 !== arguments[7] ? arguments[7] : null,
                c = 8 < arguments.length && void 0 !== arguments[8] ? arguments[8] : 0, h = this.w,
                d = (t.length < 9 && 0 === t.indexOf("#") && (t = R.hexToRgba(t, s)), i.length < 9 && 0 === i.indexOf("#") && (i = R.hexToRgba(i, a)), 0),
                u = 1, g = 1, p = null,
                o = (null !== o && (d = void 0 !== o[0] ? o[0] / 100 : 0, u = void 0 !== o[1] ? o[1] / 100 : 1, g = void 0 !== o[2] ? o[2] / 100 : 1, p = void 0 !== o[3] ? o[3] / 100 : null), !("donut" !== h.config.chart.type && "pie" !== h.config.chart.type && "polarArea" !== h.config.chart.type && "bubble" !== h.config.chart.type)),
                f = null === l || 0 === l.length ? h.globals.dom.Paper.gradient(o ? "radial" : "linear", function (e) {
                    e.at(d, t, s), e.at(u, i, a), e.at(g, i, a), null !== p && e.at(p, t, s)
                }) : h.globals.dom.Paper.gradient(o ? "radial" : "linear", function (t) {
                    (Array.isArray(l[c]) ? l[c] : l).forEach(function (e) {
                        t.at(e.offset / 100, e.color, e.opacity)
                    })
                });
            return o ? (o = h.globals.gridWidth / 2, n = h.globals.gridHeight / 2, "bubble" !== h.config.chart.type ? f.attr({
                gradientUnits: "userSpaceOnUse",
                cx: o,
                cy: n,
                r: r
            }) : f.attr({
                cx: .5,
                cy: .5,
                r: .8,
                fx: .2,
                fy: .2
            })) : "vertical" === e ? f.from(0, 0).to(0, 1) : "diagonal" === e ? f.from(0, 0).to(1, 1) : "horizontal" === e ? f.from(0, 1).to(1, 1) : "diagonal2" === e && f.from(1, 0).to(0, 1), f
        }
    }, {
        key: "getTextBasedOnMaxWidth", value: function (e) {
            var t = e.text, i = e.maxWidth, e = this.getTextRects(t, e.fontSize, e.fontFamily), s = e.width / t.length,
                s = Math.floor(i / s);
            return i < e.width ? t.slice(0, s - 3) + "..." : t
        }
    }, {
        key: "drawText", value: function (e) {
            var i = this, t = e.x, s = e.y, a = e.text, n = e.textAnchor, r = e.foreColor, o = e.opacity,
                l = e.maxWidth, c = e.cssClass, c = void 0 === c ? "" : c, h = e.isPlainText, h = void 0 === h || h,
                d = e.dominantBaseline, d = void 0 === d ? "auto" : d, u = this.w, g = a = void 0 === a ? "" : a,
                n = n || "start",
                p = (r && r.length || (r = u.config.chart.foreColor), (p = e.fontFamily) || u.config.chart.fontFamily),
                f = e.fontWeight || "regular", x = {maxWidth: l, fontSize: e = e.fontSize || "11px", fontFamily: p},
                h = Array.isArray(a) ? u.globals.dom.Paper.text(function (e) {
                    for (var t = 0; t < a.length; t++) g = a[t], l && (g = i.getTextBasedOnMaxWidth(M({text: a[t]}, x))), 0 === t ? e.tspan(g) : e.tspan(g).newLine()
                }) : (l && (g = this.getTextBasedOnMaxWidth(M({text: a}, x))), h ? u.globals.dom.Paper.plain(a) : u.globals.dom.Paper.text(function (e) {
                    return e.tspan(g)
                }));
            return h.attr({
                x: t,
                y: s,
                "text-anchor": n,
                "dominant-baseline": d,
                "font-size": e,
                "font-family": p,
                "font-weight": f,
                fill: r,
                class: "apexcharts-text " + c
            }), h.node.style.fontFamily = p, h.node.style.opacity = o, h
        }
    }, {
        key: "getMarkerPath", value: function (e, t, i, s) {
            var a = "";
            switch (i) {
                case"cross":
                    a = "M ".concat(e - (s /= 1.4), " ").concat(t - s, " L ").concat(e + s, " ").concat(t + s, "  M ").concat(e - s, " ").concat(t + s, " L ").concat(e + s, " ").concat(t - s);
                    break;
                case"plus":
                    a = "M ".concat(e - (s /= 1.12), " ").concat(t, " L ").concat(e + s, " ").concat(t, "  M ").concat(e, " ").concat(t - s, " L ").concat(e, " ").concat(t + s);
                    break;
                case"star":
                case"sparkle":
                    var n = 5;
                    s *= 1.15, "sparkle" === i && (s /= 1.1, n = 4);
                    for (var r = Math.PI / n, o = 0; o <= 2 * n; o++) {
                        var l = o * r, c = o % 2 == 0 ? s : s / 2;
                        a += (0 === o ? "M" : "L") + (e + c * Math.sin(l)) + "," + (t - c * Math.cos(l))
                    }
                    a += "Z";
                    break;
                case"triangle":
                    a = "M ".concat(e, " ").concat(t - s, " \n             L ").concat(e + s, " ").concat(t + s, " \n             L ").concat(e - s, " ").concat(t + s, " \n             Z");
                    break;
                case"square":
                case"rect":
                    a = "M ".concat(e - (s /= 1.125), " ").concat(t - s, " \n           L ").concat(e + s, " ").concat(t - s, " \n           L ").concat(e + s, " ").concat(t + s, " \n           L ").concat(e - s, " ").concat(t + s, " \n           Z");
                    break;
                case"diamond":
                    s *= 1.05, a = "M ".concat(e, " ").concat(t - s, " \n             L ").concat(e + s, " ").concat(t, " \n             L ").concat(e, " ").concat(t + s, " \n             L ").concat(e - s, " ").concat(t, " \n            Z");
                    break;
                case"line":
                    a = "M ".concat(e - (s /= 1.1), " ").concat(t, " \n           L ").concat(e + s, " ").concat(t);
                    break;
                default:
                    s *= 2, a = "M ".concat(e, ", ").concat(t, " \n           m -").concat(s / 2, ", 0 \n           a ").concat(s / 2, ",").concat(s / 2, " 0 1,0 ").concat(s, ",0 \n           a ").concat(s / 2, ",").concat(s / 2, " 0 1,0 -").concat(s, ",0")
            }
            return a
        }
    }, {
        key: "drawMarkerShape", value: function (e, t, i, s, a) {
            i = this.drawPath({
                d: this.getMarkerPath(e, t, i, s, a),
                stroke: a.pointStrokeColor,
                strokeDashArray: a.pointStrokeDashArray,
                strokeWidth: a.pointStrokeWidth,
                fill: a.pointFillColor,
                fillOpacity: a.pointFillOpacity,
                strokeOpacity: a.pointStrokeOpacity
            });
            return i.attr({cx: e, cy: t, shape: a.shape, class: a.class || ""}), i
        }
    }, {
        key: "drawMarker", value: function (e, t, i) {
            e = e || 0;
            var s = i.pSize || 0;
            return R.isNumber(t) || (t = s = 0), this.drawMarkerShape(e, t, null == i ? void 0 : i.shape, s, M(M({}, i), "line" === i.shape || "plus" === i.shape || "cross" === i.shape ? {
                pointStrokeColor: i.pointFillColor,
                pointStrokeOpacity: i.pointFillOpacity
            } : {}))
        }
    }, {
        key: "pathMouseEnter", value: function (e, t) {
            var i = this.w, s = new P(this.ctx), a = parseInt(e.node.getAttribute("index"), 10),
                n = parseInt(e.node.getAttribute("j"), 10);
            "function" == typeof i.config.chart.events.dataPointMouseEnter && i.config.chart.events.dataPointMouseEnter(t, this.ctx, {
                seriesIndex: a,
                dataPointIndex: n,
                w: i
            }), this.ctx.events.fireEvent("dataPointMouseEnter", [t, this.ctx, {
                seriesIndex: a,
                dataPointIndex: n,
                w: i
            }]), "none" !== i.config.states.active.filter.type && "true" === e.node.getAttribute("selected") || "none" === i.config.states.hover.filter.type || i.globals.isTouchDevice || (t = i.config.states.hover.filter, s.applyFilter(e, a, t.type, t.value))
        }
    }, {
        key: "pathMouseLeave", value: function (e, t) {
            var i = this.w, s = new P(this.ctx), a = parseInt(e.node.getAttribute("index"), 10),
                n = parseInt(e.node.getAttribute("j"), 10);
            "function" == typeof i.config.chart.events.dataPointMouseLeave && i.config.chart.events.dataPointMouseLeave(t, this.ctx, {
                seriesIndex: a,
                dataPointIndex: n,
                w: i
            }), this.ctx.events.fireEvent("dataPointMouseLeave", [t, this.ctx, {
                seriesIndex: a,
                dataPointIndex: n,
                w: i
            }]), "none" !== i.config.states.active.filter.type && "true" === e.node.getAttribute("selected") || "none" !== i.config.states.hover.filter.type && s.getDefaultFilter(e, a)
        }
    }, {
        key: "pathMouseDown", value: function (e, t) {
            var i, s, a, n, r = this.w, o = new P(this.ctx), l = parseInt(e.node.getAttribute("index"), 10),
                c = parseInt(e.node.getAttribute("j"), 10), h = "false";
            "true" === e.node.getAttribute("selected") ? (e.node.setAttribute("selected", "false"), -1 < r.globals.selectedDataPoints[l].indexOf(c) && (a = r.globals.selectedDataPoints[l].indexOf(c), r.globals.selectedDataPoints[l].splice(a, 1))) : (!r.config.states.active.allowMultipleDataPointsSelection && 0 < r.globals.selectedDataPoints.length && (r.globals.selectedDataPoints = [], a = r.globals.dom.Paper.select(".apexcharts-series path").members, i = r.globals.dom.Paper.select(".apexcharts-series circle, .apexcharts-series rect").members, (s = function (e) {
                Array.prototype.forEach.call(e, function (e) {
                    e.node.setAttribute("selected", "false"), o.getDefaultFilter(e, l)
                })
            })(a), s(i)), e.node.setAttribute("selected", "true"), h = "true", void 0 === r.globals.selectedDataPoints[l] && (r.globals.selectedDataPoints[l] = []), r.globals.selectedDataPoints[l].push(c)), "true" === h ? "none" !== (a = r.config.states.active.filter) ? o.applyFilter(e, l, a.type, a.value) : "none" === r.config.states.hover.filter || r.globals.isTouchDevice || (n = r.config.states.hover.filter, o.applyFilter(e, l, n.type, n.value)) : "none" !== r.config.states.active.filter.type && ("none" === r.config.states.hover.filter.type || r.globals.isTouchDevice ? o.getDefaultFilter(e, l) : (n = r.config.states.hover.filter, o.applyFilter(e, l, n.type, n.value))), "function" == typeof r.config.chart.events.dataPointSelection && r.config.chart.events.dataPointSelection(t, this.ctx, {
                selectedDataPoints: r.globals.selectedDataPoints,
                seriesIndex: l,
                dataPointIndex: c,
                w: r
            }), t && this.ctx.events.fireEvent("dataPointSelection", [t, this.ctx, {
                selectedDataPoints: r.globals.selectedDataPoints,
                seriesIndex: l,
                dataPointIndex: c,
                w: r
            }])
        }
    }, {
        key: "rotateAroundCenter", value: function (e) {
            var t = {};
            return {
                x: (t = e && "function" == typeof e.getBBox ? e.getBBox() : t).x + t.width / 2,
                y: t.y + t.height / 2
            }
        }
    }, {
        key: "getTextRects", value: function (e, t, i, s) {
            var a = !(4 < arguments.length && void 0 !== arguments[4]) || arguments[4], n = this.w, e = this.drawText({
                x: -200,
                y: -200,
                text: e,
                textAnchor: "start",
                fontSize: t,
                fontFamily: i,
                foreColor: "#fff",
                opacity: 0
            }), t = (s && e.attr("transform", s), n.globals.dom.Paper.add(e), e.bbox());
            return a || (t = e.node.getBoundingClientRect()), e.remove(), {width: t.width, height: t.height}
        }
    }, {
        key: "placeTextWithEllipsis", value: function (e, t, i) {
            if ("function" == typeof e.getComputedTextLength && 0 < (e.textContent = t).length && e.getComputedTextLength() >= i / 1.1) {
                for (var s = t.length - 3; 0 < s; s -= 3) if (e.getSubStringLength(0, s) <= i / 1.1) return void (e.textContent = t.substring(0, s) + "...");
                e.textContent = "."
            }
        }
    }], [{
        key: "setAttrs", value: function (e, t) {
            for (var i in t) t.hasOwnProperty(i) && e.setAttribute(i, t[i])
        }
    }]), se), I = (e(ie, [{
        key: "getStackedSeriesTotals", value: function () {
            var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : [], t = this.w, i = [];
            if (0 !== t.globals.series.length) for (var s = 0; s < t.globals.series[t.globals.maxValsInArrayIndex].length; s++) {
                for (var a = 0, n = 0; n < t.globals.series.length; n++) void 0 !== t.globals.series[n][s] && -1 === e.indexOf(n) && (a += t.globals.series[n][s]);
                i.push(a)
            }
            return i
        }
    }, {
        key: "getSeriesTotalByIndex", value: function () {
            var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : null;
            return null === e ? this.w.config.series.reduce(function (e, t) {
                return e + t
            }, 0) : this.w.globals.series[e].reduce(function (e, t) {
                return e + t
            }, 0)
        }
    }, {
        key: "getStackedSeriesTotalsByGroups", value: function () {
            var t = this, a = this.w, n = [];
            return a.globals.seriesGroups.forEach(function (i) {
                var s = [], e = (a.config.series.forEach(function (e, t) {
                    -1 < i.indexOf(a.globals.seriesNames[t]) && s.push(t)
                }), a.globals.series.map(function (e, t) {
                    return -1 === s.indexOf(t) ? t : -1
                }).filter(function (e) {
                    return -1 !== e
                }));
                n.push(t.getStackedSeriesTotals(e))
            }), n
        }
    }, {
        key: "setSeriesYAxisMappings", value: function () {
            var e = this.w.globals, i = this.w.config, r = [], s = [], o = [],
                l = e.series.length > i.yaxis.length || i.yaxis.some(function (e) {
                    return Array.isArray(e.seriesName)
                }), c = (i.series.forEach(function (e, t) {
                    o.push(t), s.push(null)
                }), i.yaxis.forEach(function (e, t) {
                    r[t] = []
                }), []);
            i.yaxis.forEach(function (e, a) {
                var t, n = !1;
                e.seriesName && (t = [], Array.isArray(e.seriesName) ? t = e.seriesName : t.push(e.seriesName), t.forEach(function (s) {
                    i.series.forEach(function (e, t) {
                        var i;
                        e.name === s && (a === (i = t) || l ? !l || -1 < o.indexOf(t) ? r[a].push([a, t]) : console.warn("Series '" + e.name + "' referenced more than once in what looks like the new style. That is, when using either seriesName: [], or when there are more series than yaxes.") : (r[t].push([t, a]), i = a), n = !0, -1 !== (i = o.indexOf(i))) && o.splice(i, 1)
                    })
                })), n || c.push(a)
            });
            for (var r = r.map(function (e, t) {
                var i = [];
                return e.forEach(function (e) {
                    s[e[1]] = e[0], i.push(e[1])
                }), i
            }), t = i.yaxis.length - 1, a = 0; a < c.length && (r[t = c[a]] = [], o); a++) {
                var n = o[0];
                o.shift(), r[t].push(n), s[n] = t
            }
            o.forEach(function (e) {
                r[t].push(e), s[e] = t
            }), e.seriesYAxisMap = r.map(function (e) {
                return e
            }), e.seriesYAxisReverseMap = s.map(function (e) {
                return e
            }), e.seriesYAxisMap.forEach(function (e, t) {
                e.forEach(function (e) {
                    i.series[e] && void 0 === i.series[e].group && (i.series[e].group = "apexcharts-axis-".concat(t.toString()))
                })
            })
        }
    }, {
        key: "isSeriesNull", value: function () {
            var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : null;
            return 0 === (null === e ? this.w.config.series.filter(function (e) {
                return null !== e
            }) : this.w.config.series[e].data.filter(function (e) {
                return null !== e
            })).length
        }
    }, {
        key: "seriesHaveSameValues", value: function (e) {
            return this.w.globals.series[e].every(function (e, t, i) {
                return e === i[0]
            })
        }
    }, {
        key: "getCategoryLabels", value: function (e) {
            var i = this.w, t = e.slice();
            return t = i.config.xaxis.convertedCatToNumeric ? e.map(function (e, t) {
                return i.config.xaxis.labels.formatter(e - i.globals.minX + 1)
            }) : t
        }
    }, {
        key: "getLargestSeries", value: function () {
            var e = this.w;
            e.globals.maxValsInArrayIndex = e.globals.series.map(function (e) {
                return e.length
            }).indexOf(Math.max.apply(Math, e.globals.series.map(function (e) {
                return e.length
            })))
        }
    }, {
        key: "getLargestMarkerSize", value: function () {
            var e = this.w, t = 0;
            return e.globals.markers.size.forEach(function (e) {
                t = Math.max(t, e)
            }), e.config.markers.discrete && e.config.markers.discrete.length && e.config.markers.discrete.forEach(function (e) {
                t = Math.max(t, e.size)
            }), 0 < t && (t += e.config.markers.hover.sizeOffset + 1), e.globals.markers.largestSize = t
        }
    }, {
        key: "getSeriesTotals", value: function () {
            var e = this.w;
            e.globals.seriesTotals = e.globals.series.map(function (e, t) {
                var i = 0;
                if (Array.isArray(e)) for (var s = 0; s < e.length; s++) i += e[s]; else i += e;
                return i
            })
        }
    }, {
        key: "getSeriesTotalsXRange", value: function (a, n) {
            var r = this.w;
            return r.globals.series.map(function (e, t) {
                for (var i = 0, s = 0; s < e.length; s++) r.globals.seriesX[t][s] > a && r.globals.seriesX[t][s] < n && (i += e[s]);
                return i
            })
        }
    }, {
        key: "getPercentSeries", value: function () {
            var o = this.w;
            o.globals.seriesPercent = o.globals.series.map(function (e, t) {
                var i = [];
                if (Array.isArray(e)) for (var s = 0; s < e.length; s++) {
                    var a = o.globals.stackedSeriesTotals[s], n = 0;
                    a && (n = 100 * e[s] / a), i.push(n)
                } else {
                    var r = 100 * e / o.globals.seriesTotals.reduce(function (e, t) {
                        return e + t
                    }, 0);
                    i.push(r)
                }
                return i
            })
        }
    }, {
        key: "getCalculatedRatios", value: function () {
            var e, t, i, a = this, n = this.w, s = n.globals, r = [], o = 0, l = [], c = .1, h = 0;
            if (s.yRange = [], s.isMultipleYAxis) for (var d = 0; d < s.minYArr.length; d++) s.yRange.push(Math.abs(s.minYArr[d] - s.maxYArr[d])), l.push(0); else s.yRange.push(Math.abs(s.minY - s.maxY));
            s.xRange = Math.abs(s.maxX - s.minX), s.zRange = Math.abs(s.maxZ - s.minZ);
            for (var u = 0; u < s.yRange.length; u++) r.push(s.yRange[u] / s.gridHeight);
            if (t = s.xRange / s.gridWidth, e = s.yRange / s.gridWidth, i = s.xRange / s.gridHeight, o = (o = s.zRange / s.gridHeight * 16) || 1, s.minY !== Number.MIN_VALUE && 0 !== Math.abs(s.minY) && (s.hasNegs = !0), 0 < n.globals.seriesYAxisReverseMap.length) {
                var g = function (e, t) {
                    var i = n.config.yaxis[n.globals.seriesYAxisReverseMap[t]], s = e < 0 ? -1 : 1;
                    return e = Math.abs(e), -s * (e = i.logarithmic ? a.getBaseLog(i.logBase, e) : e) / r[t]
                };
                if (s.isMultipleYAxis) for (var l = [], p = 0; p < r.length; p++) l.push(g(s.minYArr[p], p)); else (l = []).push(g(s.minY, 0)), s.minY !== Number.MIN_VALUE && 0 !== Math.abs(s.minY) && (c = -s.minY / e, h = s.minX / t)
            } else (l = []).push(0), h = c = 0;
            return {
                yRatio: r,
                invertedYRatio: e,
                zRatio: o,
                xRatio: t,
                invertedXRatio: i,
                baseLineInvertedY: c,
                baseLineY: l,
                baseLineX: h
            }
        }
    }, {
        key: "getLogSeries", value: function (e) {
            var s = this, a = this.w;
            return a.globals.seriesLog = e.map(function (e, t) {
                var i = a.globals.seriesYAxisReverseMap[t];
                return a.config.yaxis[i] && a.config.yaxis[i].logarithmic ? e.map(function (e) {
                    return null === e ? null : s.getLogVal(a.config.yaxis[i].logBase, e, t)
                }) : e
            }), a.globals.invalidLogScale ? e : a.globals.seriesLog
        }
    }, {
        key: "getBaseLog", value: function (e, t) {
            return Math.log(t) / Math.log(e)
        }
    }, {
        key: "getLogVal", value: function (e, t, i) {
            var s, a;
            return t <= 0 ? 0 : (s = 0 === (a = this.w).globals.minYArr[i] ? -1 : this.getBaseLog(e, a.globals.minYArr[i]), a = (0 === a.globals.maxYArr[i] ? 0 : this.getBaseLog(e, a.globals.maxYArr[i])) - s, t < 1 ? t / a : (this.getBaseLog(e, t) - s) / a)
        }
    }, {
        key: "getLogYRatios", value: function (e) {
            var n = this, r = this.w, o = this.w.globals;
            return o.yLogRatio = e.slice(), o.logYRange = o.yRange.map(function (e, t) {
                var i, s, a = r.globals.seriesYAxisReverseMap[t];
                if (r.config.yaxis[a] && n.w.config.yaxis[a].logarithmic) return i = -Number.MAX_VALUE, s = Number.MIN_VALUE, o.seriesLog.forEach(function (e, t) {
                    e.forEach(function (e) {
                        r.config.yaxis[t] && r.config.yaxis[t].logarithmic && (i = Math.max(e, i), s = Math.min(e, s))
                    })
                }), a = Math.pow(o.yRange[t], Math.abs(s - i) / o.yRange[t]), o.yLogRatio[t] = a / o.gridHeight, a
            }), o.invalidLogScale ? e.slice() : o.yLogRatio
        }
    }, {
        key: "drawSeriesByGroup", value: function (n, e, t, r) {
            var o = this.w, l = [];
            return 0 < n.series.length && e.forEach(function (i) {
                var s = [], a = [];
                n.i.forEach(function (e, t) {
                    o.config.series[e].group === i && (s.push(n.series[t]), a.push(e))
                }), 0 < s.length && l.push(r.draw(s, t, a))
            }), l
        }
    }], [{
        key: "checkComboSeries", value: function (e, t) {
            var i = !1, s = 0, a = 0;
            return void 0 === t && (t = "line"), e.length && void 0 !== e[0].type && e.forEach(function (e) {
                "bar" !== e.type && "column" !== e.type && "candlestick" !== e.type && "boxPlot" !== e.type || s++, void 0 !== e.type && e.type !== t && a++
            }), {comboBarCount: s, comboCharts: i = 0 < a ? !0 : i}
        }
    }, {
        key: "extendArrayProps", value: function (e, t, i) {
            var s;
            return t = null != (s = t = null != (s = t) && s.yaxis ? e.extendYAxis(t, i) : t) && s.annotations && null != (i = t = null != (i = t = t.annotations.yaxis ? e.extendYAxisAnnotations(t) : t) && null != (s = i.annotations) && s.xaxis ? e.extendXAxisAnnotations(t) : t) && null != (s = i.annotations) && s.points ? e.extendPointAnnotations(t) : t
        }
    }]), ie), a = (e(te, [{
        key: "setOrientations", value: function (e) {
            var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : null, i = this.w;
            "vertical" === e.label.orientation && null !== (i = i.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(null !== t ? t : 0, "']"))) && (t = i.getBoundingClientRect(), i.setAttribute("x", parseFloat(i.getAttribute("x")) - t.height + 4), "top" === e.label.position ? i.setAttribute("y", parseFloat(i.getAttribute("y")) + t.width) : i.setAttribute("y", parseFloat(i.getAttribute("y")) - t.width), t = (e = this.annoCtx.graphics.rotateAroundCenter(i)).x, e = e.y, i.setAttribute("transform", "rotate(-90 ".concat(t, " ").concat(e, ")")))
        }
    }, {
        key: "addBackgroundToAnno", value: function (e, t) {
            var i, s, a, n, r, o, l = this.w;
            return !e || void 0 === t.label.text || void 0 !== t.label.text && !String(t.label.text).trim() ? null : (r = l.globals.dom.baseEl.querySelector(".apexcharts-grid").getBoundingClientRect(), e = e.getBoundingClientRect(), i = t.label.style.padding.left, s = t.label.style.padding.right, a = t.label.style.padding.top, n = t.label.style.padding.bottom, "vertical" === t.label.orientation && (a = t.label.style.padding.left, n = t.label.style.padding.right, i = t.label.style.padding.top, s = t.label.style.padding.bottom), o = e.left - r.left - i, r = e.top - r.top - a, o = this.annoCtx.graphics.drawRect(o - l.globals.barPadForNumericAxis, r, e.width + i + s, e.height + a + n, t.label.borderRadius, t.label.style.background, 1, t.label.borderWidth, t.label.borderColor, 0), t.id && o.node.classList.add(t.id), o)
        }
    }, {
        key: "annotationsBackground", value: function () {
            function i(e, t, i) {
                var s;
                (i = n.globals.dom.baseEl.querySelector(".apexcharts-".concat(i, "-annotations .apexcharts-").concat(i, "-annotation-label[rel='").concat(t, "']"))) && (t = i.parentNode, s = a.addBackgroundToAnno(i, e)) && (t.insertBefore(s.node, i), e.label.mouseEnter && s.node.addEventListener("mouseenter", e.label.mouseEnter.bind(a, e)), e.label.mouseLeave && s.node.addEventListener("mouseleave", e.label.mouseLeave.bind(a, e)), e.label.click) && s.node.addEventListener("click", e.label.click.bind(a, e))
            }

            var a = this, n = this.w;
            n.config.annotations.xaxis.map(function (e, t) {
                i(e, t, "xaxis")
            }), n.config.annotations.yaxis.map(function (e, t) {
                i(e, t, "yaxis")
            }), n.config.annotations.points.map(function (e, t) {
                i(e, t, "point")
            })
        }
    }, {
        key: "getY1Y2", value: function (e, t) {
            var i, s, a, e = "y1" === e ? t.y : t.y2, n = !1, r = this.w;
            return this.annoCtx.invertAxis ? (s = r.globals.labels, a = (s = r.config.xaxis.convertedCatToNumeric ? r.globals.categoryLabels : s).indexOf(e), i = (i = r.globals.dom.baseEl.querySelector(".apexcharts-yaxis-texts-g text:nth-child(" + (a + 1) + ")")) ? parseFloat(i.getAttribute("y")) : (r.globals.gridHeight / s.length - 1) * (a + 1) - r.globals.barHeight, void 0 !== t.seriesIndex && r.globals.barHeight && (i = i - r.globals.barHeight / 2 * (r.globals.series.length - 1) + r.globals.barHeight * t.seriesIndex)) : (s = r.globals.seriesYAxisMap[t.yAxisIndex][0], (a = r.config.yaxis[t.yAxisIndex].logarithmic ? (e = new I(this.annoCtx.ctx).getLogVal(r.config.yaxis[t.yAxisIndex].logBase, e, s)) / r.globals.yLogRatio[s] : (e - r.globals.minYArr[s]) / (r.globals.yRange[s] / r.globals.gridHeight)) > r.globals.gridHeight ? (a = r.globals.gridHeight, n = !0) : a < 0 && (n = !(a = 0)), i = r.globals.gridHeight - a, t.marker && null == t.y && (i = 0), r.config.yaxis[t.yAxisIndex] && r.config.yaxis[t.yAxisIndex].reversed && (i = a)), {
                yP: i = "string" == typeof e && -1 < e.indexOf("px") ? parseFloat(e) : i,
                clipped: n
            }
        }
    }, {
        key: "getX1X2", value: function (e, t) {
            var e = "x1" === e ? t.x : t.x2, i = this.w, s = this.annoCtx.invertAxis ? i.globals.minY : i.globals.minX,
                a = this.annoCtx.invertAxis ? i.globals.maxY : i.globals.maxX,
                n = this.annoCtx.invertAxis ? i.globals.yRange[0] : i.globals.xRange, r = !1,
                a = this.annoCtx.inversedReversedAxis ? (a - e) / (n / i.globals.gridWidth) : (e - s) / (n / i.globals.gridWidth);
            return "category" !== i.config.xaxis.type && !i.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || i.globals.dataFormatXNumeric || i.config.chart.sparkline.enabled || (a = this.getStringX(e)), "string" == typeof e && -1 < e.indexOf("px") && (a = parseFloat(e)), null == e && t.marker && (a = i.globals.gridWidth), (a = void 0 !== t.seriesIndex && i.globals.barWidth && !this.annoCtx.invertAxis ? a - i.globals.barWidth / 2 * (i.globals.series.length - 1) + i.globals.barWidth * t.seriesIndex : a) > i.globals.gridWidth ? (a = i.globals.gridWidth, r = !0) : a < 0 && (r = !(a = 0)), {
                x: a,
                clipped: r
            }
        }
    }, {
        key: "getStringX", value: function (e) {
            var t = this.w, i = e,
                e = (t.config.xaxis.convertedCatToNumeric && t.globals.categoryLabels.length && (e = t.globals.categoryLabels.indexOf(e) + 1), t.globals.labels.indexOf(e)),
                t = t.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child(" + (e + 1) + ")");
            return i = t ? parseFloat(t.getAttribute("x")) : i
        }
    }]), te), V = (e(ee, [{
        key: "addXaxisAnnotation", value: function (e, t, i) {
            var s, a, n = this.w, r = this.helpers.getX1X2("x1", e), o = r.x, r = r.clipped, l = !0, c = e.label.text,
                h = e.strokeDashArray;
            R.isNumber(o) && (null == e.x2 ? r || (a = this.annoCtx.graphics.drawLine(o + e.offsetX, 0 + e.offsetY, o + e.offsetX, n.globals.gridHeight + e.offsetY, e.borderColor, h, e.borderWidth), t.appendChild(a.node), e.id && a.node.classList.add(e.id)) : (s = (a = this.helpers.getX1X2("x2", e)).x, l = a.clipped, r && l || (s < o && (a = o, o = s, s = a), (a = this.annoCtx.graphics.drawRect(o + e.offsetX, 0 + e.offsetY, s - o, n.globals.gridHeight + e.offsetY, 0, e.fillColor, e.opacity, 1, e.borderColor, h)).node.classList.add("apexcharts-annotation-rect"), a.attr("clip-path", "url(#gridRectMask".concat(n.globals.cuid, ")")), t.appendChild(a.node), e.id && a.node.classList.add(e.id))), r && l || (s = this.annoCtx.graphics.getTextRects(c, parseFloat(e.label.style.fontSize)), h = "top" === e.label.position ? 4 : "center" === e.label.position ? n.globals.gridHeight / 2 + ("vertical" === e.label.orientation ? s.width / 2 : 0) : n.globals.gridHeight, (a = this.annoCtx.graphics.drawText({
                x: o + e.label.offsetX,
                y: h + e.label.offsetY - ("vertical" === e.label.orientation ? "top" === e.label.position ? s.width / 2 - 12 : -s.width / 2 : 0),
                text: c,
                textAnchor: e.label.textAnchor,
                fontSize: e.label.style.fontSize,
                fontFamily: e.label.style.fontFamily,
                fontWeight: e.label.style.fontWeight,
                foreColor: e.label.style.color,
                cssClass: "apexcharts-xaxis-annotation-label ".concat(e.label.style.cssClass, " ").concat(e.id || "")
            })).attr({rel: i}), t.appendChild(a.node), this.annoCtx.helpers.setOrientations(e, i)))
        }
    }, {
        key: "drawXAxisAnnotations", value: function () {
            var i = this, e = this.w, s = this.annoCtx.graphics.group({class: "apexcharts-xaxis-annotations"});
            return e.config.annotations.xaxis.map(function (e, t) {
                i.addXaxisAnnotation(e, s.node, t)
            }), s
        }
    }]), ee), y = (e(J, [{
        key: "isValidDate", value: function (e) {
            return "number" != typeof e && !isNaN(this.parseDate(e))
        }
    }, {
        key: "getTimeStamp", value: function (e) {
            return Date.parse(e) ? (this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(e).toISOString().substr(0, 25)) : new Date(e)).getTime() : e
        }
    }, {
        key: "getDate", value: function (e) {
            return this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(e).toUTCString()) : new Date(e)
        }
    }, {
        key: "parseDate", value: function (e) {
            var t = Date.parse(e);
            return isNaN(t) ? (t = Date.parse(e.replace(/-/g, "/").replace(/[a-z]+/gi, " ")), this.getTimeStamp(t)) : this.getTimeStamp(e)
        }
    }, {
        key: "parseDateWithTimezone", value: function (e) {
            return Date.parse(e.replace(/-/g, "/").replace(/[a-z]+/gi, " "))
        }
    }, {
        key: "formatDate", value: function (e, t) {
            var i = this.w.globals.locale, s = this.w.config.xaxis.labels.datetimeUTC, a = ["\0"].concat(C(i.months)),
                n = [""].concat(C(i.shortMonths)), r = [""].concat(C(i.days)), i = [""].concat(C(i.shortDays));

            function o(e, t) {
                var i = e + "";
                for (t = t || 2; i.length < t;) i = "0" + i;
                return i
            }

            var l, c = s ? e.getUTCFullYear() : e.getFullYear(),
                c = (t = (t = (t = t.replace(/(^|[^\\])yyyy+/g, "$1" + c)).replace(/(^|[^\\])yy/g, "$1" + c.toString().substr(2, 2))).replace(/(^|[^\\])y/g, "$1" + c), (s ? e.getUTCMonth() : e.getMonth()) + 1),
                h = (t = (t = (t = (t = t.replace(/(^|[^\\])MMMM+/g, "$1" + a[0])).replace(/(^|[^\\])MMM/g, "$1" + n[0])).replace(/(^|[^\\])MM/g, "$1" + o(c))).replace(/(^|[^\\])M/g, "$1" + c), s ? e.getUTCDate() : e.getDate()),
                h = (t = (t = (t = (t = t.replace(/(^|[^\\])dddd+/g, "$1" + r[0])).replace(/(^|[^\\])ddd/g, "$1" + i[0])).replace(/(^|[^\\])dd/g, "$1" + o(h))).replace(/(^|[^\\])d/g, "$1" + h), s ? e.getUTCHours() : e.getHours()),
                d = 12 < h ? h - 12 : 0 === h ? 12 : h,
                d = (t = (t = (t = (t = t.replace(/(^|[^\\])HH+/g, "$1" + o(h))).replace(/(^|[^\\])H/g, "$1" + h)).replace(/(^|[^\\])hh+/g, "$1" + o(d))).replace(/(^|[^\\])h/g, "$1" + d), s ? e.getUTCMinutes() : e.getMinutes()),
                d = (t = (t = t.replace(/(^|[^\\])mm+/g, "$1" + o(d))).replace(/(^|[^\\])m/g, "$1" + d), s ? e.getUTCSeconds() : e.getSeconds()),
                d = (t = (t = t.replace(/(^|[^\\])ss+/g, "$1" + o(d))).replace(/(^|[^\\])s/g, "$1" + d), s ? e.getUTCMilliseconds() : e.getMilliseconds()),
                h = (t = t.replace(/(^|[^\\])fff+/g, "$1" + o(d, 3)), d = Math.round(d / 10), t = t.replace(/(^|[^\\])ff/g, "$1" + o(d)), d = Math.round(d / 10), h < 12 ? "AM" : "PM"),
                d = (t = (t = (t = t.replace(/(^|[^\\])f/g, "$1" + d)).replace(/(^|[^\\])TT+/g, "$1" + h)).replace(/(^|[^\\])T/g, "$1" + h.charAt(0)), h.toLowerCase()),
                h = (t = (t = t.replace(/(^|[^\\])tt+/g, "$1" + d)).replace(/(^|[^\\])t/g, "$1" + d.charAt(0)), -e.getTimezoneOffset()),
                d = s || !h ? "Z" : 0 < h ? "+" : "-",
                h = (s || (l = (h = Math.abs(h)) % 60, d += o(Math.floor(h / 60)) + ":" + o(l)), t = t.replace(/(^|[^\\])K/g, "$1" + d), (s ? e.getUTCDay() : e.getDay()) + 1);
            return (t = (t = (t = (t = t.replace(new RegExp(r[0], "g"), r[h])).replace(new RegExp(i[0], "g"), i[h])).replace(new RegExp(a[0], "g"), a[c])).replace(new RegExp(n[0], "g"), n[c])).replace(/\\(.)/g, "$1")
        }
    }, {
        key: "getTimeUnitsfromTimestamp", value: function (e, t, i) {
            var s = this.w,
                s = (void 0 !== s.config.xaxis.min && (e = s.config.xaxis.min), void 0 !== s.config.xaxis.max && (t = s.config.xaxis.max), this.getDate(e)),
                e = this.getDate(t), t = this.formatDate(s, "yyyy MM dd HH mm ss fff").split(" "),
                s = this.formatDate(e, "yyyy MM dd HH mm ss fff").split(" ");
            return {
                minMillisecond: parseInt(t[6], 10),
                maxMillisecond: parseInt(s[6], 10),
                minSecond: parseInt(t[5], 10),
                maxSecond: parseInt(s[5], 10),
                minMinute: parseInt(t[4], 10),
                maxMinute: parseInt(s[4], 10),
                minHour: parseInt(t[3], 10),
                maxHour: parseInt(s[3], 10),
                minDate: parseInt(t[2], 10),
                maxDate: parseInt(s[2], 10),
                minMonth: parseInt(t[1], 10) - 1,
                maxMonth: parseInt(s[1], 10) - 1,
                minYear: parseInt(t[0], 10),
                maxYear: parseInt(s[0], 10)
            }
        }
    }, {
        key: "isLeapYear", value: function (e) {
            return e % 4 == 0 && e % 100 != 0 || e % 400 == 0
        }
    }, {
        key: "calculcateLastDaysOfMonth", value: function (e, t, i) {
            return this.determineDaysOfMonths(e, t) - i
        }
    }, {
        key: "determineDaysOfYear", value: function (e) {
            var t = 365;
            return t = this.isLeapYear(e) ? 366 : t
        }
    }, {
        key: "determineRemainingDaysOfYear", value: function (e, t, i) {
            i = this.daysCntOfYear[t] + i;
            return 1 < t && this.isLeapYear() && i++, i
        }
    }, {
        key: "determineDaysOfMonths", value: function (e, t) {
            var i = 30;
            return e = R.monthMod(e), !0 == -1 < this.months30.indexOf(e) ? 2 === e && (i = this.isLeapYear(t) ? 29 : 28) : (this.months31.indexOf(e), i = 31), i
        }
    }]), J), f = (e(K, [{
        key: "xLabelFormat", value: function (e, t, i, s) {
            var a, n = this.w;
            return "datetime" === n.config.xaxis.type && void 0 === n.config.xaxis.labels.formatter && void 0 === n.config.tooltip.x.formatter ? (a = new y(this.ctx)).formatDate(a.getDate(t), n.config.tooltip.x.format) : e(t, i, s)
        }
    }, {
        key: "defaultGeneralFormatter", value: function (e) {
            return Array.isArray(e) ? e.map(function (e) {
                return e
            }) : e
        }
    }, {
        key: "defaultYFormatter", value: function (e, t, i) {
            var s = this.w;
            return e = R.isNumber(e) ? 0 !== s.globals.yValueDecimal ? e.toFixed(void 0 !== t.decimalsInFloat ? t.decimalsInFloat : s.globals.yValueDecimal) : (t = e.toFixed(0), e == t ? t : e.toFixed(1)) : e
        }
    }, {
        key: "setLabelFormatters", value: function () {
            var s = this, a = this.w;
            return a.globals.xaxisTooltipFormatter = function (e) {
                return s.defaultGeneralFormatter(e)
            }, a.globals.ttKeyFormatter = function (e) {
                return s.defaultGeneralFormatter(e)
            }, a.globals.ttZFormatter = function (e) {
                return e
            }, a.globals.legendFormatter = function (e) {
                return s.defaultGeneralFormatter(e)
            }, void 0 !== a.config.xaxis.labels.formatter ? a.globals.xLabelFormatter = a.config.xaxis.labels.formatter : a.globals.xLabelFormatter = function (e) {
                var t;
                return R.isNumber(e) ? a.config.xaxis.convertedCatToNumeric || "numeric" !== a.config.xaxis.type ? a.globals.isBarHorizontal && a.globals.maxY - a.globals.minYArr < 4 ? e.toFixed(1) : e.toFixed(0) : R.isNumber(a.config.xaxis.decimalsInFloat) ? e.toFixed(a.config.xaxis.decimalsInFloat) : 0 < (t = a.globals.maxX - a.globals.minX) && t < 100 ? e.toFixed(1) : e.toFixed(0) : e
            }, "function" == typeof a.config.tooltip.x.formatter ? a.globals.ttKeyFormatter = a.config.tooltip.x.formatter : a.globals.ttKeyFormatter = a.globals.xLabelFormatter, "function" == typeof a.config.xaxis.tooltip.formatter && (a.globals.xaxisTooltipFormatter = a.config.xaxis.tooltip.formatter), !Array.isArray(a.config.tooltip.y) && void 0 === a.config.tooltip.y.formatter || (a.globals.ttVal = a.config.tooltip.y), void 0 !== a.config.tooltip.z.formatter && (a.globals.ttZFormatter = a.config.tooltip.z.formatter), void 0 !== a.config.legend.formatter && (a.globals.legendFormatter = a.config.legend.formatter), a.config.yaxis.forEach(function (t, i) {
                void 0 !== t.labels.formatter ? a.globals.yLabelFormatters[i] = t.labels.formatter : a.globals.yLabelFormatters[i] = function (e) {
                    return a.globals.xyCharts ? Array.isArray(e) ? e.map(function (e) {
                        return s.defaultYFormatter(e, t, i)
                    }) : s.defaultYFormatter(e, t, i) : e
                }
            }), a.globals
        }
    }, {
        key: "heatmapLabelFormatters", value: function () {
            var e, t = this.w;
            "heatmap" === t.config.chart.type && (t.globals.yAxisScale[0].result = t.globals.seriesNames.slice(), e = t.globals.seriesNames.reduce(function (e, t) {
                return e.length > t.length ? e : t
            }, 0), t.globals.yAxisScale[0].niceMax = e, t.globals.yAxisScale[0].niceMin = e)
        }
    }]), K), w = (e(Q, [{
        key: "getLabel", value: function (e, t, i, s) {
            var a, n = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : [],
                r = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : "12px",
                o = !(6 < arguments.length && void 0 !== arguments[6]) || arguments[6], l = this.w,
                c = void 0 === e[s] ? "" : e[s], h = c, d = l.globals.xLabelFormatter,
                u = l.config.xaxis.labels.formatter, g = !1, p = new f(this.ctx),
                d = (o && (h = p.xLabelFormat(d, c, c, {
                    i: s,
                    dateFormatter: new y(this.ctx).formatDate,
                    w: l
                }), void 0 !== u) && (h = u(c, e[s], {
                    i: s,
                    dateFormatter: new y(this.ctx).formatDate,
                    w: l
                })), 0 < t.length ? (p = t[s].unit, a = null, t.forEach(function (e) {
                    "month" === e.unit ? a = "year" : "day" === e.unit ? a = "month" : "hour" === e.unit ? a = "day" : "minute" === e.unit && (a = "hour")
                }), g = a === p, i = t[s].position, h = t[s].value) : "datetime" === l.config.xaxis.type && void 0 === u && (h = ""), void 0 === h && (h = ""), h = Array.isArray(h) ? h : h.toString(), new Y(this.ctx)),
                c = l.globals.rotateXLabels && o ? d.getTextRects(h, parseInt(r, 10), null, "rotate(".concat(l.config.xaxis.labels.rotate, " 0 0)"), !1) : d.getTextRects(h, parseInt(r, 10)),
                e = !l.config.xaxis.labels.showDuplicates && this.ctx.timeScale;
            return {
                x: i,
                text: h = !Array.isArray(h) && ("NaN" === String(h) || 0 <= n.indexOf(h) && e) ? "" : h,
                textRect: c,
                isBold: g
            }
        }
    }, {
        key: "checkLabelBasedOnTickamount", value: function (e, t, i) {
            var s = this.w, a = s.config.xaxis.tickAmount;
            return i < (a = "dataPoints" === a ? Math.round(s.globals.gridWidth / 120) : a) || e % Math.round(i / (a + 1)) == 0 || (t.text = ""), t
        }
    }, {
        key: "checkForOverflowingLabels", value: function (e, t, i, s, a) {
            var n = this.w;
            return 0 === e && n.globals.skipFirstTimelinelabel && (t.text = ""), e === i - 1 && n.globals.skipLastTimelinelabel && (t.text = ""), n.config.xaxis.labels.hideOverlappingLabels && 0 < s.length && (e = a[a.length - 1], t.x < e.textRect.width / (n.globals.rotateXLabels ? Math.abs(n.config.xaxis.labels.rotate) / 12 : 1.01) + e.x) && (t.text = ""), t
        }
    }, {
        key: "checkForReversedLabels", value: function (e, t) {
            var i = this.w;
            return i.config.yaxis[e] && i.config.yaxis[e].reversed && t.reverse(), t
        }
    }, {
        key: "yAxisAllSeriesCollapsed", value: function (e) {
            var t = this.w.globals;
            return !t.seriesYAxisMap[e].some(function (e) {
                return -1 === t.collapsedSeriesIndices.indexOf(e)
            })
        }
    }, {
        key: "translateYAxisIndex", value: function (e) {
            var t = this.w, i = t.globals, t = t.config.yaxis;
            return i.series.length > t.length || t.some(function (e) {
                return Array.isArray(e.seriesName)
            }) ? e : i.seriesYAxisReverseMap[e]
        }
    }, {
        key: "isYAxisHidden", value: function (e) {
            var t, i = this.w, s = i.config.yaxis[e];
            return !(s.show && !this.yAxisAllSeriesCollapsed(e)) || !s.showForNullSeries && (s = i.globals.seriesYAxisMap[e], t = new I(this.ctx), s.every(function (e) {
                return t.isSeriesNull(e)
            }))
        }
    }, {
        key: "getYAxisForeColor", value: function (e, t) {
            var i = this.w;
            return Array.isArray(e) && i.globals.yAxisScale[t] && this.ctx.theme.pushExtraColors(e, i.globals.yAxisScale[t].result.length, !1), e
        }
    }, {
        key: "drawYAxisTicks", value: function (e, t, i, s, a, n, r) {
            var o = this.w, l = new Y(this.ctx), c = o.globals.translateY + o.config.yaxis[a].labels.offsetY;
            if (o.globals.isBarHorizontal ? c = 0 : "heatmap" === o.config.chart.type && (c += n / 2), s.show && 0 < t) {
                !0 === o.config.yaxis[a].opposite && (e += s.width);
                for (var h = t; 0 <= h; h--) {
                    var d = l.drawLine(e + i.offsetX - s.width + s.offsetX, c + s.offsetY, e + i.offsetX + s.offsetX, c + s.offsetY, s.color);
                    r.add(d), c += n
                }
            }
        }
    }]), Q), q = (e($, [{
        key: "addYaxisAnnotation", value: function (e, t, i) {
            var s, a, n = this.w, r = e.strokeDashArray, o = this.helpers.getY1Y2("y1", e), l = o.yP, c = o.clipped,
                h = !1, d = e.label.text;
            null == e.y2 ? c || (h = !0, a = this.annoCtx.graphics.drawLine(0 + e.offsetX, l + e.offsetY, this._getYAxisAnnotationWidth(e), l + e.offsetY, e.borderColor, r, e.borderWidth), t.appendChild(a.node), e.id && a.node.classList.add(e.id)) : (l < (s = (o = this.helpers.getY1Y2("y2", e)).yP) && (a = l, l = s, s = a), c && o.clipped || (h = !0, (a = this.annoCtx.graphics.drawRect(0 + e.offsetX, s + e.offsetY, this._getYAxisAnnotationWidth(e), l - s, 0, e.fillColor, e.opacity, 1, e.borderColor, r)).node.classList.add("apexcharts-annotation-rect"), a.attr("clip-path", "url(#gridRectMask".concat(n.globals.cuid, ")")), t.appendChild(a.node), e.id && a.node.classList.add(e.id))), h && (c = "right" === e.label.position ? n.globals.gridWidth : "center" === e.label.position ? n.globals.gridWidth / 2 : 0, (o = this.annoCtx.graphics.drawText({
                x: c + e.label.offsetX,
                y: (null != s ? s : l) + e.label.offsetY - 3,
                text: d,
                textAnchor: e.label.textAnchor,
                fontSize: e.label.style.fontSize,
                fontFamily: e.label.style.fontFamily,
                fontWeight: e.label.style.fontWeight,
                foreColor: e.label.style.color,
                cssClass: "apexcharts-yaxis-annotation-label ".concat(e.label.style.cssClass, " ").concat(e.id || "")
            })).attr({rel: i}), t.appendChild(o.node))
        }
    }, {
        key: "_getYAxisAnnotationWidth", value: function (e) {
            var t = this.w;
            return t.globals.gridWidth, (-1 < e.width.indexOf("%") ? t.globals.gridWidth * parseInt(e.width, 10) / 100 : parseInt(e.width, 10)) + e.offsetX
        }
    }, {
        key: "drawYAxisAnnotations", value: function () {
            var i = this, e = this.w, s = this.annoCtx.graphics.group({class: "apexcharts-yaxis-annotations"});
            return e.config.annotations.yaxis.forEach(function (e, t) {
                e.yAxisIndex = i.axesUtils.translateYAxisIndex(e.yAxisIndex), i.axesUtils.isYAxisHidden(e.yAxisIndex) && i.axesUtils.yAxisAllSeriesCollapsed(e.yAxisIndex) || i.addYaxisAnnotation(e, s.node, t)
            }), s
        }
    }]), $), U = (e(Z, [{
        key: "addPointAnnotation", value: function (e, t, i) {
            var s, a, n, r;
            -1 < this.w.globals.collapsedSeriesIndices.indexOf(e.seriesIndex) || (s = (n = this.helpers.getX1X2("x1", e)).x, r = n.clipped, a = (n = this.helpers.getY1Y2("y1", e)).yP, n = n.clipped, !R.isNumber(s)) || n || r || (n = {
                pSize: e.marker.size,
                pointStrokeWidth: e.marker.strokeWidth,
                pointFillColor: e.marker.fillColor,
                pointStrokeColor: e.marker.strokeColor,
                shape: e.marker.shape,
                pRadius: e.marker.radius,
                class: "apexcharts-point-annotation-marker ".concat(e.marker.cssClass, " ").concat(e.id || "")
            }, r = this.annoCtx.graphics.drawMarker(s + e.marker.offsetX, a + e.marker.offsetY, n), t.appendChild(r.node), n = e.label.text || "", (n = this.annoCtx.graphics.drawText({
                x: s + e.label.offsetX,
                y: a + e.label.offsetY - e.marker.size - parseFloat(e.label.style.fontSize) / 1.6,
                text: n,
                textAnchor: e.label.textAnchor,
                fontSize: e.label.style.fontSize,
                fontFamily: e.label.style.fontFamily,
                fontWeight: e.label.style.fontWeight,
                foreColor: e.label.style.color,
                cssClass: "apexcharts-point-annotation-label ".concat(e.label.style.cssClass, " ").concat(e.id || "")
            })).attr({rel: i}), t.appendChild(n.node), e.customSVG.SVG && ((i = this.annoCtx.graphics.group({class: "apexcharts-point-annotations-custom-svg " + e.customSVG.cssClass})).attr({transform: "translate(".concat(s + e.customSVG.offsetX, ", ").concat(a + e.customSVG.offsetY, ")")}), i.node.innerHTML = e.customSVG.SVG, t.appendChild(i.node)), e.image.path && (n = e.image.width || 20, t = e.image.height || 20, r = this.annoCtx.addImage({
                x: s + e.image.offsetX - n / 2,
                y: a + e.image.offsetY - t / 2,
                width: n,
                height: t,
                path: e.image.path,
                appendTo: ".apexcharts-point-annotations"
            })), e.mouseEnter && r.node.addEventListener("mouseenter", e.mouseEnter.bind(this, e)), e.mouseLeave && r.node.addEventListener("mouseleave", e.mouseLeave.bind(this, e)), e.click && r.node.addEventListener("click", e.click.bind(this, e)))
        }
    }, {
        key: "drawPointAnnotations", value: function () {
            var i = this, e = this.w, s = this.annoCtx.graphics.group({class: "apexcharts-point-annotations"});
            return e.config.annotations.points.map(function (e, t) {
                i.addPointAnnotation(e, s.node, t)
            }), s
        }
    }]), Z);

    function Z(e) {
        s(this, Z), this.w = e.w, this.annoCtx = e, this.helpers = new a(this.annoCtx)
    }

    function $(e) {
        s(this, $), this.w = e.w, this.annoCtx = e, this.helpers = new a(this.annoCtx), this.axesUtils = new w(this.annoCtx)
    }

    function Q(e) {
        s(this, Q), this.ctx = e, this.w = e.w
    }

    function K(e) {
        s(this, K), this.ctx = e, this.w = e.w, this.tooltipKeyFormat = "dd MMM"
    }

    function J(e) {
        s(this, J), this.ctx = e, this.w = e.w, this.months31 = [1, 3, 5, 7, 8, 10, 12], this.months30 = [2, 4, 6, 9, 11], this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]
    }

    function ee(e) {
        s(this, ee), this.w = e.w, this.annoCtx = e, this.invertAxis = this.annoCtx.invertAxis, this.helpers = new a(this.annoCtx)
    }

    function te(e) {
        s(this, te), this.w = e.w, this.annoCtx = e
    }

    function ie(e) {
        s(this, ie), this.ctx = e, this.w = e.w
    }

    function se(e) {
        s(this, se), this.ctx = e, this.w = e.w
    }

    function ae(e) {
        s(this, ae), this.ctx = e, this.w = e.w
    }

    function ne(e) {
        s(this, ne), this.ctx = e, this.w = e.w, this.setEasingFunctions()
    }

    function n() {
        s(this, n)
    }

    function re(e) {
        var t = e.isTimeline, i = e.ctx, s = e.seriesIndex, a = e.dataPointIndex, n = e.y1, r = e.y2,
            o = (e = e.w).globals.seriesRangeStart[s][a], l = e.globals.seriesRangeEnd[s][a], c = e.globals.labels[a],
            h = e.config.series[s].name || "", d = e.globals.ttKeyFormatter, u = e.config.tooltip.y.title.formatter,
            g = {w: e, seriesIndex: s, dataPointIndex: a, start: o, end: l},
            u = ("function" == typeof u && (h = u(h, g)), null != (u = e.config.series[s].data[a]) && u.x && (c = e.config.series[s].data[a].x), t || "datetime" === e.config.xaxis.type && (c = new f(i).xLabelFormat(e.globals.ttKeyFormatter, c, c, {
                i: void 0,
                dateFormatter: new y(i).formatDate,
                w: e
            })), "function" == typeof d && (c = d(c, g)), Number.isFinite(n) && Number.isFinite(r) && (o = n, l = r), ""),
            a = "", t = e.globals.colors[s];
        return a = void 0 === e.config.tooltip.x.formatter ? "datetime" === e.config.xaxis.type ? (u = (d = new y(i)).formatDate(d.getDate(o), e.config.tooltip.x.format), d.formatDate(d.getDate(l), e.config.tooltip.x.format)) : (u = o, l) : (u = e.config.tooltip.x.formatter(o), e.config.tooltip.x.formatter(l)), {
            start: o,
            end: l,
            startVal: u,
            endVal: a,
            ylabel: c,
            color: t,
            seriesName: h
        }
    }

    function oe(e) {
        var t = e.color, i = e.seriesName, s = e.ylabel, a = e.start, n = e.end, r = e.seriesIndex,
            o = e.dataPointIndex, a = (l = e.ctx.tooltip.tooltipLabels.getFormatters(r)).yLbFormatter(a),
            n = l.yLbFormatter(n), l = l.yLbFormatter(e.w.globals.series[r][o]),
            o = '<span class="value start-value">\n  '.concat(a, '\n  </span> <span class="separator">-</span> <span class="value end-value">\n  ').concat(n, "\n  </span>");
        return '<div class="apexcharts-tooltip-rangebar"><div> <span class="series-name" style="color: ' + t + '">' + (i || "") + '</span></div><div> <span class="category">' + s + ": </span> " + (!e.w.globals.comboCharts || "rangeArea" === e.w.config.series[r].type || "rangeBar" === e.w.config.series[r].type ? o : "<span>".concat(l, "</span>")) + " </div></div>"
    }

    function le(e) {
        for (var t, i, s, a, n = (e => {
            for (var t = [], i = e[0], s = e[1], a = t[0] = ti(i, s), n = 1, r = e.length - 1; n < r; n++) i = s, s = e[n + 1], t[n] = .5 * (a + (a = ti(i, s)));
            return t[n] = a, t
        })(e), r = e.length - 1, o = [], l = 0; l < r; l++) s = ti(e[l], e[l + 1]), Math.abs(s) < 1e-6 ? n[l] = n[l + 1] = 0 : 9 < (a = (t = n[l] / s) * t + (i = n[l + 1] / s) * i) && (a = 3 * s / Math.sqrt(a), n[l] = a * t, n[l + 1] = a * i);
        for (var c = 0; c <= r; c++) a = (e[Math.min(r, c + 1)][0] - e[Math.max(0, c - 1)][0]) / (6 * (1 + n[c] * n[c])), o.push([a || 0, n[c] * a || 0]);
        return o
    }

    var ce, he, de, ue, ge, pe = {
        name: "en",
        options: {
            months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            toolbar: {
                exportToSVG: "Download SVG",
                exportToPNG: "Download PNG",
                exportToCSV: "Download CSV",
                menu: "Menu",
                selection: "Selection",
                selectionZoom: "Selection Zoom",
                zoomIn: "Zoom In",
                zoomOut: "Zoom Out",
                pan: "Panning",
                reset: "Reset Zoom"
            }
        }
    }, d = (e(ei, [{
        key: "init", value: function () {
            return {
                annotations: {
                    yaxis: [this.yAxisAnnotation],
                    xaxis: [this.xAxisAnnotation],
                    points: [this.pointAnnotation],
                    texts: [],
                    images: [],
                    shapes: []
                },
                chart: {
                    animations: {
                        enabled: !0,
                        easing: "easeinout",
                        speed: 800,
                        animateGradually: {delay: 150, enabled: !0},
                        dynamicAnimation: {enabled: !0, speed: 350}
                    },
                    background: "",
                    locales: [pe],
                    defaultLocale: "en",
                    dropShadow: {
                        enabled: !1,
                        enabledOnSeries: void 0,
                        top: 2,
                        left: 2,
                        blur: 4,
                        color: "#000",
                        opacity: .35
                    },
                    events: {
                        animationEnd: void 0,
                        beforeMount: void 0,
                        mounted: void 0,
                        updated: void 0,
                        click: void 0,
                        mouseMove: void 0,
                        mouseLeave: void 0,
                        xAxisLabelClick: void 0,
                        legendClick: void 0,
                        markerClick: void 0,
                        selection: void 0,
                        dataPointSelection: void 0,
                        dataPointMouseEnter: void 0,
                        dataPointMouseLeave: void 0,
                        beforeZoom: void 0,
                        beforeResetZoom: void 0,
                        zoomed: void 0,
                        scrolled: void 0,
                        brushScrolled: void 0
                    },
                    foreColor: "#373d3f",
                    fontFamily: "Helvetica, Arial, sans-serif",
                    height: "auto",
                    parentHeightOffset: 15,
                    redrawOnParentResize: !0,
                    redrawOnWindowResize: !0,
                    id: void 0,
                    group: void 0,
                    nonce: void 0,
                    offsetX: 0,
                    offsetY: 0,
                    selection: {
                        enabled: !1,
                        type: "x",
                        fill: {color: "#24292e", opacity: .1},
                        stroke: {width: 1, color: "#24292e", opacity: .4, dashArray: 3},
                        xaxis: {min: void 0, max: void 0},
                        yaxis: {min: void 0, max: void 0}
                    },
                    sparkline: {enabled: !1},
                    brush: {enabled: !1, autoScaleYaxis: !0, target: void 0, targets: void 0},
                    stacked: !1,
                    stackOnlyBar: !0,
                    stackType: "normal",
                    toolbar: {
                        show: !0,
                        offsetX: 0,
                        offsetY: 0,
                        tools: {
                            download: !0,
                            selection: !0,
                            zoom: !0,
                            zoomin: !0,
                            zoomout: !0,
                            pan: !0,
                            reset: !0,
                            customIcons: []
                        },
                        export: {
                            csv: {
                                filename: void 0,
                                columnDelimiter: ",",
                                headerCategory: "category",
                                headerValue: "value",
                                categoryFormatter: void 0,
                                valueFormatter: void 0
                            }, png: {filename: void 0}, svg: {filename: void 0}, scale: void 0, width: void 0
                        },
                        autoSelected: "zoom"
                    },
                    type: "line",
                    width: "100%",
                    zoom: {
                        enabled: !0,
                        type: "x",
                        autoScaleYaxis: !1,
                        allowMouseWheelZoom: !0,
                        zoomedArea: {
                            fill: {color: "#90CAF9", opacity: .4},
                            stroke: {color: "#0D47A1", opacity: .4, width: 1}
                        }
                    }
                },
                plotOptions: {
                    line: {isSlopeChart: !1},
                    area: {fillTo: "origin"},
                    bar: {
                        horizontal: !1,
                        columnWidth: "70%",
                        barHeight: "70%",
                        distributed: !1,
                        borderRadius: 0,
                        borderRadiusApplication: "around",
                        borderRadiusWhenStacked: "last",
                        rangeBarOverlap: !0,
                        rangeBarGroupRows: !1,
                        hideZeroBarsWhenGrouped: !1,
                        isDumbbell: !1,
                        dumbbellColors: void 0,
                        isFunnel: !1,
                        isFunnel3d: !0,
                        colors: {ranges: [], backgroundBarColors: [], backgroundBarOpacity: 1, backgroundBarRadius: 0},
                        dataLabels: {
                            position: "top",
                            maxItems: 100,
                            hideOverflowingLabels: !0,
                            orientation: "horizontal",
                            total: {
                                enabled: !1,
                                formatter: void 0,
                                offsetX: 0,
                                offsetY: 0,
                                style: {color: "#373d3f", fontSize: "12px", fontFamily: void 0, fontWeight: 600}
                            }
                        }
                    },
                    bubble: {zScaling: !0, minBubbleRadius: void 0, maxBubbleRadius: void 0},
                    candlestick: {colors: {upward: "#00B746", downward: "#EF403C"}, wick: {useFillColor: !0}},
                    boxPlot: {colors: {upper: "#00E396", lower: "#008FFB"}},
                    heatmap: {
                        radius: 2,
                        enableShades: !0,
                        shadeIntensity: .5,
                        reverseNegativeShade: !1,
                        distributed: !1,
                        useFillColorAsStroke: !1,
                        colorScale: {inverse: !1, ranges: [], min: void 0, max: void 0}
                    },
                    treemap: {
                        enableShades: !0,
                        shadeIntensity: .5,
                        distributed: !1,
                        reverseNegativeShade: !1,
                        useFillColorAsStroke: !1,
                        borderRadius: 4,
                        dataLabels: {format: "scale"},
                        colorScale: {inverse: !1, ranges: [], min: void 0, max: void 0}
                    },
                    radialBar: {
                        inverseOrder: !1,
                        startAngle: 0,
                        endAngle: 360,
                        offsetX: 0,
                        offsetY: 0,
                        hollow: {
                            margin: 5,
                            size: "50%",
                            background: "transparent",
                            image: void 0,
                            imageWidth: 150,
                            imageHeight: 150,
                            imageOffsetX: 0,
                            imageOffsetY: 0,
                            imageClipped: !0,
                            position: "front",
                            dropShadow: {enabled: !1, top: 0, left: 0, blur: 3, color: "#000", opacity: .5}
                        },
                        track: {
                            show: !0,
                            startAngle: void 0,
                            endAngle: void 0,
                            background: "#f2f2f2",
                            strokeWidth: "97%",
                            opacity: 1,
                            margin: 5,
                            dropShadow: {enabled: !1, top: 0, left: 0, blur: 3, color: "#000", opacity: .5}
                        },
                        dataLabels: {
                            show: !0,
                            name: {
                                show: !0,
                                fontSize: "16px",
                                fontFamily: void 0,
                                fontWeight: 600,
                                color: void 0,
                                offsetY: 0,
                                formatter: function (e) {
                                    return e
                                }
                            },
                            value: {
                                show: !0,
                                fontSize: "14px",
                                fontFamily: void 0,
                                fontWeight: 400,
                                color: void 0,
                                offsetY: 16,
                                formatter: function (e) {
                                    return e + "%"
                                }
                            },
                            total: {
                                show: !1,
                                label: "Total",
                                fontSize: "16px",
                                fontWeight: 600,
                                fontFamily: void 0,
                                color: void 0,
                                formatter: function (e) {
                                    return e.globals.seriesTotals.reduce(function (e, t) {
                                        return e + t
                                    }, 0) / e.globals.series.length + "%"
                                }
                            }
                        },
                        barLabels: {
                            enabled: !1,
                            offsetX: 0,
                            offsetY: 0,
                            useSeriesColors: !0,
                            fontFamily: void 0,
                            fontWeight: 600,
                            fontSize: "16px",
                            formatter: function (e) {
                                return e
                            },
                            onClick: void 0
                        }
                    },
                    pie: {
                        customScale: 1,
                        offsetX: 0,
                        offsetY: 0,
                        startAngle: 0,
                        endAngle: 360,
                        expandOnClick: !0,
                        dataLabels: {offset: 0, minAngleToShowLabel: 10},
                        donut: {
                            size: "65%",
                            background: "transparent",
                            labels: {
                                show: !1,
                                name: {
                                    show: !0,
                                    fontSize: "16px",
                                    fontFamily: void 0,
                                    fontWeight: 600,
                                    color: void 0,
                                    offsetY: -10,
                                    formatter: function (e) {
                                        return e
                                    }
                                },
                                value: {
                                    show: !0,
                                    fontSize: "20px",
                                    fontFamily: void 0,
                                    fontWeight: 400,
                                    color: void 0,
                                    offsetY: 10,
                                    formatter: function (e) {
                                        return e
                                    }
                                },
                                total: {
                                    show: !1,
                                    showAlways: !1,
                                    label: "Total",
                                    fontSize: "16px",
                                    fontWeight: 400,
                                    fontFamily: void 0,
                                    color: void 0,
                                    formatter: function (e) {
                                        return e.globals.seriesTotals.reduce(function (e, t) {
                                            return e + t
                                        }, 0)
                                    }
                                }
                            }
                        }
                    },
                    polarArea: {
                        rings: {strokeWidth: 1, strokeColor: "#e8e8e8"},
                        spokes: {strokeWidth: 1, connectorColors: "#e8e8e8"}
                    },
                    radar: {
                        size: void 0,
                        offsetX: 0,
                        offsetY: 0,
                        polygons: {
                            strokeWidth: 1,
                            strokeColors: "#e8e8e8",
                            connectorColors: "#e8e8e8",
                            fill: {colors: void 0}
                        }
                    }
                },
                colors: void 0,
                dataLabels: {
                    enabled: !0,
                    enabledOnSeries: void 0,
                    formatter: function (e) {
                        return null !== e ? e : ""
                    },
                    textAnchor: "middle",
                    distributed: !1,
                    offsetX: 0,
                    offsetY: 0,
                    style: {fontSize: "12px", fontFamily: void 0, fontWeight: 600, colors: void 0},
                    background: {
                        enabled: !0,
                        foreColor: "#fff",
                        borderRadius: 2,
                        padding: 4,
                        opacity: .9,
                        borderWidth: 1,
                        borderColor: "#fff",
                        dropShadow: {enabled: !1, top: 1, left: 1, blur: 1, color: "#000", opacity: .45}
                    },
                    dropShadow: {enabled: !1, top: 1, left: 1, blur: 1, color: "#000", opacity: .45}
                },
                fill: {
                    type: "solid",
                    colors: void 0,
                    opacity: .85,
                    gradient: {
                        shade: "dark",
                        type: "horizontal",
                        shadeIntensity: .5,
                        gradientToColors: void 0,
                        inverseColors: !0,
                        opacityFrom: 1,
                        opacityTo: 1,
                        stops: [0, 50, 100],
                        colorStops: []
                    },
                    image: {src: [], width: void 0, height: void 0},
                    pattern: {style: "squares", width: 6, height: 6, strokeWidth: 2}
                },
                forecastDataPoints: {count: 0, fillOpacity: .5, strokeWidth: void 0, dashArray: 4},
                grid: {
                    show: !0,
                    borderColor: "#e0e0e0",
                    strokeDashArray: 0,
                    position: "back",
                    xaxis: {lines: {show: !1}},
                    yaxis: {lines: {show: !0}},
                    row: {colors: void 0, opacity: .5},
                    column: {colors: void 0, opacity: .5},
                    padding: {top: 0, right: 10, bottom: 0, left: 12}
                },
                labels: [],
                legend: {
                    show: !0,
                    showForSingleSeries: !1,
                    showForNullSeries: !0,
                    showForZeroSeries: !0,
                    floating: !1,
                    position: "bottom",
                    horizontalAlign: "center",
                    inverseOrder: !1,
                    fontSize: "12px",
                    fontFamily: void 0,
                    fontWeight: 400,
                    width: void 0,
                    height: void 0,
                    formatter: void 0,
                    tooltipHoverFormatter: void 0,
                    offsetX: -20,
                    offsetY: 4,
                    customLegendItems: [],
                    labels: {colors: void 0, useSeriesColors: !1},
                    markers: {
                        size: 7,
                        fillColors: void 0,
                        strokeWidth: 1,
                        shape: void 0,
                        offsetX: 0,
                        offsetY: 0,
                        customHTML: void 0,
                        onClick: void 0
                    },
                    itemMargin: {horizontal: 5, vertical: 4},
                    onItemClick: {toggleDataSeries: !0},
                    onItemHover: {highlightDataSeries: !0}
                },
                markers: {
                    discrete: [],
                    size: 0,
                    colors: void 0,
                    strokeColors: "#fff",
                    strokeWidth: 2,
                    strokeOpacity: .9,
                    strokeDashArray: 0,
                    fillOpacity: 1,
                    shape: "circle",
                    offsetX: 0,
                    offsetY: 0,
                    showNullDataPoints: !0,
                    onClick: void 0,
                    onDblClick: void 0,
                    hover: {size: void 0, sizeOffset: 3}
                },
                noData: {
                    text: void 0,
                    align: "center",
                    verticalAlign: "middle",
                    offsetX: 0,
                    offsetY: 0,
                    style: {color: void 0, fontSize: "14px", fontFamily: void 0}
                },
                responsive: [],
                series: void 0,
                states: {
                    normal: {filter: {type: "none", value: 0}},
                    hover: {filter: {type: "lighten", value: .1}},
                    active: {allowMultipleDataPointsSelection: !1, filter: {type: "darken", value: .5}}
                },
                title: {
                    text: void 0,
                    align: "left",
                    margin: 5,
                    offsetX: 0,
                    offsetY: 0,
                    floating: !1,
                    style: {fontSize: "14px", fontWeight: 900, fontFamily: void 0, color: void 0}
                },
                subtitle: {
                    text: void 0,
                    align: "left",
                    margin: 5,
                    offsetX: 0,
                    offsetY: 30,
                    floating: !1,
                    style: {fontSize: "12px", fontWeight: 400, fontFamily: void 0, color: void 0}
                },
                stroke: {
                    show: !0,
                    curve: "smooth",
                    lineCap: "butt",
                    width: 2,
                    colors: void 0,
                    dashArray: 0,
                    fill: {
                        type: "solid",
                        colors: void 0,
                        opacity: .85,
                        gradient: {
                            shade: "dark",
                            type: "horizontal",
                            shadeIntensity: .5,
                            gradientToColors: void 0,
                            inverseColors: !0,
                            opacityFrom: 1,
                            opacityTo: 1,
                            stops: [0, 50, 100],
                            colorStops: []
                        }
                    }
                },
                tooltip: {
                    enabled: !0,
                    enabledOnSeries: void 0,
                    shared: !0,
                    hideEmptySeries: !1,
                    followCursor: !1,
                    intersect: !1,
                    inverseOrder: !1,
                    custom: void 0,
                    fillSeriesColor: !1,
                    theme: "light",
                    cssClass: "",
                    style: {fontSize: "12px", fontFamily: void 0},
                    onDatasetHover: {highlightDataSeries: !1},
                    x: {show: !0, format: "dd MMM", formatter: void 0},
                    y: {
                        formatter: void 0, title: {
                            formatter: function (e) {
                                return e ? e + ": " : ""
                            }
                        }
                    },
                    z: {formatter: void 0, title: "Size: "},
                    marker: {show: !0, fillColors: void 0},
                    items: {display: "flex"},
                    fixed: {enabled: !1, position: "topRight", offsetX: 0, offsetY: 0}
                },
                xaxis: {
                    type: "category",
                    categories: [],
                    convertedCatToNumeric: !1,
                    offsetX: 0,
                    offsetY: 0,
                    overwriteCategories: void 0,
                    labels: {
                        show: !0,
                        rotate: -45,
                        rotateAlways: !1,
                        hideOverlappingLabels: !0,
                        trim: !1,
                        minHeight: void 0,
                        maxHeight: 120,
                        showDuplicates: !0,
                        style: {colors: [], fontSize: "12px", fontWeight: 400, fontFamily: void 0, cssClass: ""},
                        offsetX: 0,
                        offsetY: 0,
                        format: void 0,
                        formatter: void 0,
                        datetimeUTC: !0,
                        datetimeFormatter: {
                            year: "yyyy",
                            month: "MMM 'yy",
                            day: "dd MMM",
                            hour: "HH:mm",
                            minute: "HH:mm:ss",
                            second: "HH:mm:ss"
                        }
                    },
                    group: {
                        groups: [],
                        style: {colors: [], fontSize: "12px", fontWeight: 400, fontFamily: void 0, cssClass: ""}
                    },
                    axisBorder: {show: !0, color: "#e0e0e0", width: "100%", height: 1, offsetX: 0, offsetY: 0},
                    axisTicks: {show: !0, color: "#e0e0e0", height: 6, offsetX: 0, offsetY: 0},
                    stepSize: void 0,
                    tickAmount: void 0,
                    tickPlacement: "on",
                    min: void 0,
                    max: void 0,
                    range: void 0,
                    floating: !1,
                    decimalsInFloat: void 0,
                    position: "bottom",
                    title: {
                        text: void 0,
                        offsetX: 0,
                        offsetY: 0,
                        style: {color: void 0, fontSize: "12px", fontWeight: 900, fontFamily: void 0, cssClass: ""}
                    },
                    crosshairs: {
                        show: !0,
                        width: 1,
                        position: "back",
                        opacity: .9,
                        stroke: {color: "#b6b6b6", width: 1, dashArray: 3},
                        fill: {
                            type: "solid",
                            color: "#B1B9C4",
                            gradient: {
                                colorFrom: "#D8E3F0",
                                colorTo: "#BED1E6",
                                stops: [0, 100],
                                opacityFrom: .4,
                                opacityTo: .5
                            }
                        },
                        dropShadow: {enabled: !1, left: 0, top: 0, blur: 1, opacity: .4}
                    },
                    tooltip: {enabled: !0, offsetY: 0, formatter: void 0, style: {fontSize: "12px", fontFamily: void 0}}
                },
                yaxis: this.yAxis,
                theme: {
                    mode: "",
                    palette: "palette1",
                    monochrome: {enabled: !1, color: "#008FFB", shadeTo: "light", shadeIntensity: .65}
                }
            }
        }
    }]), ei), fe = (e(Jt, [{
        key: "drawAxesAnnotations", value: function () {
            var e = this.w;
            if (e.globals.axisCharts) {
                for (var t = this.yAxisAnnotations.drawYAxisAnnotations(), i = this.xAxisAnnotations.drawXAxisAnnotations(), s = this.pointsAnnotations.drawPointAnnotations(), a = e.config.chart.animations.enabled, n = [t, i, s], r = [i.node, t.node, s.node], o = 0; o < 3; o++) e.globals.dom.elGraphical.add(n[o]), !a || e.globals.resized || e.globals.dataChanged || "scatter" !== e.config.chart.type && "bubble" !== e.config.chart.type && 1 < e.globals.dataPoints && r[o].classList.add("apexcharts-element-hidden"), e.globals.delayedElements.push({
                    el: r[o],
                    index: 0
                });
                this.helpers.annotationsBackground()
            }
        }
    }, {
        key: "drawImageAnnos", value: function () {
            var i = this;
            this.w.config.annotations.images.map(function (e, t) {
                i.addImage(e, t)
            })
        }
    }, {
        key: "drawTextAnnos", value: function () {
            var i = this;
            this.w.config.annotations.texts.map(function (e, t) {
                i.addText(e, t)
            })
        }
    }, {
        key: "addXaxisAnnotation", value: function (e, t, i) {
            this.xAxisAnnotations.addXaxisAnnotation(e, t, i)
        }
    }, {
        key: "addYaxisAnnotation", value: function (e, t, i) {
            this.yAxisAnnotations.addYaxisAnnotation(e, t, i)
        }
    }, {
        key: "addPointAnnotation", value: function (e, t, i) {
            this.pointsAnnotations.addPointAnnotation(e, t, i)
        }
    }, {
        key: "addText", value: function (e, t) {
            var i = e.x, s = e.text, a = e.backgroundColor, n = e.borderWidth, r = e.strokeDashArray,
                o = e.borderRadius, l = e.borderColor, c = e.appendTo, c = void 0 === c ? ".apexcharts-svg" : c,
                h = e.paddingLeft, h = void 0 === h ? 4 : h, d = e.paddingRight, d = void 0 === d ? 4 : d,
                u = e.paddingBottom, u = void 0 === u ? 2 : u, g = e.paddingTop, g = void 0 === g ? 2 : g, p = this.w,
                i = this.graphics.drawText({
                    x: i,
                    y: e.y,
                    text: s,
                    textAnchor: e.textAnchor || "start",
                    fontSize: e.fontSize || "12px",
                    fontWeight: e.fontWeight || "regular",
                    fontFamily: e.fontFamily || p.config.chart.fontFamily,
                    foreColor: e.foreColor || p.config.chart.foreColor,
                    cssClass: e.cssClass
                }), e = p.globals.dom.baseEl.querySelector(c), p = (e && e.appendChild(i.node), i.bbox());
            s && (c = this.graphics.drawRect(p.x - h, p.y - g, p.width + h + d, p.height + u + g, o, a || "transparent", 1, n, l, r), e.insertBefore(c.node, i.node))
        }
    }, {
        key: "addImage", value: function (e, t) {
            var i = this.w, s = e.path, a = e.x, a = void 0 === a ? 0 : a, n = e.y, n = void 0 === n ? 0 : n,
                r = e.width, r = void 0 === r ? 20 : r, o = e.height, o = void 0 === o ? 20 : o, e = e.appendTo,
                e = void 0 === e ? ".apexcharts-svg" : e, s = i.globals.dom.Paper.image(s),
                r = (s.size(r, o).move(a, n), i.globals.dom.baseEl.querySelector(e));
            return r && r.appendChild(s.node), s
        }
    }, {
        key: "addXaxisAnnotationExternal", value: function (e, t, i) {
            return this.addAnnotationExternal({
                params: e,
                pushToMemory: t,
                context: i,
                type: "xaxis",
                contextMethod: i.addXaxisAnnotation
            }), i
        }
    }, {
        key: "addYaxisAnnotationExternal", value: function (e, t, i) {
            return this.addAnnotationExternal({
                params: e,
                pushToMemory: t,
                context: i,
                type: "yaxis",
                contextMethod: i.addYaxisAnnotation
            }), i
        }
    }, {
        key: "addPointAnnotationExternal", value: function (e, t, i) {
            return void 0 === this.invertAxis && (this.invertAxis = i.w.globals.isBarHorizontal), this.addAnnotationExternal({
                params: e,
                pushToMemory: t,
                context: i,
                type: "point",
                contextMethod: i.addPointAnnotation
            }), i
        }
    }, {
        key: "addAnnotationExternal", value: function (e) {
            var t = e.params, i = e.pushToMemory, s = e.context, a = e.type, e = e.contextMethod, n = s, r = n.w,
                o = r.globals.dom.baseEl.querySelector(".apexcharts-".concat(a, "-annotations")),
                l = o.childNodes.length + 1, c = new d,
                c = Object.assign({}, "xaxis" === a ? c.xAxisAnnotation : "yaxis" === a ? c.yAxisAnnotation : c.pointAnnotation),
                h = R.extend(c, t);
            switch (a) {
                case"xaxis":
                    this.addXaxisAnnotation(h, o, l);
                    break;
                case"yaxis":
                    this.addYaxisAnnotation(h, o, l);
                    break;
                case"point":
                    this.addPointAnnotation(h, o, l)
            }
            c = r.globals.dom.baseEl.querySelector(".apexcharts-".concat(a, "-annotations .apexcharts-").concat(a, "-annotation-label[rel='").concat(l, "']")), a = this.helpers.addBackgroundToAnno(c, h);
            return a && o.insertBefore(a.node, c), i && r.globals.memory.methodsToExec.push({
                context: n,
                id: h.id || R.randomId(),
                method: e,
                label: "addAnnotation",
                params: t
            }), s
        }
    }, {
        key: "clearAnnotations", value: function (e) {
            for (var t = e.w, e = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations"), i = t.globals.memory.methodsToExec.length - 1; 0 <= i; i--) "addText" !== t.globals.memory.methodsToExec[i].label && "addAnnotation" !== t.globals.memory.methodsToExec[i].label || t.globals.memory.methodsToExec.splice(i, 1);
            e = R.listToArray(e), Array.prototype.forEach.call(e, function (e) {
                for (; e.firstChild;) e.removeChild(e.firstChild)
            })
        }
    }, {
        key: "removeAnnotation", value: function (e, i) {
            var s = e.w, e = s.globals.dom.baseEl.querySelectorAll(".".concat(i));
            e && (s.globals.memory.methodsToExec.map(function (e, t) {
                e.id === i && s.globals.memory.methodsToExec.splice(t, 1)
            }), Array.prototype.forEach.call(e, function (e) {
                e.parentElement.removeChild(e)
            }))
        }
    }]), Jt), o = (e(Kt, [{
        key: "hideYAxis", value: function () {
            this.opts.yaxis[0].show = !1, this.opts.yaxis[0].title.text = "", this.opts.yaxis[0].axisBorder.show = !1, this.opts.yaxis[0].axisTicks.show = !1, this.opts.yaxis[0].floating = !0
        }
    }, {
        key: "line", value: function () {
            return {
                chart: {animations: {easing: "swing"}},
                dataLabels: {enabled: !1},
                stroke: {width: 5, curve: "straight"},
                markers: {size: 0, hover: {sizeOffset: 6}},
                xaxis: {crosshairs: {width: 1}}
            }
        }
    }, {
        key: "sparkline", value: function (e) {
            return this.hideYAxis(), R.extend(e, {
                grid: {show: !1, padding: {left: 0, right: 0, top: 0, bottom: 0}},
                legend: {show: !1},
                xaxis: {labels: {show: !1}, tooltip: {enabled: !1}, axisBorder: {show: !1}, axisTicks: {show: !1}},
                chart: {toolbar: {show: !1}, zoom: {enabled: !1}},
                dataLabels: {enabled: !1}
            })
        }
    }, {
        key: "slope", value: function () {
            return this.hideYAxis(), {
                chart: {toolbar: {show: !1}, zoom: {enabled: !1}},
                dataLabels: {
                    enabled: !0, formatter: function (e, t) {
                        t = t.w.config.series[t.seriesIndex].name;
                        return null !== e ? t + ": " + e : ""
                    }, background: {enabled: !1}, offsetX: -5
                },
                grid: {xaxis: {lines: {show: !0}}, yaxis: {lines: {show: !1}}},
                xaxis: {
                    position: "top",
                    labels: {style: {fontSize: 14, fontWeight: 900}},
                    tooltip: {enabled: !1},
                    crosshairs: {show: !1}
                },
                markers: {size: 8, hover: {sizeOffset: 1}},
                legend: {show: !1},
                tooltip: {shared: !1, intersect: !0, followCursor: !0},
                stroke: {width: 5, curve: "straight"}
            }
        }
    }, {
        key: "bar", value: function () {
            return {
                chart: {stacked: !1, animations: {easing: "swing"}},
                plotOptions: {bar: {dataLabels: {position: "center"}}},
                dataLabels: {style: {colors: ["#fff"]}, background: {enabled: !1}},
                stroke: {width: 0, lineCap: "round"},
                fill: {opacity: .85},
                legend: {markers: {shape: "square"}},
                tooltip: {shared: !1, intersect: !0},
                xaxis: {
                    tooltip: {enabled: !1},
                    tickPlacement: "between",
                    crosshairs: {
                        width: "barWidth",
                        position: "back",
                        fill: {type: "gradient"},
                        dropShadow: {enabled: !1},
                        stroke: {width: 0}
                    }
                }
            }
        }
    }, {
        key: "funnel", value: function () {
            return this.hideYAxis(), M(M({}, this.bar()), {}, {
                chart: {
                    animations: {
                        easing: "linear",
                        speed: 800,
                        animateGradually: {enabled: !1}
                    }
                },
                plotOptions: {
                    bar: {
                        horizontal: !0,
                        borderRadiusApplication: "around",
                        borderRadius: 0,
                        dataLabels: {position: "center"}
                    }
                },
                grid: {show: !1, padding: {left: 0, right: 0}},
                xaxis: {labels: {show: !1}, tooltip: {enabled: !1}, axisBorder: {show: !1}, axisTicks: {show: !1}}
            })
        }
    }, {
        key: "candlestick", value: function () {
            var i = this;
            return {
                stroke: {width: 1, colors: ["#333"]},
                fill: {opacity: 1},
                dataLabels: {enabled: !1},
                tooltip: {
                    shared: !0, custom: function (e) {
                        var t = e.seriesIndex;
                        return i._getBoxTooltip(e.w, t, e.dataPointIndex, ["Open", "High", "", "Low", "Close"], "candlestick")
                    }
                },
                states: {active: {filter: {type: "none"}}},
                xaxis: {crosshairs: {width: 1}}
            }
        }
    }, {
        key: "boxPlot", value: function () {
            var i = this;
            return {
                chart: {animations: {dynamicAnimation: {enabled: !1}}},
                stroke: {width: 1, colors: ["#24292e"]},
                dataLabels: {enabled: !1},
                tooltip: {
                    shared: !0, custom: function (e) {
                        var t = e.seriesIndex;
                        return i._getBoxTooltip(e.w, t, e.dataPointIndex, ["Minimum", "Q1", "Median", "Q3", "Maximum"], "boxPlot")
                    }
                },
                markers: {size: 7, strokeWidth: 1, strokeColors: "#111"},
                xaxis: {crosshairs: {width: 1}}
            }
        }
    }, {
        key: "rangeBar", value: function () {
            return {
                chart: {animations: {animateGradually: !1}},
                stroke: {width: 0, lineCap: "square"},
                plotOptions: {bar: {borderRadius: 0, dataLabels: {position: "center"}}},
                dataLabels: {
                    enabled: !1, formatter: function (e, t) {
                        t.ctx;

                        function i() {
                            var e = n.globals.seriesRangeStart[s][a];
                            return n.globals.seriesRangeEnd[s][a] - e
                        }

                        var s = t.seriesIndex, a = t.dataPointIndex, n = t.w;
                        return !n.globals.comboCharts || "rangeBar" === n.config.series[s].type || "rangeArea" === n.config.series[s].type ? i() : e
                    }, background: {enabled: !1}, style: {colors: ["#fff"]}
                },
                markers: {size: 10},
                tooltip: {
                    shared: !1, followCursor: !0, custom: function (e) {
                        return e.w.config.plotOptions && e.w.config.plotOptions.bar && e.w.config.plotOptions.bar.horizontal ? (i = re(M(M({}, t = e), {}, {isTimeline: !0})), s = i.color, a = i.seriesName, n = i.ylabel, r = i.startVal, i = i.endVal, oe(M(M({}, t), {}, {
                            color: s,
                            seriesName: a,
                            ylabel: n,
                            start: r,
                            end: i
                        }))) : (s = re(t = e), a = s.color, n = s.seriesName, r = s.ylabel, i = s.start, s = s.end, oe(M(M({}, t), {}, {
                            color: a,
                            seriesName: n,
                            ylabel: r,
                            start: i,
                            end: s
                        })));
                        var t, i, s, a, n, r
                    }
                },
                xaxis: {tickPlacement: "between", tooltip: {enabled: !1}, crosshairs: {stroke: {width: 0}}}
            }
        }
    }, {
        key: "dumbbell", value: function (e) {
            var t;
            return null != (t = e.plotOptions.bar) && t.barHeight || (e.plotOptions.bar.barHeight = 2), null != (t = e.plotOptions.bar) && t.columnWidth || (e.plotOptions.bar.columnWidth = 2), e
        }
    }, {
        key: "area", value: function () {
            return {
                stroke: {
                    width: 4,
                    fill: {
                        type: "solid",
                        gradient: {
                            inverseColors: !1,
                            shade: "light",
                            type: "vertical",
                            opacityFrom: .65,
                            opacityTo: .5,
                            stops: [0, 100, 100]
                        }
                    }
                },
                fill: {
                    type: "gradient",
                    gradient: {
                        inverseColors: !1,
                        shade: "light",
                        type: "vertical",
                        opacityFrom: .65,
                        opacityTo: .5,
                        stops: [0, 100, 100]
                    }
                },
                markers: {size: 0, hover: {sizeOffset: 6}},
                tooltip: {followCursor: !1}
            }
        }
    }, {
        key: "rangeArea", value: function () {
            return {
                stroke: {curve: "straight", width: 0},
                fill: {type: "solid", opacity: .6},
                markers: {size: 0},
                states: {hover: {filter: {type: "none"}}, active: {filter: {type: "none"}}},
                tooltip: {
                    intersect: !1, shared: !0, followCursor: !0, custom: function (e) {
                        return t = re(e = e), i = t.color, s = t.seriesName, a = t.ylabel, n = t.start, t = t.end, oe(M(M({}, e), {}, {
                            color: i,
                            seriesName: s,
                            ylabel: a,
                            start: n,
                            end: t
                        }));
                        var t, i, s, a, n
                    }
                }
            }
        }
    }, {
        key: "brush", value: function (e) {
            return R.extend(e, {
                chart: {toolbar: {autoSelected: "selection", show: !1}, zoom: {enabled: !1}},
                dataLabels: {enabled: !1},
                stroke: {width: 1},
                tooltip: {enabled: !1},
                xaxis: {tooltip: {enabled: !1}}
            })
        }
    }, {
        key: "stacked100", value: function (i) {
            i.dataLabels = i.dataLabels || {}, i.dataLabels.formatter = i.dataLabels.formatter || void 0;
            var e = i.dataLabels.formatter;
            return i.yaxis.forEach(function (e, t) {
                i.yaxis[t].min = 0, i.yaxis[t].max = 100
            }), "bar" === i.chart.type && (i.dataLabels.formatter = e || function (e) {
                return "number" == typeof e && e ? e.toFixed(0) + "%" : e
            }), i
        }
    }, {
        key: "stackedBars", value: function () {
            var e = this.bar();
            return M(M({}, e), {}, {
                plotOptions: M(M({}, e.plotOptions), {}, {
                    bar: M(M({}, e.plotOptions.bar), {}, {
                        borderRadiusApplication: "end",
                        borderRadiusWhenStacked: "last"
                    })
                })
            })
        }
    }, {
        key: "convertCatToNumeric", value: function (e) {
            return e.xaxis.convertedCatToNumeric = !0, e
        }
    }, {
        key: "convertCatToNumericXaxis", value: function (e, t, i) {
            e.xaxis.type = "numeric", e.xaxis.labels = e.xaxis.labels || {}, e.xaxis.labels.formatter = e.xaxis.labels.formatter || function (e) {
                return R.isNumber(e) ? Math.floor(e) : e
            };
            var s = e.xaxis.labels.formatter,
                a = e.xaxis.categories && e.xaxis.categories.length ? e.xaxis.categories : e.labels;
            return (a = i && i.length ? i.map(function (e) {
                return Array.isArray(e) ? e : String(e)
            }) : a) && a.length && (e.xaxis.labels.formatter = function (e) {
                return R.isNumber(e) ? s(a[Math.floor(e) - 1]) : s(e)
            }), e.xaxis.categories = [], e.labels = [], e.xaxis.tickAmount = e.xaxis.tickAmount || "dataPoints", e
        }
    }, {
        key: "bubble", value: function () {
            return {
                dataLabels: {style: {colors: ["#fff"]}},
                tooltip: {shared: !1, intersect: !0},
                xaxis: {crosshairs: {width: 0}},
                fill: {
                    type: "solid",
                    gradient: {shade: "light", inverse: !0, shadeIntensity: .55, opacityFrom: .4, opacityTo: .8}
                }
            }
        }
    }, {
        key: "scatter", value: function () {
            return {
                dataLabels: {enabled: !1},
                tooltip: {shared: !1, intersect: !0},
                markers: {size: 6, strokeWidth: 1, hover: {sizeOffset: 2}}
            }
        }
    }, {
        key: "heatmap", value: function () {
            return {
                chart: {stacked: !1},
                fill: {opacity: 1},
                dataLabels: {style: {colors: ["#fff"]}},
                stroke: {colors: ["#fff"]},
                tooltip: {followCursor: !0, marker: {show: !1}, x: {show: !1}},
                legend: {position: "top", markers: {shape: "square"}},
                grid: {padding: {right: 20}}
            }
        }
    }, {
        key: "treemap", value: function () {
            return {
                chart: {zoom: {enabled: !1}},
                dataLabels: {style: {fontSize: 14, fontWeight: 600, colors: ["#fff"]}},
                stroke: {show: !0, width: 2, colors: ["#fff"]},
                legend: {show: !1},
                fill: {opacity: 1, gradient: {stops: [0, 100]}},
                tooltip: {followCursor: !0, x: {show: !1}},
                grid: {padding: {left: 0, right: 0}},
                xaxis: {crosshairs: {show: !1}, tooltip: {enabled: !1}}
            }
        }
    }, {
        key: "pie", value: function () {
            return {
                chart: {toolbar: {show: !1}},
                plotOptions: {pie: {donut: {labels: {show: !1}}}},
                dataLabels: {
                    formatter: function (e) {
                        return e.toFixed(1) + "%"
                    }, style: {colors: ["#fff"]}, background: {enabled: !1}, dropShadow: {enabled: !0}
                },
                stroke: {colors: ["#fff"]},
                fill: {opacity: 1, gradient: {shade: "light", stops: [0, 100]}},
                tooltip: {theme: "dark", fillSeriesColor: !0},
                legend: {position: "right"}
            }
        }
    }, {
        key: "donut", value: function () {
            return {
                chart: {toolbar: {show: !1}},
                dataLabels: {
                    formatter: function (e) {
                        return e.toFixed(1) + "%"
                    }, style: {colors: ["#fff"]}, background: {enabled: !1}, dropShadow: {enabled: !0}
                },
                stroke: {colors: ["#fff"]},
                fill: {
                    opacity: 1,
                    gradient: {shade: "light", shadeIntensity: .35, stops: [80, 100], opacityFrom: 1, opacityTo: 1}
                },
                tooltip: {theme: "dark", fillSeriesColor: !0},
                legend: {position: "right"}
            }
        }
    }, {
        key: "polarArea", value: function () {
            return {
                chart: {toolbar: {show: !1}},
                dataLabels: {
                    formatter: function (e) {
                        return e.toFixed(1) + "%"
                    }, enabled: !1
                },
                stroke: {show: !0, width: 2},
                fill: {opacity: .7},
                tooltip: {theme: "dark", fillSeriesColor: !0},
                legend: {position: "right"}
            }
        }
    }, {
        key: "radar", value: function () {
            return this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY || 6, {
                dataLabels: {
                    enabled: !1,
                    style: {fontSize: "11px"}
                },
                stroke: {width: 2},
                markers: {size: 5, strokeWidth: 1, strokeOpacity: 1},
                fill: {opacity: .2},
                tooltip: {shared: !1, intersect: !0, followCursor: !0},
                grid: {show: !1},
                xaxis: {
                    labels: {
                        formatter: function (e) {
                            return e
                        }, style: {colors: ["#a8a8a8"], fontSize: "11px"}
                    }, tooltip: {enabled: !1}, crosshairs: {show: !1}
                }
            }
        }
    }, {
        key: "radialBar", value: function () {
            return {
                chart: {animations: {dynamicAnimation: {enabled: !0, speed: 800}}, toolbar: {show: !1}},
                fill: {
                    gradient: {
                        shade: "dark",
                        shadeIntensity: .4,
                        inverseColors: !1,
                        type: "diagonal2",
                        opacityFrom: 1,
                        opacityTo: 1,
                        stops: [70, 98, 100]
                    }
                },
                legend: {show: !1, position: "right"},
                tooltip: {enabled: !1, fillSeriesColor: !0}
            }
        }
    }, {
        key: "_getBoxTooltip", value: function (e, t, i, s, a) {
            var n = e.globals.seriesCandleO[t][i], r = e.globals.seriesCandleH[t][i], o = e.globals.seriesCandleM[t][i],
                l = e.globals.seriesCandleL[t][i], c = e.globals.seriesCandleC[t][i];
            return e.config.series[t].type && e.config.series[t].type !== a ? '<div class="apexcharts-custom-tooltip">\n          '.concat(e.config.series[t].name || "series-" + (t + 1), ": <strong>").concat(e.globals.series[t][i], "</strong>\n        </div>") : '<div class="apexcharts-tooltip-box apexcharts-tooltip-'.concat(e.config.chart.type, '">') + "<div>".concat(s[0], ': <span class="value">') + n + "</span></div>" + "<div>".concat(s[1], ': <span class="value">') + r + "</span></div>" + (o ? "<div>".concat(s[2], ': <span class="value">') + o + "</span></div>" : "") + "<div>".concat(s[3], ': <span class="value">') + l + "</span></div>" + "<div>".concat(s[4], ': <span class="value">') + c + "</span></div></div>"
        }
    }]), Kt), p = (e(Qt, [{
        key: "init", value: function (e) {
            var t, i, e = e.responsiveOverride, s = this.opts, a = new d, n = new o(s),
                a = (this.chartType = s.chart.type, s = this.extendYAxis(s), s = this.extendAnnotations(s), a.init()),
                r = {},
                e = (s && "object" === v(s) && (i = {}, i = -1 !== ["line", "area", "bar", "candlestick", "boxPlot", "rangeBar", "rangeArea", "bubble", "scatter", "heatmap", "treemap", "pie", "polarArea", "donut", "radar", "radialBar"].indexOf(s.chart.type) ? n[s.chart.type]() : n.line(), null != (t = s.plotOptions) && null != (t = t.bar) && t.isFunnel && (i = n.funnel()), s.chart.stacked && "bar" === s.chart.type && (i = n.stackedBars()), null != (t = s.chart.brush) && t.enabled && (i = n.brush(i)), null != (t = s.plotOptions) && null != (t = t.line) && t.isSlopeChart && (i = n.slope()), null != (t = (s = s.chart.stacked && "100%" === s.chart.stackType ? n.stacked100(s) : s).plotOptions) && null != (t = t.bar) && t.isDumbbell && (s = n.dumbbell(s)), this.checkForDarkTheme(window.Apex), this.checkForDarkTheme(s), s.xaxis = s.xaxis || window.Apex.xaxis || {}, e || (s.xaxis.convertedCatToNumeric = !1), (null != (t = (s = this.checkForCatToNumericXAxis(this.chartType, i, s)).chart.sparkline) && t.enabled || null != (e = window.Apex.chart) && null != (t = e.sparkline) && t.enabled) && (i = n.sparkline(i)), r = R.extend(a, i)), R.extend(r, window.Apex)),
                a = R.extend(e, s);
            return this.handleUserInputErrors(a)
        }
    }, {
        key: "checkForCatToNumericXAxis", value: function (e, t, i) {
            var s = new o(i),
                a = ("bar" === e || "boxPlot" === e) && (null == (a = i.plotOptions) || null == (a = a.bar) ? void 0 : a.horizontal),
                n = "datetime" !== i.xaxis.type && "numeric" !== i.xaxis.type,
                t = i.xaxis.tickPlacement || t.xaxis && t.xaxis.tickPlacement;
            return i = a || ("pie" === e || "polarArea" === e || "donut" === e || "radar" === e || "radialBar" === e || "heatmap" === e) || !n || "between" === t ? i : s.convertCatToNumeric(i)
        }
    }, {
        key: "extendYAxis", value: function (i, e) {
            var s = new d,
                t = ((void 0 === i.yaxis || !i.yaxis || Array.isArray(i.yaxis) && 0 === i.yaxis.length) && (i.yaxis = {}), i.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array && (i.yaxis = R.extend(i.yaxis, window.Apex.yaxis)), i.yaxis.constructor !== Array ? i.yaxis = [R.extend(s.yAxis, i.yaxis)] : i.yaxis = R.extendArray(i.yaxis, s.yAxis), !1),
                a = (i.yaxis.forEach(function (e) {
                    e.logarithmic && (t = !0)
                }), i.series);
            return e && !a && (a = e.config.series), t && a.length !== i.yaxis.length && a.length && (i.yaxis = a.map(function (e, t) {
                return e.name || (a[t].name = "series-".concat(t + 1)), i.yaxis[t] ? (i.yaxis[t].seriesName = a[t].name, i.yaxis[t]) : ((e = R.extend(s.yAxis, i.yaxis[0])).show = !1, e)
            })), t && 1 < a.length && a.length !== i.yaxis.length && console.warn("A multi-series logarithmic chart should have equal number of series and y-axes"), i
        }
    }, {
        key: "extendAnnotations", value: function (e) {
            return void 0 === e.annotations && (e.annotations = {}, e.annotations.yaxis = [], e.annotations.xaxis = [], e.annotations.points = []), e = this.extendYAxisAnnotations(e), e = this.extendXAxisAnnotations(e), this.extendPointAnnotations(e)
        }
    }, {
        key: "extendYAxisAnnotations", value: function (e) {
            var t = new d;
            return e.annotations.yaxis = R.extendArray(void 0 !== e.annotations.yaxis ? e.annotations.yaxis : [], t.yAxisAnnotation), e
        }
    }, {
        key: "extendXAxisAnnotations", value: function (e) {
            var t = new d;
            return e.annotations.xaxis = R.extendArray(void 0 !== e.annotations.xaxis ? e.annotations.xaxis : [], t.xAxisAnnotation), e
        }
    }, {
        key: "extendPointAnnotations", value: function (e) {
            var t = new d;
            return e.annotations.points = R.extendArray(void 0 !== e.annotations.points ? e.annotations.points : [], t.pointAnnotation), e
        }
    }, {
        key: "checkForDarkTheme", value: function (e) {
            e.theme && "dark" === e.theme.mode && (e.tooltip || (e.tooltip = {}), "light" !== e.tooltip.theme && (e.tooltip.theme = "dark"), e.chart.foreColor || (e.chart.foreColor = "#f6f7f8"), e.theme.palette || (e.theme.palette = "palette4"))
        }
    }, {
        key: "handleUserInputErrors", value: function (e) {
            if (e.tooltip.shared && e.tooltip.intersect) throw new Error("tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.");
            if ("bar" === e.chart.type && e.plotOptions.bar.horizontal) {
                if (1 < e.yaxis.length) throw new Error("Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false");
                e.yaxis[0].reversed && (e.yaxis[0].opposite = !0), e.xaxis.tooltip.enabled = !1, e.yaxis[0].tooltip.enabled = !1, e.chart.zoom.enabled = !1
            }
            return "bar" !== e.chart.type && "rangeBar" !== e.chart.type || e.tooltip.shared && "barWidth" === e.xaxis.crosshairs.width && 1 < e.series.length && (e.xaxis.crosshairs.width = "tickWidth"), "candlestick" !== e.chart.type && "boxPlot" !== e.chart.type || e.yaxis[0].reversed && (console.warn("Reversed y-axis in ".concat(e.chart.type, " chart is not supported.")), e.yaxis[0].reversed = !1), e
        }
    }]), Qt), xe = (e($t, [{
        key: "initGlobalVars", value: function (e) {
            e.series = [], e.seriesCandleO = [], e.seriesCandleH = [], e.seriesCandleM = [], e.seriesCandleL = [], e.seriesCandleC = [], e.seriesRangeStart = [], e.seriesRangeEnd = [], e.seriesRange = [], e.seriesPercent = [], e.seriesGoals = [], e.seriesX = [], e.seriesZ = [], e.seriesNames = [], e.seriesTotals = [], e.seriesLog = [], e.seriesColors = [], e.stackedSeriesTotals = [], e.seriesXvalues = [], e.seriesYvalues = [], e.labels = [], e.hasXaxisGroups = !1, e.groups = [], e.barGroups = [], e.lineGroups = [], e.areaGroups = [], e.hasSeriesGroups = !1, e.seriesGroups = [], e.categoryLabels = [], e.timescaleLabels = [], e.noLabelsProvided = !1, e.resizeTimer = null, e.selectionResizeTimer = null, e.lastWheelExecution = 0, e.delayedElements = [], e.pointsArray = [], e.dataLabelsRects = [], e.isXNumeric = !1, e.skipLastTimelinelabel = !1, e.skipFirstTimelinelabel = !1, e.isDataXYZ = !1, e.isMultiLineX = !1, e.isMultipleYAxis = !1, e.maxY = -Number.MAX_VALUE, e.minY = Number.MIN_VALUE, e.minYArr = [], e.maxYArr = [], e.maxX = -Number.MAX_VALUE, e.minX = Number.MAX_VALUE, e.initialMaxX = -Number.MAX_VALUE, e.initialMinX = Number.MAX_VALUE, e.maxDate = 0, e.minDate = Number.MAX_VALUE, e.minZ = Number.MAX_VALUE, e.maxZ = -Number.MAX_VALUE, e.minXDiff = Number.MAX_VALUE, e.yAxisScale = [], e.xAxisScale = null, e.xAxisTicksPositions = [], e.yLabelsCoords = [], e.yTitleCoords = [], e.barPadForNumericAxis = 0, e.padHorizontal = 0, e.xRange = 0, e.yRange = [], e.zRange = 0, e.dataPoints = 0, e.xTickAmount = 0, e.multiAxisTickAmount = 0
        }
    }, {
        key: "globalVars", value: function (e) {
            return {
                chartID: null,
                cuid: null,
                events: {
                    beforeMount: [],
                    mounted: [],
                    updated: [],
                    clicked: [],
                    selection: [],
                    dataPointSelection: [],
                    zoomed: [],
                    scrolled: []
                },
                colors: [],
                clientX: null,
                clientY: null,
                fill: {colors: []},
                stroke: {colors: []},
                dataLabels: {style: {colors: []}},
                radarPolygons: {fill: {colors: []}},
                markers: {colors: [], size: e.markers.size, largestSize: 0},
                animationEnded: !1,
                isTouchDevice: "ontouchstart" in window || navigator.msMaxTouchPoints,
                isDirty: !1,
                isExecCalled: !1,
                initialConfig: null,
                initialSeries: [],
                lastXAxis: [],
                lastYAxis: [],
                columnSeries: null,
                labels: [],
                timescaleLabels: [],
                noLabelsProvided: !1,
                allSeriesCollapsed: !1,
                collapsedSeries: [],
                collapsedSeriesIndices: [],
                ancillaryCollapsedSeries: [],
                ancillaryCollapsedSeriesIndices: [],
                risingSeries: [],
                dataFormatXNumeric: !1,
                capturedSeriesIndex: -1,
                capturedDataPointIndex: -1,
                selectedDataPoints: [],
                goldenPadding: 35,
                invalidLogScale: !1,
                ignoreYAxisIndexes: [],
                maxValsInArrayIndex: 0,
                radialSize: 0,
                selection: void 0,
                zoomEnabled: "zoom" === e.chart.toolbar.autoSelected && e.chart.toolbar.tools.zoom && e.chart.zoom.enabled,
                panEnabled: "pan" === e.chart.toolbar.autoSelected && e.chart.toolbar.tools.pan,
                selectionEnabled: "selection" === e.chart.toolbar.autoSelected && e.chart.toolbar.tools.selection,
                yaxis: null,
                mousedown: !1,
                lastClientPosition: {},
                visibleXRange: void 0,
                yValueDecimal: 0,
                total: 0,
                SVGNS: "http://www.w3.org/2000/svg",
                svgWidth: 0,
                svgHeight: 0,
                noData: !1,
                locale: {},
                dom: {},
                memory: {methodsToExec: []},
                shouldAnimate: !0,
                skipLastTimelinelabel: !1,
                skipFirstTimelinelabel: !1,
                delayedElements: [],
                axisCharts: !0,
                isDataXYZ: !1,
                isSlopeChart: e.plotOptions.line.isSlopeChart,
                resized: !1,
                resizeTimer: null,
                comboCharts: !1,
                dataChanged: !1,
                previousPaths: [],
                allSeriesHasEqualX: !0,
                pointsArray: [],
                dataLabelsRects: [],
                lastDrawnDataLabelsIndexes: [],
                hasNullValues: !1,
                easing: null,
                zoomed: !1,
                gridWidth: 0,
                gridHeight: 0,
                rotateXLabels: !1,
                defaultLabels: !1,
                xLabelFormatter: void 0,
                yLabelFormatters: [],
                xaxisTooltipFormatter: void 0,
                ttKeyFormatter: void 0,
                ttVal: void 0,
                ttZFormatter: void 0,
                LINE_HEIGHT_RATIO: 1.618,
                xAxisLabelsHeight: 0,
                xAxisGroupLabelsHeight: 0,
                xAxisLabelsWidth: 0,
                yAxisLabelsWidth: 0,
                scaleX: 1,
                scaleY: 1,
                translateX: 0,
                translateY: 0,
                translateYAxisX: [],
                yAxisWidths: [],
                translateXAxisY: 0,
                translateXAxisX: 0,
                tooltip: null,
                niceScaleAllowedMagMsd: [[1, 1, 2, 5, 5, 5, 10, 10, 10, 10, 10], [1, 1, 2, 5, 5, 5, 10, 10, 10, 10, 10]],
                niceScaleDefaultTicks: [1, 2, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 12, 12, 12, 12, 12, 12, 12, 12, 12, 24],
                seriesYAxisMap: [],
                seriesYAxisReverseMap: []
            }
        }
    }, {
        key: "init", value: function (e) {
            var t = this.globalVars(e);
            return this.initGlobalVars(t), t.initialConfig = R.extend({}, e), t.initialSeries = R.clone(e.series), t.lastXAxis = R.clone(t.initialConfig.xaxis), t.lastYAxis = R.clone(t.initialConfig.yaxis), t
        }
    }]), $t), me = (e(Zt, [{
        key: "init", value: function () {
            var e = new p(this.opts).init({responsiveOverride: !1});
            return {config: e, globals: (new xe).init(e)}
        }
    }]), Zt), S = (e(Ut, [{
        key: "clippedImgArea", value: function (e) {
            var t = this.w, i = t.config, s = parseInt(t.globals.gridWidth, 10), a = parseInt(t.globals.gridHeight, 10),
                s = a < s ? s : a, a = e.image, n = 0, r = 0,
                r = void 0 === e.width && void 0 === e.height ? void 0 !== i.fill.image.width && void 0 !== i.fill.image.height ? (n = i.fill.image.width + 1, i.fill.image.height) : (n = s + 1, s) : (n = e.width, e.height),
                i = document.createElementNS(t.globals.SVGNS, "pattern"), s = (Y.setAttrs(i, {
                    id: e.patternID,
                    patternUnits: e.patternUnits || "userSpaceOnUse",
                    width: n + "px",
                    height: r + "px"
                }), document.createElementNS(t.globals.SVGNS, "image"));
            i.appendChild(s), s.setAttributeNS(window.SVG.xlink, "href", a), Y.setAttrs(s, {
                x: 0,
                y: 0,
                preserveAspectRatio: "none",
                width: n + "px",
                height: r + "px"
            }), s.style.opacity = e.opacity, t.globals.dom.elDefs.node.appendChild(i)
        }
    }, {
        key: "getSeriesIndex", value: function (e) {
            var t = this.w, i = t.config.chart.type;
            return ("bar" === i || "rangeBar" === i) && t.config.plotOptions.bar.distributed || "heatmap" === i || "treemap" === i ? this.seriesIndex = e.seriesNumber : this.seriesIndex = e.seriesNumber % t.globals.series.length, this.seriesIndex
        }
    }, {
        key: "fillPath", value: function (e) {
            var t = this.w;
            this.opts = e;
            var i, s, a = this.w.config,
                n = (this.seriesIndex = this.getSeriesIndex(e), this.getFillColors()[this.seriesIndex]),
                r = ("function" == typeof (n = void 0 !== t.globals.seriesColors[this.seriesIndex] ? t.globals.seriesColors[this.seriesIndex] : n) && (n = n({
                    seriesIndex: this.seriesIndex,
                    dataPointIndex: e.dataPointIndex,
                    value: e.value,
                    w: t
                })), e.fillType || this.getFillType(this.seriesIndex)),
                o = Array.isArray(a.fill.opacity) ? a.fill.opacity[this.seriesIndex] : a.fill.opacity,
                l = ((n = e.color ? e.color : n) || (n = "#fff", console.warn("undefined color - ApexCharts")), n);
            return -1 === n.indexOf("rgb") ? n.length < 9 && (l = R.hexToRgba(n, o)) : -1 < n.indexOf("rgba") && (o = R.getOpacityFromRGBA(n)), e.opacity && (o = e.opacity), "pattern" === r && (i = this.handlePatternFill({
                fillConfig: e.fillConfig,
                patternFill: i,
                fillColor: n,
                fillOpacity: o,
                defaultColor: l
            })), "gradient" === r && (s = this.handleGradientFill({
                fillConfig: e.fillConfig,
                fillColor: n,
                fillOpacity: o,
                i: this.seriesIndex
            })), a = "image" === r ? (n = a.fill.image.src, a = e.patternID || "", t = "pattern".concat(t.globals.cuid).concat(e.seriesNumber + 1).concat(a), -1 === this.patternIDs.indexOf(t) && (this.clippedImgArea({
                opacity: o,
                image: Array.isArray(n) ? e.seriesNumber < n.length ? n[e.seriesNumber] : n[0] : n,
                width: e.width || void 0,
                height: e.height || void 0,
                patternUnits: e.patternUnits,
                patternID: t
            }), this.patternIDs.push(t)), "url(#".concat(t, ")")) : "gradient" === r ? s : "pattern" === r ? i : l, a = e.solid ? l : a
        }
    }, {
        key: "getFillType", value: function (e) {
            var t = this.w;
            return Array.isArray(t.config.fill.type) ? t.config.fill.type[e] : t.config.fill.type
        }
    }, {
        key: "getFillColors", value: function () {
            var e = this.w, t = e.config, i = this.opts, s = [];
            return e.globals.comboCharts ? "line" === e.config.series[this.seriesIndex].type ? Array.isArray(e.globals.stroke.colors) ? s = e.globals.stroke.colors : s.push(e.globals.stroke.colors) : Array.isArray(e.globals.fill.colors) ? s = e.globals.fill.colors : s.push(e.globals.fill.colors) : "line" === t.chart.type ? Array.isArray(e.globals.stroke.colors) ? s = e.globals.stroke.colors : s.push(e.globals.stroke.colors) : Array.isArray(e.globals.fill.colors) ? s = e.globals.fill.colors : s.push(e.globals.fill.colors), void 0 !== i.fillColors && (s = [], Array.isArray(i.fillColors) ? s = i.fillColors.slice() : s.push(i.fillColors)), s
        }
    }, {
        key: "handlePatternFill", value: function (e) {
            var t = e.fillConfig, i = e.fillColor, s = e.fillOpacity, e = e.defaultColor, a = this.w.config.fill,
                t = (t && (a = t), this.opts), n = new Y(this.ctx),
                r = Array.isArray(a.pattern.strokeWidth) ? a.pattern.strokeWidth[this.seriesIndex] : a.pattern.strokeWidth;
            return Array.isArray(a.pattern.style) ? void 0 !== a.pattern.style[t.seriesNumber] ? n.drawPattern(a.pattern.style[t.seriesNumber], a.pattern.width, a.pattern.height, i, r, s) : e : n.drawPattern(a.pattern.style, a.pattern.width, a.pattern.height, i, r, s)
        }
    }, {
        key: "handleGradientFill", value: function (e) {
            var t = e.fillColor, i = e.fillOpacity, s = e.fillConfig, e = e.i, a = this.w.config.fill;
            s && (a = M(M({}, a), s));
            var n, s = this.opts, r = new Y(this.ctx), o = new R, l = a.gradient.type, c = t,
                h = void 0 === a.gradient.opacityFrom ? i : Array.isArray(a.gradient.opacityFrom) ? a.gradient.opacityFrom[e] : a.gradient.opacityFrom,
                i = (-1 < c.indexOf("rgba") && (h = R.getOpacityFromRGBA(c)), void 0 === a.gradient.opacityTo ? i : Array.isArray(a.gradient.opacityTo) ? a.gradient.opacityTo[e] : a.gradient.opacityTo);
            return void 0 === a.gradient.gradientToColors || 0 === a.gradient.gradientToColors.length ? n = "dark" === a.gradient.shade ? o.shadeColor(-1 * parseFloat(a.gradient.shadeIntensity), -1 < t.indexOf("rgb") ? R.rgb2hex(t) : t) : o.shadeColor(parseFloat(a.gradient.shadeIntensity), -1 < t.indexOf("rgb") ? R.rgb2hex(t) : t) : a.gradient.gradientToColors[s.seriesNumber] ? -1 < (n = o = a.gradient.gradientToColors[s.seriesNumber]).indexOf("rgba") && (i = R.getOpacityFromRGBA(o)) : n = t, a.gradient.gradientFrom && (c = a.gradient.gradientFrom), a.gradient.gradientTo && (n = a.gradient.gradientTo), a.gradient.inverseColors && (o = c, c = n, n = o), -1 < c.indexOf("rgb") && (c = R.rgb2hex(c)), -1 < n.indexOf("rgb") && (n = R.rgb2hex(n)), r.drawGradient(l, c, n, h, i, s.size, a.gradient.stops, a.gradient.colorStops, e)
        }
    }]), Ut), k = (e(qt, [{
        key: "setGlobalMarkerSize", value: function () {
            var t = this.w;
            if (t.globals.markers.size = Array.isArray(t.config.markers.size) ? t.config.markers.size : [t.config.markers.size], 0 < t.globals.markers.size.length) {
                if (t.globals.markers.size.length < t.globals.series.length + 1) for (var e = 0; e <= t.globals.series.length; e++) void 0 === t.globals.markers.size[e] && t.globals.markers.size.push(t.globals.markers.size[0])
            } else t.globals.markers.size = t.config.series.map(function (e) {
                return t.config.markers.size
            })
        }
    }, {
        key: "plotChartMarkers", value: function (e, t, i, s) {
            var a, n = 4 < arguments.length && void 0 !== arguments[4] && arguments[4], r = this.w, o = t, l = e,
                c = null, h = new Y(this.ctx), d = r.config.markers.discrete && r.config.markers.discrete.length;
            if ((0 < r.globals.markers.size[t] || n || d) && (c = h.group({class: n || d ? "" : "apexcharts-series-markers"})).attr("clip-path", "url(#gridRectMarkerMask".concat(r.globals.cuid, ")")), Array.isArray(l.x)) for (var u = 0; u < l.x.length; u++) {
                var g = 1 === i && 1 === u ? 1 : 1 === i && 0 === u ? 0 : i, p = "apexcharts-marker";
                "line" !== r.config.chart.type && "area" !== r.config.chart.type || r.globals.comboCharts || r.config.tooltip.intersect || (p += " no-pointer-events"), (Array.isArray(r.config.markers.size) ? 0 < r.globals.markers.size[t] : 0 < r.config.markers.size) || n || d ? (R.isNumber(l.y[u]) ? p += " w".concat(R.randomId()) : p = "apexcharts-nullpoint", p = this.getMarkerConfig({
                    cssClass: p,
                    seriesIndex: t,
                    dataPointIndex: g
                }), r.config.series[o].data[g] && (r.config.series[o].data[g].fillColor && (p.pointFillColor = r.config.series[o].data[g].fillColor), r.config.series[o].data[g].strokeColor) && (p.pointStrokeColor = r.config.series[o].data[g].strokeColor), void 0 !== s && (p.pSize = s), (l.x[u] < -r.globals.markers.largestSize || l.x[u] > r.globals.gridWidth + r.globals.markers.largestSize || l.y[u] < -r.globals.markers.largestSize || l.y[u] > r.globals.gridHeight + r.globals.markers.largestSize) && (p.pSize = 0), (a = h.drawMarker(l.x[u], l.y[u], p)).attr("rel", g), a.attr("j", g), a.attr("index", t), a.node.setAttribute("default-marker-size", p.pSize), new P(this.ctx).setSelectionFilter(a, t, g), this.addEvents(a), c && c.add(a)) : (void 0 === r.globals.pointsArray[t] && (r.globals.pointsArray[t] = []), r.globals.pointsArray[t].push([l.x[u], l.y[u]]))
            }
            return c
        }
    }, {
        key: "getMarkerConfig", value: function (e) {
            var t = e.cssClass, i = e.seriesIndex, s = e.dataPointIndex, a = void 0 === s ? null : s, s = e.radius,
                s = void 0 === s ? null : s, n = e.size, n = void 0 === n ? null : n, e = e.strokeWidth,
                e = void 0 === e ? null : e, r = this.w, o = this.getMarkerStyle(i),
                l = null === n ? r.globals.markers.size[i] : n, n = r.config.markers;
            return null !== a && n.discrete.length && n.discrete.map(function (e) {
                e.seriesIndex === i && e.dataPointIndex === a && (o.pointStrokeColor = e.strokeColor, o.pointFillColor = e.fillColor, l = e.size, o.pointShape = e.shape)
            }), {
                pSize: null === s ? l : s,
                pRadius: null !== s ? s : n.radius,
                pointStrokeWidth: null !== e ? e : Array.isArray(n.strokeWidth) ? n.strokeWidth[i] : n.strokeWidth,
                pointStrokeColor: o.pointStrokeColor,
                pointFillColor: o.pointFillColor,
                shape: o.pointShape || (Array.isArray(n.shape) ? n.shape[i] : n.shape),
                class: t,
                pointStrokeOpacity: Array.isArray(n.strokeOpacity) ? n.strokeOpacity[i] : n.strokeOpacity,
                pointStrokeDashArray: Array.isArray(n.strokeDashArray) ? n.strokeDashArray[i] : n.strokeDashArray,
                pointFillOpacity: Array.isArray(n.fillOpacity) ? n.fillOpacity[i] : n.fillOpacity,
                seriesIndex: i
            }
        }
    }, {
        key: "addEvents", value: function (e) {
            var t = this.w, i = new Y(this.ctx);
            e.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this.ctx, e)), e.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this.ctx, e)), e.node.addEventListener("mousedown", i.pathMouseDown.bind(this.ctx, e)), e.node.addEventListener("click", t.config.markers.onClick), e.node.addEventListener("dblclick", t.config.markers.onDblClick), e.node.addEventListener("touchstart", i.pathMouseDown.bind(this.ctx, e), {passive: !0})
        }
    }, {
        key: "getMarkerStyle", value: function (e) {
            var t = this.w, i = t.globals.markers.colors,
                t = t.config.markers.strokeColor || t.config.markers.strokeColors;
            return {pointStrokeColor: Array.isArray(t) ? t[e] : t, pointFillColor: Array.isArray(i) ? i[e] : i}
        }
    }]), qt), be = (e(Vt, [{
        key: "draw", value: function (e, t, i) {
            var s = this.w, a = new Y(this.ctx), n = i.realIndex, r = i.pointsPos, o = i.zRatio, l = i.elParent,
                c = a.group({class: "apexcharts-series-markers apexcharts-series-".concat(s.config.chart.type)});
            if (c.attr("clip-path", "url(#gridRectMarkerMask".concat(s.globals.cuid, ")")), Array.isArray(r.x)) for (var h = 0; h < r.x.length; h++) {
                var d = t + 1, u = !0,
                    g = (0 === t && 0 === h && (d = 0), 0 === t && 1 === h && (d = 1), s.globals.markers.size[n]),
                    p = (o !== 1 / 0 && (p = s.config.plotOptions.bubble, g = s.globals.seriesZ[n][d], p.zScaling && (g /= o), p.minBubbleRadius && g < p.minBubbleRadius && (g = p.minBubbleRadius), p.maxBubbleRadius) && g > p.maxBubbleRadius && (g = p.maxBubbleRadius), r.x[h]),
                    f = r.y[h];
                g = g || 0, (u = null !== f && void 0 !== s.globals.series[n][d] && u) && (u = this.drawPoint(p, f, g, n, d, t), c.add(u)), l.add(c)
            }
        }
    }, {
        key: "drawPoint", value: function (e, t, i, s, a, n) {
            var r = this.w, o = s, l = new A(this.ctx), c = new P(this.ctx), h = new S(this.ctx), d = new k(this.ctx),
                u = new Y(this.ctx), i = d.getMarkerConfig({
                    cssClass: "apexcharts-marker",
                    seriesIndex: o,
                    dataPointIndex: a,
                    radius: "bubble" === r.config.chart.type || r.globals.comboCharts && r.config.series[s] && "bubble" === r.config.series[s].type ? i : null
                }), h = h.fillPath({
                    seriesNumber: s,
                    dataPointIndex: a,
                    color: i.pointFillColor,
                    patternUnits: "objectBoundingBox",
                    value: r.globals.series[s][n]
                }), g = u.drawMarker(e, t, i);
            return r.config.series[o].data[a] && r.config.series[o].data[a].fillColor && (h = r.config.series[o].data[a].fillColor), g.attr({fill: h}), r.config.chart.dropShadow.enabled && (n = r.config.chart.dropShadow, c.dropShadow(g, n, s)), !this.initialAnim || r.globals.dataChanged || r.globals.resized ? r.globals.animationEnded = !0 : (u = r.config.chart.animations.speed, l.animateMarker(g, u, r.globals.easing, function () {
                window.setTimeout(function () {
                    l.animationCompleted(g)
                }, 100)
            })), g.attr({
                rel: a,
                j: a,
                index: s,
                "default-marker-size": i.pSize
            }), c.setSelectionFilter(g, s, a), d.addEvents(g), g.node.classList.add("apexcharts-marker"), g
        }
    }, {
        key: "centerTextInBubble", value: function (e) {
            var t = this.w;
            return {y: e += parseInt(t.config.dataLabels.style.fontSize, 10) / 4}
        }
    }]), Vt), L = (e(Gt, [{
        key: "dataLabelsCorrection", value: function (e, t, i, s, a, n, r) {
            var o = this.w, l = !1, i = new Y(this.ctx).getTextRects(i, r), r = i.width, c = i.height,
                h = ((t = t < 0 ? 0 : t) > o.globals.gridHeight + c && (t = o.globals.gridHeight + c / 2), void 0 === o.globals.dataLabelsRects[s] && (o.globals.dataLabelsRects[s] = []), o.globals.dataLabelsRects[s].push({
                    x: e,
                    y: t,
                    width: r,
                    height: c
                }), o.globals.dataLabelsRects[s].length - 2),
                d = void 0 !== o.globals.lastDrawnDataLabelsIndexes[s] ? o.globals.lastDrawnDataLabelsIndexes[s][o.globals.lastDrawnDataLabelsIndexes[s].length - 1] : 0;
            return void 0 !== o.globals.dataLabelsRects[s][h] && (e > (h = o.globals.dataLabelsRects[s][d]).x + h.width || t > h.y + h.height || t + c < h.y || e + r < h.x) && (l = !0), {
                x: e,
                y: t,
                textRects: i,
                drawnextLabel: l = 0 !== a && !n ? l : !0
            }
        }
    }, {
        key: "drawDataLabel", value: function (e) {
            var t = this, i = e.type, s = e.pos, a = e.i, n = e.j, r = e.isRangeStart, e = e.strokeWidth,
                o = void 0 === e ? 2 : e, l = this.w, e = new Y(this.ctx), c = l.config.dataLabels, h = 0, d = n;
            if (-1 !== l.globals.collapsedSeriesIndices.indexOf(a) || !c.enabled || !Array.isArray(s.x)) return null;
            for (var u = e.group({class: "apexcharts-data-labels"}), g = 0; g < s.x.length; g++) {
                var p, f, x, m = s.x[g] + c.offsetX, h = s.y[g] + c.offsetY + o;
                isNaN(m) || (1 === n && 0 === g && (d = 0), 1 === n && 1 === g && (d = 1), p = l.globals.series[a][d], "rangeArea" === i && (p = (r ? l.globals.seriesRangeStart : l.globals.seriesRangeEnd)[a][d]), f = "", x = function (e) {
                    return l.config.dataLabels.formatter(e, {ctx: t.ctx, seriesIndex: a, dataPointIndex: d, w: l})
                }, "bubble" === l.config.chart.type ? (f = x(p = l.globals.seriesZ[a][d]), h = s.y[g], h = new be(this.ctx).centerTextInBubble(h, a, d).y) : void 0 !== p && (f = x(p)), x = l.config.dataLabels.textAnchor, l.globals.isSlopeChart && (x = 0 === d ? "end" : d === l.config.series[a].data.length - 1 ? "start" : "middle"), this.plotDataLabelsText({
                    x: m,
                    y: h,
                    text: f,
                    i: a,
                    j: d,
                    parent: u,
                    offsetCorrection: !0,
                    dataLabelsConfig: l.config.dataLabels,
                    textAnchor: x
                }))
            }
            return u
        }
    }, {
        key: "plotDataLabelsText", value: function (e) {
            var t, i = this.w, s = new Y(this.ctx), a = e.x, n = e.y, r = e.i, o = e.j, l = e.text, c = e.textAnchor,
                h = e.fontSize, d = e.parent, u = e.dataLabelsConfig, g = e.color, p = e.alwaysDrawDataLabel,
                f = e.offsetCorrection, e = e.className, x = null;
            return Array.isArray(i.config.dataLabels.enabledOnSeries) && i.config.dataLabels.enabledOnSeries.indexOf(r) < 0 || (t = {
                x: a,
                y: n,
                drawnextLabel: !0,
                textRects: null
            }, f && (t = this.dataLabelsCorrection(a, n, l, r, o, p, parseInt(u.style.fontSize, 10))), i.globals.zoomed || (a = t.x, n = t.y), t.textRects && (a < -20 - t.textRects.width || a > i.globals.gridWidth + t.textRects.width + 30) && (l = ""), f = i.globals.dataLabels.style.colors[r], "function" == typeof (f = ("bar" === i.config.chart.type || "rangeBar" === i.config.chart.type) && i.config.plotOptions.bar.distributed || i.config.dataLabels.distributed ? i.globals.dataLabels.style.colors[o] : f) && (f = f({
                series: i.globals.series,
                seriesIndex: r,
                dataPointIndex: o,
                w: i
            })), g && (f = g), p = u.offsetX, g = u.offsetY, "bar" !== i.config.chart.type && "rangeBar" !== i.config.chart.type || (g = p = 0), i.globals.isSlopeChart && (0 !== o && (p = -2 * u.offsetX + 5), 0 !== o) && o !== i.config.series[r].data.length - 1 && (p = 0), t.drawnextLabel && ((x = s.drawText({
                width: 100,
                height: parseInt(u.style.fontSize, 10),
                x: a + p,
                y: n + g,
                foreColor: f,
                textAnchor: c || u.textAnchor,
                text: l,
                fontSize: h || u.style.fontSize,
                fontFamily: u.style.fontFamily,
                fontWeight: u.style.fontWeight || "normal"
            })).attr({
                class: e || "apexcharts-datalabel",
                cx: a,
                cy: n
            }), u.dropShadow.enabled && (t = u.dropShadow, new P(this.ctx).dropShadow(x, t)), d.add(x), void 0 === i.globals.lastDrawnDataLabelsIndexes[r] && (i.globals.lastDrawnDataLabelsIndexes[r] = []), i.globals.lastDrawnDataLabelsIndexes[r].push(o))), x
        }
    }, {
        key: "addBackgroundToDataLabel", value: function (e, t) {
            var i = this.w, s = i.config.dataLabels.background, a = s.padding, n = s.padding / 2, r = t.width,
                o = t.height,
                t = new Y(this.ctx).drawRect(t.x - a, t.y - n / 2, r + 2 * a, o + n, s.borderRadius, "transparent" !== i.config.chart.background && i.config.chart.background ? i.config.chart.background : "#fff", s.opacity, s.borderWidth, s.borderColor);
            return s.dropShadow.enabled && new P(this.ctx).dropShadow(t, s.dropShadow), t
        }
    }, {
        key: "dataLabelsBackground", value: function () {
            var e = this.w;
            if ("bubble" !== e.config.chart.type) for (var t = e.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels text"), i = 0; i < t.length; i++) {
                var s = t[i], a = s.getBBox(), n = null;
                (n = a.width && a.height ? this.addBackgroundToDataLabel(s, a) : n) && (s.parentNode.insertBefore(n.node, s), a = s.getAttribute("fill"), (!e.config.chart.animations.enabled || e.globals.resized || e.globals.dataChanged ? n : n.animate()).attr({fill: a}), s.setAttribute("fill", e.config.dataLabels.background.foreColor))
            }
        }
    }, {
        key: "bringForward", value: function () {
            for (var e = this.w, t = e.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels"), i = e.globals.dom.baseEl.querySelector(".apexcharts-plot-series:last-child"), s = 0; s < t.length; s++) i && i.insertBefore(t[s], i.nextSibling)
        }
    }]), Gt), T = (e(jt, [{
        key: "getAllSeriesEls", value: function () {
            return this.w.globals.dom.baseEl.getElementsByClassName("apexcharts-series")
        }
    }, {
        key: "getSeriesByName", value: function (e) {
            return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner .apexcharts-series[seriesName='".concat(R.escapeString(e), "']"))
        }
    }, {
        key: "isSeriesHidden", value: function (e) {
            var e = this.getSeriesByName(e), t = parseInt(e.getAttribute("data:realIndex"), 10);
            return {isHidden: e.classList.contains("apexcharts-series-collapsed"), realIndex: t}
        }
    }, {
        key: "addCollapsedClassToSeries", value: function (i, s) {
            var e = this.w;

            function t(e) {
                for (var t = 0; t < e.length; t++) e[t].index === s && i.node.classList.add("apexcharts-series-collapsed")
            }

            t(e.globals.collapsedSeries), t(e.globals.ancillaryCollapsedSeries)
        }
    }, {
        key: "toggleSeries", value: function (e) {
            e = this.isSeriesHidden(e);
            return this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex, e.isHidden), e.isHidden
        }
    }, {
        key: "showSeries", value: function (e) {
            e = this.isSeriesHidden(e);
            e.isHidden && this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex, !0)
        }
    }, {
        key: "hideSeries", value: function (e) {
            e = this.isSeriesHidden(e);
            e.isHidden || this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex, !1)
        }
    }, {
        key: "resetSeries", value: function () {
            var e = !(0 < arguments.length && void 0 !== arguments[0]) || arguments[0],
                t = !(1 < arguments.length && void 0 !== arguments[1]) || arguments[1],
                i = !(2 < arguments.length && void 0 !== arguments[2]) || arguments[2], s = this.w,
                a = R.clone(s.globals.initialSeries);
            s.globals.previousPaths = [], i ? (s.globals.collapsedSeries = [], s.globals.ancillaryCollapsedSeries = [], s.globals.collapsedSeriesIndices = [], s.globals.ancillaryCollapsedSeriesIndices = []) : a = this.emptyCollapsedSeries(a), s.config.series = a, e && (t && (s.globals.zoomed = !1, this.ctx.updateHelpers.revertDefaultAxisMinMax()), this.ctx.updateHelpers._updateSeries(a, s.config.chart.animations.dynamicAnimation.enabled))
        }
    }, {
        key: "emptyCollapsedSeries", value: function (e) {
            for (var t = this.w, i = 0; i < e.length; i++) -1 < t.globals.collapsedSeriesIndices.indexOf(i) && (e[i].data = []);
            return e
        }
    }, {
        key: "highlightSeries", value: function (e) {
            var t, i = this.w, e = this.getSeriesByName(e), e = parseInt(e.getAttribute("data:realIndex"), 10),
                s = i.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels, .apexcharts-yaxis"),
                a = null, n = null, r = null;
            i.globals.axisCharts || "radialBar" === i.config.chart.type ? i.globals.axisCharts ? (a = i.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(e, "']")), n = i.globals.dom.baseEl.querySelector(".apexcharts-datalabels[data\\:realIndex='".concat(e, "']")), t = i.globals.seriesYAxisReverseMap[e], r = i.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(t, "']"))) : a = i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(e + 1, "']")) : a = i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(e + 1, "'] path"));
            for (var o = 0; o < s.length; o++) s[o].classList.add(this.legendInactiveClass);
            null !== a && (i.globals.axisCharts || a.parentNode.classList.remove(this.legendInactiveClass), a.classList.remove(this.legendInactiveClass), null !== n && n.classList.remove(this.legendInactiveClass), null !== r) && r.classList.remove(this.legendInactiveClass)
        }
    }, {
        key: "toggleSeriesOnHover", value: function (e, t) {
            var i = this.w,
                s = (t = t || e.target, i.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels, .apexcharts-yaxis"));
            if ("mousemove" === e.type) {
                t = parseInt(t.getAttribute("rel"), 10) - 1;
                this.highlightSeries(i.config.series[t].name)
            } else if ("mouseout" === e.type) for (var a = 0; a < s.length; a++) s[a].classList.remove(this.legendInactiveClass)
        }
    }, {
        key: "highlightRangeInSeries", value: function (e, t) {
            function i(e) {
                for (var t = 0; t < n.length; t++) n[t].classList[e](s.legendInactiveClass)
            }

            var s = this, a = this.w, n = a.globals.dom.baseEl.getElementsByClassName("apexcharts-heatmap-rect");
            if ("mousemove" === e.type) for (var t = parseInt(t.getAttribute("rel"), 10) - 1, a = (i("add"), a.config.plotOptions.heatmap.colorScale.ranges), r = a[t], o = a.reduce(function (e, t) {
                return Math.max(e, t.to)
            }, 0), l = 0; l < n.length; l++) {
                var c = Number(n[l].getAttribute("val"));
                c >= r.from && (c < r.to || r.to === o && c === o) && n[l].classList.remove(s.legendInactiveClass)
            } else "mouseout" === e.type && i("remove")
        }
    }, {
        key: "getActiveConfigSeriesIndex", value: function () {
            var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : "asc",
                i = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : [], s = this.w, t = 0;
            if (1 < s.config.series.length) for (var a = s.config.series.map(function (e, t) {
                return e.data && 0 < e.data.length && -1 === s.globals.collapsedSeriesIndices.indexOf(t) && (!s.globals.comboCharts || 0 === i.length || i.length && -1 < i.indexOf(s.config.series[t].type)) ? t : -1
            }), n = "asc" === e ? 0 : a.length - 1; "asc" === e ? n < a.length : 0 <= n; "asc" === e ? n++ : n--) if (-1 !== a[n]) {
                t = a[n];
                break
            }
            return t
        }
    }, {
        key: "getBarSeriesIndices", value: function () {
            return this.w.globals.comboCharts ? this.w.config.series.map(function (e, t) {
                return "bar" === e.type || "column" === e.type ? t : -1
            }).filter(function (e) {
                return -1 !== e
            }) : this.w.config.series.map(function (e, t) {
                return t
            })
        }
    }, {
        key: "getPreviousPaths", value: function () {
            var h = this.w;
            h.globals.previousPaths = [], ["line", "area", "bar", "rangebar", "rangeArea", "candlestick", "radar"].forEach(function (e) {
                for (var t = h.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(e, "-series .apexcharts-series")), i = 0; i < t.length; i++) {
                    s = void 0;
                    a = void 0;
                    n = void 0;
                    o = void 0;
                    l = void 0;
                    c = void 0;
                    r = void 0;
                    var s = t;
                    var a = i;
                    var n = e;
                    for (var r, o = s[a].childNodes, l = {
                        type: n,
                        paths: [],
                        realIndex: s[a].getAttribute("data:realIndex")
                    }, c = 0; c < o.length; c++) o[c].hasAttribute("pathTo") && (r = o[c].getAttribute("pathTo"), l.paths.push({d: r}));
                    h.globals.previousPaths.push(l)
                }
            }), this.handlePrevBubbleScatterPaths("bubble"), this.handlePrevBubbleScatterPaths("scatter");
            var e = h.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(h.config.chart.type, " .apexcharts-series"));
            if (0 < e.length) for (var t = 0; t < e.length; t++) (e => {
                for (var s = h.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(h.config.chart.type, " .apexcharts-series[data\\:realIndex='").concat(e, "'] rect")), a = [], t = 0; t < s.length; t++) (t => {
                    function e(e) {
                        return s[t].getAttribute(e)
                    }

                    var i = {
                        x: parseFloat(e("x")),
                        y: parseFloat(e("y")),
                        width: parseFloat(e("width")),
                        height: parseFloat(e("height"))
                    };
                    a.push({rect: i, color: s[t].getAttribute("color")})
                })(t);
                h.globals.previousPaths.push(a)
            })(t);
            h.globals.axisCharts || (h.globals.previousPaths = h.globals.series)
        }
    }, {
        key: "handlePrevBubbleScatterPaths", value: function (e) {
            var t = this.w,
                i = t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(e, "-series .apexcharts-series"));
            if (0 < i.length) for (var s = 0; s < i.length; s++) {
                for (var a = t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(e, "-series .apexcharts-series[data\\:realIndex='").concat(s, "'] circle")), n = [], r = 0; r < a.length; r++) n.push({
                    x: a[r].getAttribute("cx"),
                    y: a[r].getAttribute("cy"),
                    r: a[r].getAttribute("r")
                });
                t.globals.previousPaths.push(n)
            }
        }
    }, {
        key: "clearPreviousPaths", value: function () {
            var e = this.w;
            e.globals.previousPaths = [], e.globals.allSeriesCollapsed = !1
        }
    }, {
        key: "handleNoData", value: function () {
            var e = this.w, t = e.config.noData, i = new Y(this.ctx), s = e.globals.svgWidth / 2,
                a = e.globals.svgHeight / 2, n = "middle";
            e.globals.noData = !0, e.globals.animationEnded = !0, "left" === t.align ? (s = 10, n = "start") : "right" === t.align && (s = e.globals.svgWidth - 10, n = "end"), "top" === t.verticalAlign ? a = 50 : "bottom" === t.verticalAlign && (a = e.globals.svgHeight - 50), s += t.offsetX, a = a + parseInt(t.style.fontSize, 10) + 2 + t.offsetY, void 0 !== t.text && "" !== t.text && (i = i.drawText({
                x: s,
                y: a,
                text: t.text,
                textAnchor: n,
                fontSize: t.style.fontSize,
                fontFamily: t.style.fontFamily,
                foreColor: t.style.color,
                opacity: 1,
                class: "apexcharts-text-nodata"
            }), e.globals.dom.Paper.add(i))
        }
    }, {
        key: "setNullSeriesToZeroValues", value: function (e) {
            for (var t = this.w, i = 0; i < e.length; i++) if (0 === e[i].length) for (var s = 0; s < e[t.globals.maxValsInArrayIndex].length; s++) e[i].push(0);
            return e
        }
    }, {
        key: "hasAllSeriesEqualX", value: function () {
            for (var e = !0, t = this.w, i = this.filteredSeriesX(), s = 0; s < i.length - 1; s++) if (i[s][0] !== i[s + 1][0]) {
                e = !1;
                break
            }
            return t.globals.allSeriesHasEqualX = e
        }
    }, {
        key: "filteredSeriesX", value: function () {
            return this.w.globals.seriesX.map(function (e) {
                return 0 < e.length ? e : []
            })
        }
    }]), jt), ve = (e(Bt, [{
        key: "isMultiFormat", value: function () {
            return this.isFormatXY() || this.isFormat2DArray()
        }
    }, {
        key: "isFormatXY", value: function () {
            var e = this.w.config.series.slice(), t = new T(this.ctx);
            if (this.activeSeriesIndex = t.getActiveConfigSeriesIndex(), void 0 !== e[this.activeSeriesIndex].data && 0 < e[this.activeSeriesIndex].data.length && null !== e[this.activeSeriesIndex].data[0] && void 0 !== e[this.activeSeriesIndex].data[0].x && null !== e[this.activeSeriesIndex].data[0]) return !0
        }
    }, {
        key: "isFormat2DArray", value: function () {
            var e = this.w.config.series.slice(), t = new T(this.ctx);
            if (this.activeSeriesIndex = t.getActiveConfigSeriesIndex(), void 0 !== e[this.activeSeriesIndex].data && 0 < e[this.activeSeriesIndex].data.length && null != e[this.activeSeriesIndex].data[0] && e[this.activeSeriesIndex].data[0].constructor === Array) return !0
        }
    }, {
        key: "handleFormat2DArray", value: function (e, t) {
            for (var i, s = this.w.config, a = this.w.globals, n = "boxPlot" === s.chart.type || "boxPlot" === s.series[t].type, r = 0; r < e[t].data.length; r++) void 0 !== e[t].data[r][1] && (Array.isArray(e[t].data[r][1]) && 4 === e[t].data[r][1].length && !n ? this.twoDSeries.push(R.parseNumber(e[t].data[r][1][3])) : 5 <= e[t].data[r].length ? this.twoDSeries.push(R.parseNumber(e[t].data[r][4])) : this.twoDSeries.push(R.parseNumber(e[t].data[r][1])), a.dataFormatXNumeric = !0), "datetime" === s.xaxis.type ? (i = new Date(e[t].data[r][0]), i = new Date(i).getTime(), this.twoDSeriesX.push(i)) : this.twoDSeriesX.push(e[t].data[r][0]);
            for (var o = 0; o < e[t].data.length; o++) void 0 !== e[t].data[o][2] && (this.threeDSeries.push(e[t].data[o][2]), a.isDataXYZ = !0)
        }
    }, {
        key: "handleFormatXY", value: function (e, t) {
            var i = this.w.config, s = this.w.globals, a = new y(this.ctx), n = t;
            -1 < s.collapsedSeriesIndices.indexOf(t) && (n = this.activeSeriesIndex);
            for (var r = 0; r < e[t].data.length; r++) void 0 !== e[t].data[r].y && (Array.isArray(e[t].data[r].y) ? this.twoDSeries.push(R.parseNumber(e[t].data[r].y[e[t].data[r].y.length - 1])) : this.twoDSeries.push(R.parseNumber(e[t].data[r].y))), void 0 !== e[t].data[r].goals && Array.isArray(e[t].data[r].goals) ? (void 0 === this.seriesGoals[t] && (this.seriesGoals[t] = []), this.seriesGoals[t].push(e[t].data[r].goals)) : (void 0 === this.seriesGoals[t] && (this.seriesGoals[t] = []), this.seriesGoals[t].push(null));
            for (var o = 0; o < e[n].data.length; o++) {
                var l = "string" == typeof e[n].data[o].x, c = Array.isArray(e[n].data[o].x),
                    h = !c && !!a.isValidDate(e[n].data[o].x);
                l || h ? l || i.xaxis.convertedCatToNumeric ? (h = s.isBarHorizontal && s.isRangeData, "datetime" !== i.xaxis.type || h ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(e[n].data[o].x), isNaN(e[n].data[o].x) || "category" === this.w.config.xaxis.type || "string" == typeof e[n].data[o].x || (s.isXNumeric = !0)) : this.twoDSeriesX.push(a.parseDate(e[n].data[o].x))) : "datetime" === i.xaxis.type ? this.twoDSeriesX.push(a.parseDate(e[n].data[o].x.toString())) : (s.dataFormatXNumeric = !0, s.isXNumeric = !0, this.twoDSeriesX.push(parseFloat(e[n].data[o].x))) : (c ? this.fallbackToCategory = !0 : (s.isXNumeric = !0, s.dataFormatXNumeric = !0), this.twoDSeriesX.push(e[n].data[o].x))
            }
            if (e[t].data[0] && void 0 !== e[t].data[0].z) {
                for (var d = 0; d < e[t].data.length; d++) this.threeDSeries.push(e[t].data[d].z);
                s.isDataXYZ = !0
            }
        }
    }, {
        key: "handleRangeData", value: function (e, t) {
            var i = this.w.globals, s = {};
            return this.isFormat2DArray() ? s = this.handleRangeDataFormat("array", e, t) : this.isFormatXY() && (s = this.handleRangeDataFormat("xy", e, t)), i.seriesRangeStart.push(void 0 === s.start ? [] : s.start), i.seriesRangeEnd.push(void 0 === s.end ? [] : s.end), i.seriesRange.push(s.rangeUniques), i.seriesRange.forEach(function (e, t) {
                e && e.forEach(function (n, e) {
                    n.y.forEach(function (e, t) {
                        for (var i, s, a = 0; a < n.y.length; a++) t !== a && (i = e.y1, s = n.y[a].y1, i <= n.y[a].y2) && s <= e.y2 && (n.overlaps.indexOf(e.rangeName) < 0 && n.overlaps.push(e.rangeName), n.overlaps.indexOf(n.y[a].rangeName) < 0) && n.overlaps.push(n.y[a].rangeName)
                    })
                })
            }), s
        }
    }, {
        key: "handleCandleStickBoxData", value: function (e, t) {
            var i = this.w.globals, s = {};
            return this.isFormat2DArray() ? s = this.handleCandleStickBoxDataFormat("array", e, t) : this.isFormatXY() && (s = this.handleCandleStickBoxDataFormat("xy", e, t)), i.seriesCandleO[t] = s.o, i.seriesCandleH[t] = s.h, i.seriesCandleM[t] = s.m, i.seriesCandleL[t] = s.l, i.seriesCandleC[t] = s.c, s
        }
    }, {
        key: "handleRangeDataFormat", value: function (e, a, n) {
            var r = [], o = [], l = a[n].data.filter(function (t, e, i) {
                return e === i.findIndex(function (e) {
                    return e.x === t.x
                })
            }).map(function (e, t) {
                return {x: e.x, overlaps: [], y: []}
            });
            if ("array" === e) for (var t = 0; t < a[n].data.length; t++) Array.isArray(a[n].data[t]) ? (r.push(a[n].data[t][1][0]), o.push(a[n].data[t][1][1])) : (r.push(a[n].data[t]), o.push(a[n].data[t])); else if ("xy" === e) for (var i = 0; i < a[n].data.length; i++) (e => {
                var t = Array.isArray(a[n].data[e].y), i = R.randomId(), s = a[n].data[e].x, t = {
                    y1: t ? a[n].data[e].y[0] : a[n].data[e].y,
                    y2: t ? a[n].data[e].y[1] : a[n].data[e].y,
                    rangeName: i
                }, e = (a[n].data[e].rangeName = i, l.findIndex(function (e) {
                    return e.x === s
                }));
                l[e].y.push(t), r.push(t.y1), o.push(t.y2)
            })(i);
            return {start: r, end: o, rangeUniques: l}
        }
    }, {
        key: "handleCandleStickBoxDataFormat", value: function (e, t, i) {
            var s = this.w, a = "boxPlot" === s.config.chart.type || "boxPlot" === s.config.series[i].type, n = [],
                r = [], o = [], l = [], c = [];
            if ("array" === e) if (a && 6 === t[i].data[0].length || !a && 5 === t[i].data[0].length) for (var h = 0; h < t[i].data.length; h++) n.push(t[i].data[h][1]), r.push(t[i].data[h][2]), a ? (o.push(t[i].data[h][3]), l.push(t[i].data[h][4]), c.push(t[i].data[h][5])) : (l.push(t[i].data[h][3]), c.push(t[i].data[h][4])); else for (var d = 0; d < t[i].data.length; d++) Array.isArray(t[i].data[d][1]) && (n.push(t[i].data[d][1][0]), r.push(t[i].data[d][1][1]), a ? (o.push(t[i].data[d][1][2]), l.push(t[i].data[d][1][3]), c.push(t[i].data[d][1][4])) : (l.push(t[i].data[d][1][2]), c.push(t[i].data[d][1][3]))); else if ("xy" === e) for (var u = 0; u < t[i].data.length; u++) Array.isArray(t[i].data[u].y) && (n.push(t[i].data[u].y[0]), r.push(t[i].data[u].y[1]), a ? (o.push(t[i].data[u].y[2]), l.push(t[i].data[u].y[3]), c.push(t[i].data[u].y[4])) : (l.push(t[i].data[u].y[2]), c.push(t[i].data[u].y[3])));
            return {o: n, h: r, m: o, l: l, c: c}
        }
    }, {
        key: "parseDataAxisCharts", value: function (e) {
            var t = this, i = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : this.ctx,
                s = this.w.config, a = this.w.globals, n = new y(i),
                r = (0 < s.labels.length ? s.labels : s.xaxis.categories).slice(),
                o = (a.isRangeBar = "rangeBar" === s.chart.type && a.isBarHorizontal, a.hasXaxisGroups = "category" === s.xaxis.type && 0 < s.xaxis.group.groups.length, a.hasXaxisGroups && (a.groups = s.xaxis.group.groups), e.forEach(function (e, t) {
                    void 0 !== e.name ? a.seriesNames.push(e.name) : a.seriesNames.push("series-" + parseInt(t + 1, 10))
                }), this.coreUtils.setSeriesYAxisMappings(), []), l = C(new Set(s.series.map(function (e) {
                    return e.group
                })));
            s.series.forEach(function (e, t) {
                e = l.indexOf(e.group);
                o[e] || (o[e] = []), o[e].push(a.seriesNames[t])
            }), a.seriesGroups = o;
            for (var c = 0; c < e.length; c++) {
                if (this.twoDSeries = [], this.twoDSeriesX = [], this.threeDSeries = [], void 0 === e[c].data) return void console.error("It is a possibility that you may have not included 'data' property in series.");
                if ("rangeBar" !== s.chart.type && "rangeArea" !== s.chart.type && "rangeBar" !== e[c].type && "rangeArea" !== e[c].type || (a.isRangeData = !0, "rangeBar" !== s.chart.type && "rangeArea" !== s.chart.type) || this.handleRangeData(e, c), this.isMultiFormat()) this.isFormat2DArray() ? this.handleFormat2DArray(e, c) : this.isFormatXY() && this.handleFormatXY(e, c), "candlestick" !== s.chart.type && "candlestick" !== e[c].type && "boxPlot" !== s.chart.type && "boxPlot" !== e[c].type || this.handleCandleStickBoxData(e, c), a.series.push(this.twoDSeries), a.labels.push(this.twoDSeriesX), a.seriesX.push(this.twoDSeriesX), a.seriesGoals = this.seriesGoals, c !== this.activeSeriesIndex || this.fallbackToCategory || (a.isXNumeric = !0); else {
                    if ("datetime" === s.xaxis.type) {
                        a.isXNumeric = !0;
                        {
                            h = void 0;
                            for (var h = 0; h < r.length; h++) if ("string" == typeof r[h]) {
                                if (!n.isValidDate(r[h])) throw new Error("You have provided invalid Date format. Please provide a valid JavaScript Date");
                                t.twoDSeriesX.push(n.parseDate(r[h]))
                            } else t.twoDSeriesX.push(r[h])
                        }
                        a.seriesX.push(this.twoDSeriesX)
                    } else "numeric" === s.xaxis.type && (a.isXNumeric = !0, 0 < r.length) && (this.twoDSeriesX = r, a.seriesX.push(this.twoDSeriesX));
                    a.labels.push(this.twoDSeriesX);
                    var d = e[c].data.map(function (e) {
                        return R.parseNumber(e)
                    });
                    a.series.push(d)
                }
                a.seriesZ.push(this.threeDSeries), void 0 !== e[c].color ? a.seriesColors.push(e[c].color) : a.seriesColors.push(void 0)
            }
            return this.w
        }
    }, {
        key: "parseDataNonAxisCharts", value: function (e) {
            var t = this.w.globals, i = this.w.config;
            t.series = e.slice(), t.seriesNames = i.labels.slice();
            for (var s = 0; s < t.series.length; s++) void 0 === t.seriesNames[s] && t.seriesNames.push("series-" + (s + 1));
            return this.w
        }
    }, {
        key: "handleExternalLabelsData", value: function (e) {
            var t = this.w.config, i = this.w.globals;
            0 < t.xaxis.categories.length ? i.labels = t.xaxis.categories : 0 < t.labels.length ? i.labels = t.labels.slice() : this.fallbackToCategory ? (i.labels = i.labels[0], i.seriesRange.length && (i.seriesRange.map(function (e) {
                e.forEach(function (e) {
                    i.labels.indexOf(e.x) < 0 && e.x && i.labels.push(e.x)
                })
            }), i.labels = Array.from(new Set(i.labels.map(JSON.stringify)), JSON.parse)), t.xaxis.convertedCatToNumeric && (new o(t).convertCatToNumericXaxis(t, this.ctx, i.seriesX[0]), this._generateExternalLabels(e))) : this._generateExternalLabels(e)
        }
    }, {
        key: "_generateExternalLabels", value: function (e) {
            var t = this.w.globals, i = this.w.config, s = [];
            if (t.axisCharts) {
                if (0 < t.series.length) if (this.isFormatXY()) for (var a = i.series.map(function (e, t) {
                    return e.data.filter(function (t, e, i) {
                        return i.findIndex(function (e) {
                            return e.x === t.x
                        }) === e
                    })
                }), n = a.reduce(function (e, t, i, s) {
                    return s[e].length > t.length ? e : i
                }, 0), r = 0; r < a[n].length; r++) s.push(r + 1); else for (var o = 0; o < t.series[t.maxValsInArrayIndex].length; o++) s.push(o + 1);
                t.seriesX = [];
                for (var l = 0; l < e.length; l++) t.seriesX.push(s);
                this.w.globals.isBarHorizontal || (t.isXNumeric = !0)
            }
            if (0 === s.length) for (var s = t.axisCharts ? [] : t.series.map(function (e, t) {
                return t + 1
            }), c = 0; c < e.length; c++) t.seriesX.push(s);
            t.labels = s, i.xaxis.convertedCatToNumeric && (t.categoryLabels = s.map(function (e) {
                return i.xaxis.labels.formatter(e)
            })), t.noLabelsProvided = !0
        }
    }, {
        key: "parseData", value: function (e) {
            var t = this.w, i = t.config, s = t.globals;
            this.excludeCollapsedSeriesInYAxis(), this.fallbackToCategory = !1, this.ctx.core.resetGlobals(), this.ctx.core.isMultipleY(), s.axisCharts ? (this.parseDataAxisCharts(e), this.coreUtils.getLargestSeries()) : this.parseDataNonAxisCharts(e), i.chart.stacked && (t = new T(this.ctx), s.series = t.setNullSeriesToZeroValues(s.series)), this.coreUtils.getSeriesTotals(), s.axisCharts && (s.stackedSeriesTotals = this.coreUtils.getStackedSeriesTotals(), s.stackedSeriesTotalsByGroups = this.coreUtils.getStackedSeriesTotalsByGroups()), this.coreUtils.getPercentSeries(), s.dataFormatXNumeric || s.isXNumeric && ("numeric" !== i.xaxis.type || 0 !== i.labels.length || 0 !== i.xaxis.categories.length) || this.handleExternalLabelsData(e);
            for (var a = this.coreUtils.getCategoryLabels(s.labels), n = 0; n < a.length; n++) if (Array.isArray(a[n])) {
                s.isMultiLineX = !0;
                break
            }
        }
    }, {
        key: "excludeCollapsedSeriesInYAxis", value: function () {
            var s = this.w, a = [];
            s.globals.seriesYAxisMap.forEach(function (e, t) {
                var i = 0;
                e.forEach(function (e) {
                    -1 !== s.globals.collapsedSeriesIndices.indexOf(e) && i++
                }), 0 < i && i == e.length && a.push(t)
            }), s.globals.ignoreYAxisIndexes = a.map(function (e) {
                return e
            })
        }
    }]), Bt), ye = (e(Wt, [{
        key: "scaleSvgNode", value: function (e, t) {
            var i = parseFloat(e.getAttributeNS(null, "width")), s = parseFloat(e.getAttributeNS(null, "height"));
            e.setAttributeNS(null, "width", i * t), e.setAttributeNS(null, "height", s * t), e.setAttributeNS(null, "viewBox", "0 0 " + i + " " + s)
        }
    }, {
        key: "getSvgString", value: function () {
            var n = this;
            return new Promise(function (e) {
                var t = n.w, i = t.config.chart.toolbar.export.width,
                    i = (i = t.config.chart.toolbar.export.scale || i / t.globals.svgWidth) || 1,
                    s = n.w.globals.dom.Paper.svg(), a = n.w.globals.dom.Paper.node.cloneNode(!0);
                1 !== i && n.scaleSvgNode(a, i), n.convertImagesToBase64(a).then(function () {
                    s = (new XMLSerializer).serializeToString(a), e(s.replace(/&nbsp;/g, "&#160;"))
                })
            })
        }
    }, {
        key: "convertImagesToBase64", value: function (e) {
            var i = this, e = e.getElementsByTagName("image"), e = Array.from(e).map(function (t) {
                var e = t.getAttributeNS("http://www.w3.org/1999/xlink", "href");
                return e && !e.startsWith("data:") ? i.getBase64FromUrl(e).then(function (e) {
                    t.setAttributeNS("http://www.w3.org/1999/xlink", "href", e)
                }).catch(function (e) {
                    console.error("Error converting image to base64:", e)
                }) : Promise.resolve()
            });
            return Promise.all(e)
        }
    }, {
        key: "getBase64FromUrl", value: function (s) {
            return new Promise(function (t, e) {
                var i = new Image;
                i.crossOrigin = "Anonymous", i.onload = function () {
                    var e = document.createElement("canvas");
                    e.width = i.width, e.height = i.height, e.getContext("2d").drawImage(i, 0, 0), t(e.toDataURL())
                }, i.onerror = e, i.src = s
            })
        }
    }, {
        key: "cleanup", value: function () {
            var e = this.w, t = e.globals.dom.baseEl.getElementsByClassName("apexcharts-xcrosshairs"),
                i = e.globals.dom.baseEl.getElementsByClassName("apexcharts-ycrosshairs"),
                e = e.globals.dom.baseEl.querySelectorAll(".apexcharts-zoom-rect, .apexcharts-selection-rect");
            Array.prototype.forEach.call(e, function (e) {
                e.setAttribute("width", 0)
            }), t && t[0] && (t[0].setAttribute("x", -500), t[0].setAttribute("x1", -500), t[0].setAttribute("x2", -500)), i && i[0] && (i[0].setAttribute("y", -100), i[0].setAttribute("y1", -100), i[0].setAttribute("y2", -100))
        }
    }, {
        key: "svgUrl", value: function () {
            var e = this;
            return new Promise(function (t) {
                e.cleanup(), e.getSvgString().then(function (e) {
                    e = new Blob([e], {type: "image/svg+xml;charset=utf-8"});
                    t(URL.createObjectURL(e))
                })
            })
        }
    }, {
        key: "dataURI", value: function (n) {
            var r = this;
            return new Promise(function (i) {
                var e = r.w, t = n ? n.scale || n.width / e.globals.svgWidth : 1,
                    s = (r.cleanup(), document.createElement("canvas")),
                    e = (s.width = e.globals.svgWidth * t, s.height = parseInt(e.globals.dom.elWrap.style.height, 10) * t, "transparent" !== e.config.chart.background && e.config.chart.background ? e.config.chart.background : "#fff"),
                    a = s.getContext("2d");
                a.fillStyle = e, a.fillRect(0, 0, s.width * t, s.height * t), r.getSvgString().then(function (e) {
                    var e = "data:image/svg+xml," + encodeURIComponent(e), t = new Image;
                    t.crossOrigin = "anonymous", t.onload = function () {
                        var e;
                        a.drawImage(t, 0, 0), s.msToBlob ? (e = s.msToBlob(), i({blob: e})) : (e = s.toDataURL("image/png"), i({imgURI: e}))
                    }, t.src = e
                })
            })
        }
    }, {
        key: "exportToSVG", value: function () {
            var t = this;
            this.svgUrl().then(function (e) {
                t.triggerDownload(e, t.w.config.chart.toolbar.export.svg.filename, ".svg")
            })
        }
    }, {
        key: "exportToPng", value: function () {
            var i = this, e = this.w.config.chart.toolbar.export.scale, t = this.w.config.chart.toolbar.export.width;
            this.dataURI(e ? {scale: e} : t ? {width: t} : void 0).then(function (e) {
                var t = e.imgURI, e = e.blob;
                e ? navigator.msSaveOrOpenBlob(e, i.w.globals.chartID + ".png") : i.triggerDownload(t, i.w.config.chart.toolbar.export.png.filename, ".png")
            })
        }
    }, {
        key: "exportToCSV", value: function (e) {
            var a, n, r = this, l = e.series, t = e.fileName, i = e.columnDelimiter, c = void 0 === i ? "," : i,
                i = e.lineDelimiter, e = void 0 === i ? "\n" : i, h = this.w, l = l || h.config.series, d = [], u = [],
                i = "", g = h.globals.series.map(function (e, t) {
                    return -1 === h.globals.collapsedSeriesIndices.indexOf(t) ? e : []
                }), p = function (e) {
                    return "function" == typeof h.config.chart.toolbar.export.csv.categoryFormatter ? h.config.chart.toolbar.export.csv.categoryFormatter(e) : "datetime" === h.config.xaxis.type && 10 <= String(e).length ? new Date(e).toDateString() : R.isNumber(e) ? e : e.split(c).join("")
                }, f = function (e) {
                    return "function" == typeof h.config.chart.toolbar.export.csv.valueFormatter ? h.config.chart.toolbar.export.csv.valueFormatter(e) : e
                }, x = Math.max.apply(Math, C(l.map(function (e) {
                    return e.data ? e.data.length : 0
                }))), m = new ve(this.ctx), o = new w(this.ctx), b = function (e) {
                    var t, i, s = "";
                    return h.globals.axisCharts ? ("category" !== h.config.xaxis.type && !h.config.xaxis.convertedCatToNumeric || (s = h.globals.isBarHorizontal ? (t = h.globals.yLabelFormatters[0], i = new T(r.ctx).getActiveConfigSeriesIndex(), t(h.globals.labels[e], {
                        seriesIndex: i,
                        dataPointIndex: e,
                        w: h
                    })) : o.getLabel(h.globals.labels, h.globals.timescaleLabels, 0, e).text), "datetime" === h.config.xaxis.type && (h.config.xaxis.categories.length ? s = h.config.xaxis.categories[e] : h.config.labels.length && (s = h.config.labels[e]))) : s = h.config.labels[e], null === s ? "nullvalue" : (Array.isArray(s) && (s = s.join(" ")), R.isNumber(s) ? s : s.split(c).join(""))
                };
            d.push(h.config.chart.toolbar.export.csv.headerCategory), "boxPlot" === h.config.chart.type ? (d.push("minimum"), d.push("q1"), d.push("median"), d.push("q3"), d.push("maximum")) : "candlestick" === h.config.chart.type ? (d.push("open"), d.push("high"), d.push("low"), d.push("close")) : "rangeBar" === h.config.chart.type ? (d.push("minimum"), d.push("maximum")) : l.map(function (e, t) {
                e = (e.name || "series-".concat(t)) + "";
                h.globals.axisCharts && d.push(e.split(c).join("") ? e.split(c).join("") : "series-".concat(t))
            }), h.globals.axisCharts || (d.push(h.config.chart.toolbar.export.csv.headerValue), u.push(d.join(c))), h.globals.allSeriesHasEqualX || !h.globals.axisCharts || h.config.xaxis.categories.length || h.config.labels.length ? l.map(function (e, t) {
                if (h.globals.axisCharts) {
                    var i = e, s = t;
                    if (d.length && 0 === s && u.push(d.join(c)), i.data) {
                        i.data = i.data.length && i.data || C(Array(x)).map(function () {
                            return ""
                        });
                        for (var a = 0; a < i.data.length; a++) {
                            d = [];
                            var n = b(a);
                            if ("nullvalue" !== n) {
                                if (n || (m.isFormatXY() ? n = l[s].data[a].x : m.isFormat2DArray() && (n = l[s].data[a] ? l[s].data[a][0] : "")), 0 === s) {
                                    d.push(p(n));
                                    for (var r = 0; r < h.globals.series.length; r++) {
                                        var o = m.isFormatXY() ? null == (o = l[r].data[a]) ? void 0 : o.y : g[r][a];
                                        d.push(f(o))
                                    }
                                }
                                ("candlestick" === h.config.chart.type || i.type && "candlestick" === i.type) && (d.pop(), d.push(h.globals.seriesCandleO[s][a]), d.push(h.globals.seriesCandleH[s][a]), d.push(h.globals.seriesCandleL[s][a]), d.push(h.globals.seriesCandleC[s][a])), ("boxPlot" === h.config.chart.type || i.type && "boxPlot" === i.type) && (d.pop(), d.push(h.globals.seriesCandleO[s][a]), d.push(h.globals.seriesCandleH[s][a]), d.push(h.globals.seriesCandleM[s][a]), d.push(h.globals.seriesCandleL[s][a]), d.push(h.globals.seriesCandleC[s][a])), "rangeBar" === h.config.chart.type && (d.pop(), d.push(h.globals.seriesRangeStart[s][a]), d.push(h.globals.seriesRangeEnd[s][a])), d.length && u.push(d.join(c))
                            }
                        }
                    }
                } else (d = []).push(p(h.globals.labels[t])), d.push(f(g[t])), u.push(d.join(c))
            }) : (a = new Set, n = {}, l.forEach(function (e, s) {
                null != e && e.data.forEach(function (e) {
                    var t, i;
                    if (m.isFormatXY()) t = e.x, i = e.y; else {
                        if (!m.isFormat2DArray()) return;
                        t = e[0], i = e[1]
                    }
                    n[t] || (n[t] = Array(l.length).fill("")), n[t][s] = f(i), a.add(t)
                })
            }), d.length && u.push(d.join(c)), Array.from(a).sort().forEach(function (e) {
                u.push([p(e), n[e].join(c)])
            })), i += u.join(e), this.triggerDownload("data:text/csv; charset=utf-8," + encodeURIComponent("\ufeff" + i), t || h.config.chart.toolbar.export.csv.filename, ".csv")
        }
    }, {
        key: "triggerDownload", value: function (e, t, i) {
            var s = document.createElement("a");
            s.href = e, s.download = (t || this.w.globals.chartID) + i, document.body.appendChild(s), s.click(), document.body.removeChild(s)
        }
    }]), Wt), g = (e(Yt, [{
        key: "drawXaxis", value: function () {
            var e = this.w, t = new Y(this.ctx), i = t.group({
                class: "apexcharts-xaxis",
                transform: "translate(".concat(e.config.xaxis.offsetX, ", ").concat(e.config.xaxis.offsetY, ")")
            }), s = t.group({
                class: "apexcharts-xaxis-texts-g",
                transform: "translate(".concat(e.globals.translateXAxisX, ", ").concat(e.globals.translateXAxisY, ")")
            });
            i.add(s);
            for (var a = [], n = 0; n < this.xaxisLabels.length; n++) a.push(this.xaxisLabels[n]);
            if (this.drawXAxisLabelAndGroup(!0, t, s, a, e.globals.isXNumeric, function (e, t) {
                return t
            }), e.globals.hasXaxisGroups) {
                for (var r = e.globals.groups, a = [], o = 0; o < r.length; o++) a.push(r[o].title);
                var l = {};
                e.config.xaxis.group.style && (l.xaxisFontSize = e.config.xaxis.group.style.fontSize, l.xaxisFontFamily = e.config.xaxis.group.style.fontFamily, l.xaxisForeColors = e.config.xaxis.group.style.colors, l.fontWeight = e.config.xaxis.group.style.fontWeight, l.cssClass = e.config.xaxis.group.style.cssClass), this.drawXAxisLabelAndGroup(!1, t, s, a, !1, function (e, t) {
                    return r[e].cols * t
                }, l)
            }
            return void 0 !== e.config.xaxis.title.text && (s = t.group({class: "apexcharts-xaxis-title"}), l = t.drawText({
                x: e.globals.gridWidth / 2 + e.config.xaxis.title.offsetX,
                y: this.offY + parseFloat(this.xaxisFontSize) + ("bottom" === e.config.xaxis.position ? e.globals.xAxisLabelsHeight : -e.globals.xAxisLabelsHeight - 10) + e.config.xaxis.title.offsetY,
                text: e.config.xaxis.title.text,
                textAnchor: "middle",
                fontSize: e.config.xaxis.title.style.fontSize,
                fontFamily: e.config.xaxis.title.style.fontFamily,
                fontWeight: e.config.xaxis.title.style.fontWeight,
                foreColor: e.config.xaxis.title.style.color,
                cssClass: "apexcharts-xaxis-title-text " + e.config.xaxis.title.style.cssClass
            }), s.add(l), i.add(s)), e.config.xaxis.axisBorder.show && (l = e.globals.barPadForNumericAxis, s = t.drawLine(e.globals.padHorizontal + e.config.xaxis.axisBorder.offsetX - l, this.offY, this.xaxisBorderWidth + l, this.offY, e.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight), (this.elgrid && this.elgrid.elGridBorders && e.config.grid.show ? this.elgrid.elGridBorders : i).add(s)), i
        }
    }, {
        key: "drawXAxisLabelAndGroup", value: function (a, n, r, o, e, l) {
            var c, h = this, t = 6 < arguments.length && void 0 !== arguments[6] ? arguments[6] : {}, d = [], u = [],
                g = this.w, p = t.xaxisFontSize || this.xaxisFontSize, f = t.xaxisFontFamily || this.xaxisFontFamily,
                x = t.xaxisForeColors || this.xaxisForeColors,
                m = t.fontWeight || g.config.xaxis.labels.style.fontWeight,
                b = t.cssClass || g.config.xaxis.labels.style.cssClass, v = g.globals.padHorizontal, y = o.length,
                w = "category" === g.config.xaxis.type ? g.globals.dataPoints : y;
            0 === w && w < y && (w = y), v = e ? (t = 1 < w ? w - 1 : w, c = g.globals.gridWidth / Math.min(t, y - 1), v + l(0, c) / 2 + g.config.xaxis.labels.offsetX) : (c = g.globals.gridWidth / w, v + l(0, c) + g.config.xaxis.labels.offsetX);
            for (var i = 0; i <= y - 1; i++) (i => {
                var e, t = v - l(i, c) / 2 + g.config.xaxis.labels.offsetX,
                    t = (0 === i && 1 === y && c / 2 === v && 1 === w && (t = g.globals.gridWidth / 2), h.axesUtils.getLabel(o, g.globals.timescaleLabels, t, i, d, p, a)),
                    s = 28;
                g.globals.rotateXLabels && a && (s = 22), g.config.xaxis.title.text && "top" === g.config.xaxis.position && (s += parseFloat(g.config.xaxis.title.style.fontSize) + 2), a || (s = s + parseFloat(p) + (g.globals.xAxisLabelsHeight - g.globals.xAxisGroupLabelsHeight) + (g.globals.rotateXLabels ? 10 : 0)), t = void 0 !== g.config.xaxis.tickAmount && "dataPoints" !== g.config.xaxis.tickAmount && "datetime" !== g.config.xaxis.type ? h.axesUtils.checkLabelBasedOnTickamount(i, t, y) : h.axesUtils.checkForOverflowingLabels(i, t, y, d, u), g.config.xaxis.labels.show && (s = n.drawText({
                    x: t.x,
                    y: h.offY + g.config.xaxis.labels.offsetY + s - ("top" === g.config.xaxis.position ? g.globals.xAxisHeight + g.config.xaxis.axisTicks.height - 2 : 0),
                    text: t.text,
                    textAnchor: "middle",
                    fontWeight: t.isBold ? 600 : m,
                    fontSize: p,
                    fontFamily: f,
                    foreColor: Array.isArray(x) ? a && g.config.xaxis.convertedCatToNumeric ? x[g.globals.minX + i - 1] : x[i] : x,
                    isPlainText: !1,
                    cssClass: (a ? "apexcharts-xaxis-label " : "apexcharts-xaxis-group-label ") + b
                }), r.add(s), s.on("click", function (e) {
                    var t;
                    "function" == typeof g.config.chart.events.xAxisLabelClick && (t = Object.assign({}, g, {labelIndex: i}), g.config.chart.events.xAxisLabelClick(e, h.ctx, t))
                }), a) && ((e = document.createElementNS(g.globals.SVGNS, "title")).textContent = Array.isArray(t.text) ? t.text.join(" ") : t.text, s.node.appendChild(e), "" !== t.text) && (d.push(t.text), u.push(t)), i < y - 1 && (v += l(i + 1, c))
            })(i)
        }
    }, {
        key: "drawXaxisInversed", value: function (r) {
            var o = this, l = this.w, c = new Y(this.ctx),
                e = l.config.yaxis[0].opposite ? l.globals.translateYAxisX[r] : 0,
                t = c.group({class: "apexcharts-yaxis apexcharts-xaxis-inversed", rel: r}), h = c.group({
                    class: "apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g",
                    transform: "translate(" + e + ", 0)"
                }), d = (t.add(h), []);
            if (l.config.yaxis[r].show) for (var i = 0; i < this.xaxisLabels.length; i++) d.push(this.xaxisLabels[i]);
            var u, g = -(u = l.globals.gridHeight / d.length) / 2.2, p = l.globals.yLabelFormatters[0],
                f = l.config.yaxis[0].labels;
            if (f.show) for (var s = 0; s <= d.length - 1; s++) (i => {
                var e = void 0 === d[i] ? "" : d[i], e = p(e, {seriesIndex: r, dataPointIndex: i, w: l}),
                    t = o.axesUtils.getYAxisForeColor(f.style.colors, r), s = 0,
                    a = (Array.isArray(e) && (s = e.length / 2 * parseInt(f.style.fontSize, 10)), f.offsetX - 15),
                    n = "end",
                    a = (o.yaxis.opposite && (n = "start"), "left" === l.config.yaxis[0].labels.align ? (a = f.offsetX, n = "start") : "center" === l.config.yaxis[0].labels.align ? (a = f.offsetX, n = "middle") : "right" === l.config.yaxis[0].labels.align && (n = "end"), c.drawText({
                        x: a,
                        y: g + u + f.offsetY - s,
                        text: e,
                        textAnchor: n,
                        foreColor: Array.isArray(t) ? t[i] : t,
                        fontSize: f.style.fontSize,
                        fontFamily: f.style.fontFamily,
                        fontWeight: f.style.fontWeight,
                        isPlainText: !1,
                        cssClass: "apexcharts-yaxis-label " + f.style.cssClass,
                        maxWidth: f.maxWidth
                    }));
                h.add(a), a.on("click", function (e) {
                    var t;
                    "function" == typeof l.config.chart.events.xAxisLabelClick && (t = Object.assign({}, l, {labelIndex: i}), l.config.chart.events.xAxisLabelClick(e, o.ctx, t))
                }), (s = document.createElementNS(l.globals.SVGNS, "title")).textContent = Array.isArray(e) ? e.join(" ") : e, a.node.appendChild(s), 0 !== l.config.yaxis[r].labels.rotate && (n = c.rotateAroundCenter(a.node), a.node.setAttribute("transform", "rotate(".concat(l.config.yaxis[r].labels.rotate, " 0 ").concat(n.y, ")"))), g += u
            })(s);
            void 0 !== l.config.yaxis[0].title.text && (e = c.group({
                class: "apexcharts-yaxis-title apexcharts-xaxis-title-inversed",
                transform: "translate(" + e + ", 0)"
            }), a = c.drawText({
                x: l.config.yaxis[0].title.offsetX,
                y: l.globals.gridHeight / 2 + l.config.yaxis[0].title.offsetY,
                text: l.config.yaxis[0].title.text,
                textAnchor: "middle",
                foreColor: l.config.yaxis[0].title.style.color,
                fontSize: l.config.yaxis[0].title.style.fontSize,
                fontWeight: l.config.yaxis[0].title.style.fontWeight,
                fontFamily: l.config.yaxis[0].title.style.fontFamily,
                cssClass: "apexcharts-yaxis-title-text " + l.config.yaxis[0].title.style.cssClass
            }), e.add(a), t.add(e));
            var a = 0,
                e = (this.isCategoryBarHorizontal && l.config.yaxis[0].opposite && (a = l.globals.gridWidth), l.config.xaxis.axisBorder);
            return e.show && (e = c.drawLine(l.globals.padHorizontal + e.offsetX + a, 1 + e.offsetY, l.globals.padHorizontal + e.offsetX + a, l.globals.gridHeight + e.offsetY, e.color, 0), (this.elgrid && this.elgrid.elGridBorders && l.config.grid.show ? this.elgrid.elGridBorders : t).add(e)), l.config.yaxis[0].axisTicks.show && this.axesUtils.drawYAxisTicks(a, d.length, l.config.yaxis[0].axisBorder, l.config.yaxis[0].axisTicks, 0, u, t), t
        }
    }, {
        key: "drawXaxisTicks", value: function (e, t, i) {
            var s, a = this.w, n = e;
            e < 0 || e - 2 > a.globals.gridWidth || (t = t + (s = this.offY + a.config.xaxis.axisTicks.offsetY) + a.config.xaxis.axisTicks.height, "top" === a.config.xaxis.position && (t = s - a.config.xaxis.axisTicks.height), a.config.xaxis.axisTicks.show && (e = new Y(this.ctx).drawLine(e + a.config.xaxis.axisTicks.offsetX, s + a.config.xaxis.offsetY, n + a.config.xaxis.axisTicks.offsetX, t + a.config.xaxis.offsetY, a.config.xaxis.axisTicks.color), i.add(e), e.node.classList.add("apexcharts-xaxis-tick")))
        }
    }, {
        key: "getXAxisTicksPositions", value: function () {
            var e = this.w, t = [], i = this.xaxisLabels.length, s = e.globals.padHorizontal;
            if (0 < e.globals.timescaleLabels.length) for (var a = 0; a < i; a++) s = this.xaxisLabels[a].position, t.push(s); else for (var n = i, r = 0; r < n; r++) {
                var o = n;
                e.globals.isXNumeric && "bar" !== e.config.chart.type && --o, s += e.globals.gridWidth / o, t.push(s)
            }
            return t
        }
    }, {
        key: "xAxisLabelCorrections", value: function () {
            var t = this.w, i = new Y(this.ctx), e = t.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g"),
                s = t.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-texts-g text:not(.apexcharts-xaxis-group-label)"),
                a = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-inversed text"),
                n = t.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-inversed-texts-g text tspan");
            if (t.globals.rotateXLabels || t.config.xaxis.labels.rotateAlways) for (var r = 0; r < s.length; r++) {
                var o = i.rotateAroundCenter(s[r]),
                    o = (o.y = o.y - 1, o.x = o.x + 1, s[r].setAttribute("transform", "rotate(".concat(t.config.xaxis.labels.rotate, " ").concat(o.x, " ").concat(o.y, ")")), s[r].setAttribute("text-anchor", "end"), e.setAttribute("transform", "translate(0, ".concat(-10, ")")), s[r].childNodes);
                t.config.xaxis.labels.trim && Array.prototype.forEach.call(o, function (e) {
                    i.placeTextWithEllipsis(e, e.textContent, t.globals.xAxisLabelsHeight - ("bottom" === t.config.legend.position ? 20 : 10))
                })
            } else for (var l = t.globals.gridWidth / (t.globals.labels.length + 1), c = 0; c < s.length; c++) {
                var h = s[c].childNodes;
                t.config.xaxis.labels.trim && "datetime" !== t.config.xaxis.type && Array.prototype.forEach.call(h, function (e) {
                    i.placeTextWithEllipsis(e, e.textContent, l)
                })
            }
            if (0 < a.length) {
                var d = a[a.length - 1].getBBox(), u = a[0].getBBox();
                d.x < -20 && a[a.length - 1].parentNode.removeChild(a[a.length - 1]), u.x + u.width > t.globals.gridWidth && !t.globals.isBarHorizontal && a[0].parentNode.removeChild(a[0]);
                for (var g = 0; g < n.length; g++) i.placeTextWithEllipsis(n[g], n[g].textContent, t.config.yaxis[0].labels.maxWidth - (t.config.yaxis[0].title.text ? 2 * parseFloat(t.config.yaxis[0].title.style.fontSize) : 0) - 15)
            }
        }
    }]), Yt), we = (e(Rt, [{
        key: "drawGridArea", value: function () {
            var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : null, t = this.w,
                i = new Y(this.ctx),
                s = (null === e && (e = i.group({class: "apexcharts-grid"})), i.drawLine(t.globals.padHorizontal, 1, t.globals.padHorizontal, t.globals.gridHeight, "transparent")),
                i = i.drawLine(t.globals.padHorizontal, t.globals.gridHeight, t.globals.gridWidth, t.globals.gridHeight, "transparent");
            return e.add(i), e.add(s), e
        }
    }, {
        key: "drawGrid", value: function () {
            var e = null;
            return this.w.globals.axisCharts && (e = this.renderGrid(), this.drawGridArea(e.el)), e
        }
    }, {
        key: "createGridMask", value: function () {
            var t, e = this.w, i = e.globals, s = new Y(this.ctx),
                a = Array.isArray(e.config.stroke.width) ? 0 : e.config.stroke.width,
                n = (Array.isArray(e.config.stroke.width) && (t = 0, e.config.stroke.width.forEach(function (e) {
                    t = Math.max(t, e)
                }), a = t), i.dom.elGridRectMask = document.createElementNS(i.SVGNS, "clipPath"), i.dom.elGridRectMask.setAttribute("id", "gridRectMask".concat(i.cuid)), i.dom.elGridRectMarkerMask = document.createElementNS(i.SVGNS, "clipPath"), i.dom.elGridRectMarkerMask.setAttribute("id", "gridRectMarkerMask".concat(i.cuid)), i.dom.elForecastMask = document.createElementNS(i.SVGNS, "clipPath"), i.dom.elForecastMask.setAttribute("id", "forecastMask".concat(i.cuid)), i.dom.elNonForecastMask = document.createElementNS(i.SVGNS, "clipPath"), i.dom.elNonForecastMask.setAttribute("id", "nonForecastMask".concat(i.cuid)), e.config.chart.type),
                r = 0, o = 0,
                n = (("bar" === n || "rangeBar" === n || "candlestick" === n || "boxPlot" === n || 0 < e.globals.comboBarCount) && e.globals.isXNumeric && !e.globals.isBarHorizontal && (r = e.config.grid.padding.left, o = e.config.grid.padding.right, i.barPadForNumericAxis > r) && (r = i.barPadForNumericAxis, o = i.barPadForNumericAxis), i.dom.elGridRect = s.drawRect(-a / 2 - r - 2, -a / 2 - 2, i.gridWidth + a + o + r + 4, i.gridHeight + a + 4, 0, "#fff"), e.globals.markers.largestSize + 1),
                o = (i.dom.elGridRectMarker = s.drawRect(2 * -n, 2 * -n, i.gridWidth + 4 * n, i.gridHeight + 4 * n, 0, "#fff"), i.dom.elGridRectMask.appendChild(i.dom.elGridRect.node), i.dom.elGridRectMarkerMask.appendChild(i.dom.elGridRectMarker.node), i.dom.baseEl.querySelector("defs"));
            o.appendChild(i.dom.elGridRectMask), o.appendChild(i.dom.elForecastMask), o.appendChild(i.dom.elNonForecastMask), o.appendChild(i.dom.elGridRectMarkerMask)
        }
    }, {
        key: "_drawGridLines", value: function (e) {
            var t = e.i, i = e.x1, s = e.xCount, a = this.w;
            if (!(0 === t && a.globals.skipFirstTimelinelabel || t === s - 1 && a.globals.skipLastTimelinelabel && !a.config.xaxis.labels.formatter || "radar" === a.config.chart.type)) {
                a.config.grid.xaxis.lines.show && this._drawGridLine({
                    i: t,
                    x1: i,
                    y1: e.y1,
                    x2: e.x2,
                    y2: e.y2,
                    xCount: s,
                    parent: e.parent
                });
                s = 0;
                if (a.globals.hasXaxisGroups && "between" === a.config.xaxis.tickPlacement) {
                    var n = a.globals.groups;
                    if (n) {
                        for (var r = 0, o = 0; r < t && o < n.length; o++) r += n[o].cols;
                        r === t && (s = .6 * a.globals.xAxisLabelsHeight)
                    }
                }
                new g(this.ctx).drawXaxisTicks(i, s, a.globals.dom.elGraphical)
            }
        }
    }, {
        key: "_drawGridLine", value: function (e) {
            var t = e.i, i = e.x1, s = e.y1, a = e.x2, n = e.y2, r = e.xCount, e = e.parent, o = this.w, l = !1,
                c = e.node.classList.contains("apexcharts-gridlines-horizontal"), h = o.config.grid.strokeDashArray,
                d = o.globals.barPadForNumericAxis,
                t = ((0 === s && 0 === n || 0 === i && 0 === a) && (l = !0), s === o.globals.gridHeight && n === o.globals.gridHeight && (l = !0), !o.globals.isBarHorizontal || 0 !== t && t !== r - 1 || (l = !0), new Y(this).drawLine(i - (c ? d : 0), s, a + (c ? d : 0), n, o.config.grid.borderColor, h));
            t.node.classList.add("apexcharts-gridline"), (l && o.config.grid.show ? this.elGridBorders : e).add(t)
        }
    }, {
        key: "_drawGridBandRect", value: function (e) {
            var t = e.c, i = e.x1, s = e.y1, a = e.x2, n = e.y2, e = e.type, r = this.w, o = new Y(this.ctx),
                l = r.globals.barPadForNumericAxis, t = r.config.grid[e].colors[t],
                o = o.drawRect(i - ("row" === e ? l : 0), s, a + ("row" === e ? 2 * l : 0), n, 0, t, r.config.grid[e].opacity);
            this.elg.add(o), o.attr("clip-path", "url(#gridRectMask".concat(r.globals.cuid, ")")), o.node.classList.add("apexcharts-grid-".concat(e))
        }
    }, {
        key: "_drawXYLines", value: function (e) {
            var t, o = this, l = e.xCount, i = e.tickAmount, c = this.w;
            if ((c.config.grid.xaxis.lines.show || c.config.xaxis.axisTicks.show) && (e = c.globals.padHorizontal, t = c.globals.gridHeight, (c.globals.timescaleLabels.length ? e => {
                for (var t, i, s = e.xC, a = e.y1, n = e.y2, r = 0; r < s; r++) t = o.xaxisLabels[r].position, i = o.xaxisLabels[r].position, o._drawGridLines({
                    i: r,
                    x1: t,
                    y1: a,
                    x2: i,
                    y2: n,
                    xCount: l,
                    parent: o.elgridLinesV
                })
            } : (c.globals.isXNumeric && (l = c.globals.xAxisScale.result.length), e => {
                for (var t = e.xC, i = e.x1, s = e.y1, a = e.x2, n = e.y2, r = 0; r < t + (c.globals.isXNumeric ? 0 : 1); r++) 0 === r && 1 === t && 1 === c.globals.dataPoints && (a = i = c.globals.gridWidth / 2), o._drawGridLines({
                    i: r,
                    x1: i,
                    y1: s,
                    x2: a,
                    y2: n,
                    xCount: l,
                    parent: o.elgridLinesV
                }), a = i += c.globals.gridWidth / (c.globals.isXNumeric ? t - 1 : t)
            }))({xC: l, x1: e, y1: 0, x2: void 0, y2: t})), c.config.grid.yaxis.lines.show) {
                var s = 0, a = 0, n = c.globals.gridWidth, r = i + 1;
                this.isRangeBar && (r = c.globals.labels.length);
                for (var h = 0; h < r + (this.isRangeBar ? 1 : 0); h++) this._drawGridLine({
                    i: h,
                    xCount: r + (this.isRangeBar ? 1 : 0),
                    x1: 0,
                    y1: s,
                    x2: n,
                    y2: a,
                    parent: this.elgridLinesH
                }), a = s += c.globals.gridHeight / (this.isRangeBar ? r : i)
            }
        }
    }, {
        key: "_drawInvertedXYLines", value: function (e) {
            var t = e.xCount, i = this.w;
            if (i.config.grid.xaxis.lines.show || i.config.xaxis.axisTicks.show) for (var s, a = i.globals.padHorizontal, n = i.globals.gridHeight, r = 0; r < t + 1; r++) i.config.grid.xaxis.lines.show && this._drawGridLine({
                i: r,
                xCount: t + 1,
                x1: a,
                y1: 0,
                x2: s,
                y2: n,
                parent: this.elgridLinesV
            }), new g(this.ctx).drawXaxisTicks(a, 0, i.globals.dom.elGraphical), s = a += i.globals.gridWidth / t;
            if (i.config.grid.yaxis.lines.show) for (var o = 0, l = 0, c = i.globals.gridWidth, h = 0; h < i.globals.dataPoints + 1; h++) this._drawGridLine({
                i: h,
                xCount: i.globals.dataPoints + 1,
                x1: 0,
                y1: o,
                x2: c,
                y2: l,
                parent: this.elgridLinesH
            }), l = o += i.globals.gridHeight / i.globals.dataPoints
        }
    }, {
        key: "renderGrid", value: function () {
            var e = this.w, t = e.globals, i = new Y(this.ctx);
            this.elg = i.group({class: "apexcharts-grid"}), this.elgridLinesH = i.group({class: "apexcharts-gridlines-horizontal"}), this.elgridLinesV = i.group({class: "apexcharts-gridlines-vertical"}), this.elGridBorders = i.group({class: "apexcharts-grid-borders"}), this.elg.add(this.elgridLinesH), this.elg.add(this.elgridLinesV), e.config.grid.show || (this.elgridLinesV.hide(), this.elgridLinesH.hide(), this.elGridBorders.hide());
            for (var s = 0; s < t.seriesYAxisMap.length && -1 !== t.ignoreYAxisIndexes.indexOf(s);) s++;
            s === t.seriesYAxisMap.length && (s = 0);
            var a, n, i = t.yAxisScale[s].result.length - 1;
            return !t.isBarHorizontal || this.isRangeBar ? (n = this.xaxisLabels.length, this.isRangeBar && (i = t.labels.length, e.config.xaxis.tickAmount && e.config.xaxis.labels.formatter && (n = e.config.xaxis.tickAmount), 0 < (null == (a = t.yAxisScale) || null == (a = a[s]) || null == (a = a.result) ? void 0 : a.length)) && "datetime" !== e.config.xaxis.type && (n = t.yAxisScale[s].result.length - 1), this._drawXYLines({
                xCount: n,
                tickAmount: i
            })) : (n = i, i = t.xTickAmount, this._drawInvertedXYLines({
                xCount: n,
                tickAmount: i
            })), this.drawGridBands(n, i), {
                el: this.elg,
                elGridBorders: this.elGridBorders,
                xAxisTickWidth: t.gridWidth / n
            }
        }
    }, {
        key: "drawGridBands", value: function (e, t) {
            var i = this.w;
            if (void 0 !== i.config.grid.row.colors && 0 < i.config.grid.row.colors.length) for (var s = 0, a = i.globals.gridHeight / t, n = i.globals.gridWidth, r = 0, o = 0; r < t; r++, o++) o >= i.config.grid.row.colors.length && (o = 0), this._drawGridBandRect({
                c: o,
                x1: 0,
                y1: s,
                x2: n,
                y2: a,
                type: "row"
            }), s += i.globals.gridHeight / t;
            if (void 0 !== i.config.grid.column.colors && 0 < i.config.grid.column.colors.length) {
                var l = i.globals.isBarHorizontal || "on" !== i.config.xaxis.tickPlacement || "category" !== i.config.xaxis.type && !i.config.xaxis.convertedCatToNumeric ? e : e - 1;
                i.globals.isXNumeric && (l = i.globals.xAxisScale.result.length - 1);
                for (var c, h = i.globals.padHorizontal, d = i.globals.padHorizontal + i.globals.gridWidth / l, u = i.globals.gridHeight, g = 0, p = 0; g < e; g++, p++) p >= i.config.grid.column.colors.length && (p = 0), "datetime" === i.config.xaxis.type && (h = this.xaxisLabels[g].position, d = ((null == (c = this.xaxisLabels[g + 1]) ? void 0 : c.position) || i.globals.gridWidth) - this.xaxisLabels[g].position), this._drawGridBandRect({
                    c: p,
                    x1: h,
                    y1: 0,
                    x2: d,
                    y2: u,
                    type: "column"
                }), h += i.globals.gridWidth / l
            }
        }
    }]), Rt), ke = (e(Ht, [{
        key: "niceScale", value: function (e, t) {
            var i, s = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0, a = this.w, n = a.globals,
                r = n.isBarHorizontal ? (i = a.config.xaxis, Math.max((n.svgWidth - 100) / 25, 2)) : (i = a.config.yaxis[s], Math.max((n.svgHeight - 100) / 15, 2)),
                a = (R.isNumber(r) || (r = 10), null != i.min), o = void 0 !== i.max && null !== i.min,
                l = null != i.stepSize, c = null != i.tickAmount,
                h = c ? i.tickAmount : n.niceScaleDefaultTicks[Math.min(Math.round(r / 2), n.niceScaleDefaultTicks.length - 1)],
                d = (n.isMultipleYAxis && !c && 0 < n.multiAxisTickAmount && (h = n.multiAxisTickAmount, c = !0), h = "dataPoints" === h ? n.dataPoints - 1 : Math.abs(Math.round(h)), (e === Number.MIN_VALUE && 0 === t || !R.isNumber(e) && !R.isNumber(t) || e === Number.MIN_VALUE && t === -Number.MAX_VALUE) && (e = R.isNumber(i.min) ? i.min : 0, t = R.isNumber(i.max) ? i.max : e + h, n.allSeriesCollapsed = !1), t < e ? (console.warn("axis.min cannot be greater than axis.max: swapping min and max"), u = t, t = e, e = u) : e === t && (e = 0 === e ? 0 : e - 1, t = 0 === t ? 2 : t + 1), []),
                u = h = h < 1 ? 1 : h, g = Math.abs(t - e);
            !a && 0 < e && e / g < .15 && (a = !(e = 0)), !o && t < 0 && -t / g < .15 && (o = !(t = 0));
            var p = m = (g = Math.abs(t - e)) / u, f = Math.floor(Math.log10(p)), x = Math.pow(10, f),
                p = Math.ceil(p / x), m = n.niceScaleAllowedMagMsd[0 === n.yValueDecimal ? 0 : 1][p] * x;
            if (n.isBarHorizontal && i.stepSize && "datetime" !== i.type ? (m = i.stepSize, l = !0) : l && (m = i.stepSize), l && i.forceNiceScale && (p = Math.floor(Math.log10(m)), m *= Math.pow(10, f - p)), u = (a && o ? (x = g / u, c ? l ? 0 != R.mod(g, m) ? m = x / (f = R.getGCD(m, x)) < 10 ? f : x : 0 == R.mod(m, x) ? m = x : (x = m, c = !1) : m = x : l ? 0 == R.mod(g, m) ? x = m : m = x : 0 == R.mod(g, m) ? x = m : (x = g / (u = Math.ceil(g / m)), m = x = g / (p = R.getGCD(g, m)) < r ? p : x)) : (a || o ? o ? c ? e = t - m * u : (f = e, e = m * Math.floor(e / m), Math.abs(t - e) / R.getGCD(g, m) > r && (e = t - m * h, e += m * Math.floor((f - e) / m))) : a && (c ? t = e + m * u : (p = t, t = m * Math.ceil(t / m), Math.abs(t - e) / R.getGCD(g, m) > r && (t = e + m * h, t += m * Math.ceil((p - t) / m)))) : n.isMultipleYAxis && c ? ((x = m * Math.floor(e / m)) + m * u < t && (m *= 2), f = t, t = (e = x) + m * u, g = Math.abs(t - e), 0 < e && e < Math.abs(f - t) && (e = 0, t = m * u), t < 0 && -t < Math.abs(x - e) && (t = 0, e = -m * u)) : (e = m * Math.floor(e / m), t = m * Math.ceil(t / m)), g = Math.abs(t - e), m = R.getGCD(g, m)), Math.round(g / m)), c || a || o || 16 < (u = Math.ceil((g - 1e-11) / (m + 1e-11))) && R.getPrimeFactors(u).length < 2 && u++, !c && i.forceNiceScale && 0 === n.yValueDecimal && g < u && (u = g, m = Math.round(g / u)), r < u && (!c && !l || i.forceNiceScale)) {
                var b = R.getPrimeFactors(u), v = b.length - 1, y = u;
                e:for (var w = 0; w < v; w++) for (var k = 0; k <= v - w; k++) {
                    for (var A = Math.min(k + w, v), C = y, S = 1, L = k; L <= A; L++) S *= b[L];
                    if ((C /= S) < r) {
                        y = C;
                        break e
                    }
                }
                m = y === u ? g : g / y, u = Math.round(g / m)
            }
            n.isMultipleYAxis && 0 == n.multiAxisTickAmount && n.ignoreYAxisIndexes.indexOf(s) < 0 && (n.multiAxisTickAmount = u);
            for (var T = e - m, E = 1e-11 * m; d.push(R.stripNumber(T += m, 7)), E < t - T;) ;
            return {result: d, niceMin: d[0], niceMax: d[d.length - 1]}
        }
    }, {
        key: "linearScale", value: function (e, t) {
            var i = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 10,
                s = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0,
                a = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : void 0, n = Math.abs(t - e),
                r = [];
            if (e === t) return {result: r = [e], niceMin: r[0], niceMax: r[r.length - 1]};
            "dataPoints" === (i = this._adjustTicksForSmallRange(i, s, n)) && (i = this.w.globals.dataPoints - 1), a = a || n / i, a = Math.round(10 * (a + Number.EPSILON)) / 10, i === Number.MAX_VALUE && (i = 5, a = 1);
            for (var o = e; 0 <= i;) r.push(o), o = R.preciseAddition(o, a), --i;
            return {result: r, niceMin: r[0], niceMax: r[r.length - 1]}
        }
    }, {
        key: "logarithmicScaleNice", value: function (e, t, i) {
            t <= 0 && (t = Math.max(e, i)), e <= 0 && (e = Math.min(t, i));
            for (var s = [], a = Math.ceil(Math.log(t) / Math.log(i) + 1), n = Math.floor(Math.log(e) / Math.log(i)); n < a; n++) s.push(Math.pow(i, n));
            return {result: s, niceMin: s[0], niceMax: s[s.length - 1]}
        }
    }, {
        key: "logarithmicScale", value: function (e, t, i) {
            t <= 0 && (t = Math.max(e, i)), e <= 0 && (e = Math.min(t, i));
            for (var s = [], a = Math.log(t) / Math.log(i), n = Math.log(e) / Math.log(i), r = a - n, o = Math.round(r), l = r / o, c = 0, h = n; c < o; c++, h += l) s.push(Math.pow(i, h));
            return s.push(Math.pow(i, a)), {result: s, niceMin: e, niceMax: t}
        }
    }, {
        key: "_adjustTicksForSmallRange", value: function (e, t, i) {
            var s = e;
            return (s = void 0 !== t && this.w.config.yaxis[t].labels.formatter && void 0 === this.w.config.yaxis[t].tickAmount && (t = Number(this.w.config.yaxis[t].labels.formatter(1)), R.isNumber(t)) && 0 === this.w.globals.yValueDecimal ? Math.ceil(i) : s) < e ? s : e
        }
    }, {
        key: "setYScaleForIndex", value: function (e, t, i) {
            var s = this.w.globals, a = this.w.config, a = s.isBarHorizontal ? a.xaxis : a.yaxis[e],
                n = (void 0 === s.yAxisScale[e] && (s.yAxisScale[e] = []), Math.abs(i - t));
            a.logarithmic && n <= 5 && (s.invalidLogScale = !0), a.logarithmic && 5 < n ? (s.allSeriesCollapsed = !1, s.yAxisScale[e] = a.forceNiceScale ? this.logarithmicScaleNice(t, i, a.logBase) : this.logarithmicScale(t, i, a.logBase)) : i !== -Number.MAX_VALUE && R.isNumber(i) && t !== Number.MAX_VALUE && R.isNumber(t) ? (s.allSeriesCollapsed = !1, s.yAxisScale[e] = this.niceScale(t, i, e)) : s.yAxisScale[e] = this.niceScale(Number.MIN_VALUE, 0, e)
        }
    }, {
        key: "setXScale", value: function (e, t) {
            var i, s = this.w, a = s.globals, n = Math.abs(t - e);
            return t !== -Number.MAX_VALUE && R.isNumber(t) ? (i = a.xTickAmount + 1, a.xAxisScale = this.linearScale(e, t, i = n < 10 && 1 < n ? n : i, 0, s.config.xaxis.stepSize)) : a.xAxisScale = this.linearScale(0, 10, 10), a.xAxisScale
        }
    }, {
        key: "setSeriesYAxisMappings", value: function () {
            var e = this.w.globals, i = this.w.config, r = [], s = [], o = [],
                l = e.series.length > i.yaxis.length || i.yaxis.some(function (e) {
                    return Array.isArray(e.seriesName)
                }), c = (i.series.forEach(function (e, t) {
                    o.push(t), s.push(null)
                }), i.yaxis.forEach(function (e, t) {
                    r[t] = []
                }), []);
            i.yaxis.forEach(function (e, a) {
                var t, n = !1;
                e.seriesName && (t = [], Array.isArray(e.seriesName) ? t = e.seriesName : t.push(e.seriesName), t.forEach(function (s) {
                    i.series.forEach(function (e, t) {
                        var i;
                        e.name === s && (a === (i = t) || l ? !l || -1 < o.indexOf(t) ? r[a].push([a, t]) : console.warn("Series '" + e.name + "' referenced more than once in what looks like the new style. That is, when using either seriesName: [], or when there are more series than yaxes.") : (r[t].push([t, a]), i = a), n = !0, -1 !== (i = o.indexOf(i))) && o.splice(i, 1)
                    })
                })), n || c.push(a)
            });
            for (var r = r.map(function (e, t) {
                var i = [];
                return e.forEach(function (e) {
                    s[e[1]] = e[0], i.push(e[1])
                }), i
            }), t = i.yaxis.length - 1, a = 0; a < c.length && (r[t = c[a]] = [], o); a++) {
                var n = o[0];
                o.shift(), r[t].push(n), s[n] = t
            }
            o.forEach(function (e) {
                r[t].push(e), s[e] = t
            }), e.seriesYAxisMap = r.map(function (e) {
                return e
            }), e.seriesYAxisReverseMap = s.map(function (e) {
                return e
            })
        }
    }, {
        key: "scaleMultipleYAxes", value: function () {
            var x = this, m = this.w.config, b = this.w.globals, e = (this.setSeriesYAxisMappings(), b.seriesYAxisMap),
                v = b.minYArr, y = b.maxYArr;
            b.allSeriesCollapsed = !0, b.barGroups = [], e.forEach(function (t, i) {
                var s = [];
                if (t.forEach(function (e) {
                    e = m.series[e].group;
                    s.indexOf(e) < 0 && s.push(e)
                }), 0 < t.length) {
                    var n, r, o = p = Number.MAX_VALUE, l = f = -Number.MAX_VALUE;
                    if (m.chart.stacked) {
                        var e = b.seriesX[t[0]], c = [], h = [], d = [];
                        s.forEach(function () {
                            c.push(e.map(function () {
                                return Number.MIN_VALUE
                            })), h.push(e.map(function () {
                                return Number.MIN_VALUE
                            })), d.push(e.map(function () {
                                return Number.MIN_VALUE
                            }))
                        });
                        for (var a = 0; a < t.length; a++) (e => {
                            !n && m.series[t[e]].type && (n = m.series[t[e]].type);
                            var a = t[e];
                            r = m.series[a].group || "axis-".concat(i), b.collapsedSeriesIndices.indexOf(a) < 0 && b.ancillaryCollapsedSeriesIndices.indexOf(a) < 0 && (b.allSeriesCollapsed = !1, s.forEach(function (e, t) {
                                if (m.series[a].group === e) for (var i = 0; i < b.series[a].length; i++) {
                                    var s = b.series[a][i];
                                    0 <= s ? h[t][i] += s : d[t][i] += s, c[t][i] += s, o = Math.min(o, s), l = Math.max(l, s)
                                }
                            })), "bar" !== n && "column" !== n || b.barGroups.push(r)
                        })(a);
                        "bar" === (n = n || m.chart.type) || "column" === n ? s.forEach(function (e, t) {
                            p = Math.min(p, Math.min.apply(null, d[t])), f = Math.max(f, Math.max.apply(null, h[t]))
                        }) : (s.forEach(function (e, t) {
                            o = Math.min(o, Math.min.apply(null, c[t])), l = Math.max(l, Math.max.apply(null, c[t]))
                        }), p = o, f = l), p === Number.MIN_VALUE && f === Number.MIN_VALUE && (f = -Number.MAX_VALUE)
                    } else for (var u = 0; u < t.length; u++) {
                        var g = t[u], p = Math.min(p, v[g]), f = Math.max(f, y[g]);
                        b.collapsedSeriesIndices.indexOf(g) < 0 && b.ancillaryCollapsedSeriesIndices.indexOf(g) < 0 && (b.allSeriesCollapsed = !1)
                    }
                    void 0 !== m.yaxis[i].min && (p = "function" == typeof m.yaxis[i].min ? m.yaxis[i].min(p) : m.yaxis[i].min), void 0 !== m.yaxis[i].max && (f = "function" == typeof m.yaxis[i].max ? m.yaxis[i].max(f) : m.yaxis[i].max), b.barGroups = b.barGroups.filter(function (e, t, i) {
                        return i.indexOf(e) === t
                    }), x.setYScaleForIndex(i, p, f), t.forEach(function (e) {
                        v[e] = b.yAxisScale[i].niceMin, y[e] = b.yAxisScale[i].niceMax
                    })
                } else x.setYScaleForIndex(i, 0, -Number.MAX_VALUE)
            })
        }
    }]), Ht), Ae = (e(Ft, [{
        key: "init", value: function () {
            this.setYRange(), this.setXRange(), this.setZRange()
        }
    }, {
        key: "getMinYMaxY", value: function (e) {
            var t, i = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE,
                s = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : -Number.MAX_VALUE,
                a = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null, n = this.w.config,
                r = this.w.globals, o = -Number.MAX_VALUE, l = Number.MIN_VALUE, c = r.series, h = c, d = c,
                u = ("candlestick" === n.chart.type ? (h = r.seriesCandleL, d = r.seriesCandleH) : "boxPlot" === n.chart.type ? (h = r.seriesCandleO, d = r.seriesCandleC) : r.isRangeData && (h = r.seriesRangeStart, d = r.seriesRangeEnd), !1);
            r.seriesX.length >= (a = null === a ? e + 1 : a) && (t = null == (t = r.brushSource) ? void 0 : t.w.config.chart.brush, n.chart.zoom.enabled && n.chart.zoom.autoScaleYaxis || null != t && t.enabled && null != t && t.autoScaleYaxis) && (u = !0);
            for (var g = e; g < a; g++) {
                r.dataPoints = Math.max(r.dataPoints, c[g].length);
                var p = n.series[g].type,
                    f = (r.categoryLabels.length && (r.dataPoints = r.categoryLabels.filter(function (e) {
                        return void 0 !== e
                    }).length), r.labels.length && "datetime" !== n.xaxis.type && 0 !== r.series.reduce(function (e, t) {
                        return e + t.length
                    }, 0) && (r.dataPoints = Math.max(r.dataPoints, r.labels.length)), 0), x = c[g].length - 1;
                if (u) {
                    if (n.xaxis.min) for (; f < x && r.seriesX[g][f] < n.xaxis.min; f++) ;
                    if (n.xaxis.max) for (; f < x && r.seriesX[g][x] > n.xaxis.max; x--) ;
                }
                for (var m = f; m <= x && m < r.series[g].length; m++) {
                    var b = c[g][m];
                    if (null !== b && R.isNumber(b)) {
                        switch (void 0 !== d[g][m] && (o = Math.max(o, d[g][m]), i = Math.min(i, d[g][m])), void 0 !== h[g][m] && (i = Math.min(i, h[g][m]), s = Math.max(s, h[g][m])), p) {
                            case"candlestick":
                                void 0 !== r.seriesCandleC[g][m] && (o = Math.max(o, r.seriesCandleH[g][m]), i = Math.min(i, r.seriesCandleL[g][m]));
                                break;
                            case"boxPlot":
                                void 0 !== r.seriesCandleC[g][m] && (o = Math.max(o, r.seriesCandleC[g][m]), i = Math.min(i, r.seriesCandleO[g][m]))
                        }
                        p && "candlestick" !== p && "boxPlot" !== p && "rangeArea" !== p && "rangeBar" !== p && (o = Math.max(o, r.series[g][m]), i = Math.min(i, r.series[g][m])), s = o, r.seriesGoals[g] && r.seriesGoals[g][m] && Array.isArray(r.seriesGoals[g][m]) && r.seriesGoals[g][m].forEach(function (e) {
                            l !== Number.MIN_VALUE && (l = Math.min(l, e.value), i = l), o = Math.max(o, e.value), s = o
                        }), R.isFloat(b) && (b = R.noExponents(b), r.yValueDecimal = Math.max(r.yValueDecimal, b.toString().split(".")[1].length)), l > h[g][m] && h[g][m] < 0 && (l = h[g][m])
                    } else r.hasNullValues = !0
                }
                "bar" !== p && "column" !== p || (l < 0 && o < 0 && (o = 0, s = Math.max(s, 0)), l === Number.MIN_VALUE && (l = 0, i = Math.min(i, 0)))
            }
            return "rangeBar" === n.chart.type && r.seriesRangeStart.length && r.isBarHorizontal && (l = i), {
                minY: l = "bar" === n.chart.type && (l < 0 && o < 0 && (o = 0), l === Number.MIN_VALUE) ? 0 : l,
                maxY: o,
                lowestY: i,
                highestY: s
            }
        }
    }, {
        key: "setYRange", value: function () {
            var i = this.w.globals, t = this.w.config;
            i.maxY = -Number.MAX_VALUE, i.minY = Number.MIN_VALUE;
            var e, s = Number.MAX_VALUE;
            if (i.isMultipleYAxis) for (var s = Number.MAX_VALUE, a = 0; a < i.series.length; a++) e = this.getMinYMaxY(a), i.minYArr[a] = e.lowestY, i.maxYArr[a] = e.highestY, s = Math.min(s, e.lowestY);
            return e = this.getMinYMaxY(0, s, null, i.series.length), "bar" === t.chart.type ? (i.minY = e.minY, i.maxY = e.maxY) : (i.minY = e.lowestY, i.maxY = e.highestY), s = e.lowestY, t.chart.stacked && this._setStackedMinMax(), "line" === t.chart.type || "area" === t.chart.type || "scatter" === t.chart.type || "candlestick" === t.chart.type || "boxPlot" === t.chart.type || "rangeBar" === t.chart.type && !i.isBarHorizontal ? i.minY === Number.MIN_VALUE && s !== -Number.MAX_VALUE && s !== i.maxY && (i.minY = s) : i.minY = e.minY, t.yaxis.forEach(function (e, t) {
                void 0 !== e.max && ("number" == typeof e.max ? i.maxYArr[t] = e.max : "function" == typeof e.max && (i.maxYArr[t] = e.max(i.isMultipleYAxis ? i.maxYArr[t] : i.maxY)), i.maxY = i.maxYArr[t]), void 0 !== e.min && ("number" == typeof e.min ? i.minYArr[t] = e.min : "function" == typeof e.min && (i.minYArr[t] = e.min(i.isMultipleYAxis ? i.minYArr[t] === Number.MIN_VALUE ? 0 : i.minYArr[t] : i.minY)), i.minY = i.minYArr[t])
            }), i.isBarHorizontal && ["min", "max"].forEach(function (e) {
                void 0 !== t.xaxis[e] && "number" == typeof t.xaxis[e] && ("min" === e ? i.minY = t.xaxis[e] : i.maxY = t.xaxis[e])
            }), i.isMultipleYAxis ? (this.scales.scaleMultipleYAxes(), i.minY = s) : (this.scales.setYScaleForIndex(0, i.minY, i.maxY), i.minY = i.yAxisScale[0].niceMin, i.maxY = i.yAxisScale[0].niceMax, i.minYArr[0] = i.minY, i.maxYArr[0] = i.maxY), i.barGroups = [], i.lineGroups = [], i.areaGroups = [], t.series.forEach(function (e) {
                switch (e.type || t.chart.type) {
                    case"bar":
                    case"column":
                        i.barGroups.push(e.group);
                        break;
                    case"line":
                        i.lineGroups.push(e.group);
                        break;
                    case"area":
                        i.areaGroups.push(e.group)
                }
            }), i.barGroups = i.barGroups.filter(function (e, t, i) {
                return i.indexOf(e) === t
            }), i.lineGroups = i.lineGroups.filter(function (e, t, i) {
                return i.indexOf(e) === t
            }), i.areaGroups = i.areaGroups.filter(function (e, t, i) {
                return i.indexOf(e) === t
            }), {minY: i.minY, maxY: i.maxY, minYArr: i.minYArr, maxYArr: i.maxYArr, yAxisScale: i.yAxisScale}
        }
    }, {
        key: "setXRange", value: function () {
            var e = this.w.globals, t = this.w.config,
                i = "numeric" === t.xaxis.type || "datetime" === t.xaxis.type || "category" === t.xaxis.type && !e.noLabelsProvided || e.noLabelsProvided || e.isXNumeric;
            if (e.isXNumeric) for (var s = 0; s < e.series.length; s++) if (e.labels[s]) for (var a = 0; a < e.labels[s].length; a++) null !== e.labels[s][a] && R.isNumber(e.labels[s][a]) && (e.maxX = Math.max(e.maxX, e.labels[s][a]), e.initialMaxX = Math.max(e.maxX, e.labels[s][a]), e.minX = Math.min(e.minX, e.labels[s][a]), e.initialMinX = Math.min(e.minX, e.labels[s][a]));
            if (e.noLabelsProvided && 0 === t.xaxis.categories.length && (e.maxX = e.labels[e.labels.length - 1], e.initialMaxX = e.labels[e.labels.length - 1], e.minX = 1, e.initialMinX = 1), e.isXNumeric || e.noLabelsProvided || e.dataFormatXNumeric) {
                var n, r = 10;
                if (void 0 === t.xaxis.tickAmount ? (r = Math.round(e.svgWidth / 150), (r = "numeric" === t.xaxis.type && e.dataPoints < 30 ? e.dataPoints - 1 : r) > e.dataPoints && 0 !== e.dataPoints && (r = e.dataPoints - 1)) : "dataPoints" === t.xaxis.tickAmount ? (1 < e.series.length && (r = e.series[e.maxValsInArrayIndex].length - 1), e.isXNumeric && (n = e.maxX - e.minX) < 30 && (r = n - 1)) : r = t.xaxis.tickAmount, e.xTickAmount = r, void 0 !== t.xaxis.max && "number" == typeof t.xaxis.max && (e.maxX = t.xaxis.max), void 0 !== t.xaxis.min && "number" == typeof t.xaxis.min && (e.minX = t.xaxis.min), void 0 !== t.xaxis.range && (e.minX = e.maxX - t.xaxis.range), e.minX !== Number.MAX_VALUE && e.maxX !== -Number.MAX_VALUE) if (t.xaxis.convertedCatToNumeric && !e.dataFormatXNumeric) {
                    for (var o = [], l = e.minX - 1; l < e.maxX; l++) o.push(l + 1);
                    e.xAxisScale = {result: o, niceMin: o[0], niceMax: o[o.length - 1]}
                } else e.xAxisScale = this.scales.setXScale(e.minX, e.maxX); else e.xAxisScale = this.scales.linearScale(0, r, r, 0, t.xaxis.stepSize), e.noLabelsProvided && 0 < e.labels.length && (e.xAxisScale = this.scales.linearScale(1, e.labels.length, r - 1, 0, t.xaxis.stepSize), e.seriesX = e.labels.slice());
                i && (e.labels = e.xAxisScale.result.slice())
            }
            return e.isBarHorizontal && e.labels.length && (e.xTickAmount = e.labels.length), this._handleSingleDataPoint(), this._getMinXDiff(), {
                minX: e.minX,
                maxX: e.maxX
            }
        }
    }, {
        key: "setZRange", value: function () {
            var e = this.w.globals;
            if (e.isDataXYZ) for (var t = 0; t < e.series.length; t++) if (void 0 !== e.seriesZ[t]) for (var i = 0; i < e.seriesZ[t].length; i++) null !== e.seriesZ[t][i] && R.isNumber(e.seriesZ[t][i]) && (e.maxZ = Math.max(e.maxZ, e.seriesZ[t][i]), e.minZ = Math.min(e.minZ, e.seriesZ[t][i]))
        }
    }, {
        key: "_handleSingleDataPoint", value: function () {
            var e, t, i = this.w.globals, s = this.w.config;
            i.minX === i.maxX && (e = new y(this.ctx), "datetime" === s.xaxis.type ? (t = e.getDate(i.minX), s.xaxis.labels.datetimeUTC ? t.setUTCDate(t.getUTCDate() - 2) : t.setDate(t.getDate() - 2), i.minX = new Date(t).getTime(), t = e.getDate(i.maxX), s.xaxis.labels.datetimeUTC ? t.setUTCDate(t.getUTCDate() + 2) : t.setDate(t.getDate() + 2), i.maxX = new Date(t).getTime()) : "numeric" !== s.xaxis.type && ("category" !== s.xaxis.type || i.noLabelsProvided) || (i.minX = i.minX - 2, i.initialMinX = i.minX, i.maxX = i.maxX + 2, i.initialMaxX = i.maxX))
        }
    }, {
        key: "_getMinXDiff", value: function () {
            var s = this.w.globals;
            s.isXNumeric && s.seriesX.forEach(function (e, t) {
                1 === e.length && e.push(s.seriesX[s.maxValsInArrayIndex][s.seriesX[s.maxValsInArrayIndex].length - 1]);
                var i = e.slice();
                i.sort(function (e, t) {
                    return e - t
                }), i.forEach(function (e, t) {
                    0 < t && 0 < (e = e - i[t - 1]) && (s.minXDiff = Math.min(e, s.minXDiff))
                }), 1 !== s.dataPoints && s.minXDiff !== Number.MAX_VALUE || (s.minXDiff = .5)
            })
        }
    }, {
        key: "_setStackedMinMax", value: function () {
            var e, a, n, r = this, o = this.w.globals;
            o.series.length && ((e = o.seriesGroups).length || (e = [this.w.globals.seriesNames.map(function (e) {
                return e
            })]), a = {}, n = {}, e.forEach(function (s) {
                a[s] = [], n[s] = [], r.w.config.series.map(function (e, t) {
                    return -1 < s.indexOf(o.seriesNames[t]) ? t : null
                }).filter(function (e) {
                    return null !== e
                }).forEach(function (e) {
                    for (var t, i = 0; i < o.series[o.maxValsInArrayIndex].length; i++) void 0 === a[s][i] && (a[s][i] = 0, n[s][i] = 0), (r.w.config.chart.stacked && !o.comboCharts || r.w.config.chart.stacked && o.comboCharts && (!r.w.config.chart.stackOnlyBar || "bar" === (null == (t = r.w.config.series) || null == (t = t[e]) ? void 0 : t.type) || "column" === (null == (t = r.w.config.series) || null == (t = t[e]) ? void 0 : t.type))) && null !== o.series[e][i] && R.isNumber(o.series[e][i]) && (0 < o.series[e][i] ? a[s][i] += parseFloat(o.series[e][i]) + 1e-4 : n[s][i] += parseFloat(o.series[e][i]))
                })
            }), Object.entries(a).forEach(function (e) {
                var i = B(e, 1)[0];
                a[i].forEach(function (e, t) {
                    o.maxY = Math.max(o.maxY, a[i][t]), o.minY = Math.min(o.minY, n[i][t])
                })
            }))
        }
    }]), Ft), Ce = (e(Nt, [{
        key: "drawYaxis", value: function (e) {
            var t = this, i = this.w, s = new Y(this.ctx), a = i.config.yaxis[e].labels.style, n = a.fontSize,
                r = a.fontFamily, o = a.fontWeight, l = s.group({
                    class: "apexcharts-yaxis",
                    rel: e,
                    transform: "translate(" + i.globals.translateYAxisX[e] + ", 0)"
                });
            if (!this.axesUtils.isYAxisHidden(e)) {
                var c, h, d, u, g, p, f = s.group({class: "apexcharts-yaxis-texts-g"}),
                    x = (l.add(f), i.globals.yAxisScale[e].result.length - 1), m = i.globals.gridHeight / x,
                    b = i.globals.yLabelFormatters[e], v = i.globals.yAxisScale[e].result.slice(),
                    v = this.axesUtils.checkForReversedLabels(e, v), y = "";
                if (i.config.yaxis[e].labels.show) {
                    var w = i.globals.translateY + i.config.yaxis[e].labels.offsetY;
                    i.globals.isBarHorizontal ? w = 0 : "heatmap" === i.config.chart.type && (w -= m / 2), w += parseInt(i.config.yaxis[e].labels.style.fontSize, 10) / 3;
                    for (var k = x; 0 <= k; k--) p = d = p = g = u = d = h = void 0, h = v[c = k], h = b(h, c, i), d = i.config.yaxis[e].labels.padding, i.config.yaxis[e].opposite && 0 !== i.config.yaxis.length && (d *= -1), u = "end", i.config.yaxis[e].opposite && (u = "start"), "left" === i.config.yaxis[e].labels.align ? u = "start" : "center" === i.config.yaxis[e].labels.align ? u = "middle" : "right" === i.config.yaxis[e].labels.align && (u = "end"), g = t.axesUtils.getYAxisForeColor(a.colors, e), p = R.listToArray(i.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(e, "'] .apexcharts-yaxis-label tspan"))).map(function (e) {
                        return e.textContent
                    }), d = s.drawText({
                        x: d,
                        y: w,
                        text: 0 <= p.indexOf(h) ? "" : h,
                        textAnchor: u,
                        fontSize: n,
                        fontFamily: r,
                        fontWeight: o,
                        maxWidth: i.config.yaxis[e].labels.maxWidth,
                        foreColor: Array.isArray(g) ? g[c] : g,
                        isPlainText: !1,
                        cssClass: "apexcharts-yaxis-label " + a.cssClass
                    }), c === x && (y = d), f.add(d), (p = document.createElementNS(i.globals.SVGNS, "title")).textContent = Array.isArray(h) ? h.join(" ") : h, d.node.appendChild(p), 0 !== i.config.yaxis[e].labels.rotate && (u = s.rotateAroundCenter(y.node), g = s.rotateAroundCenter(d.node), d.node.setAttribute("transform", "rotate(".concat(i.config.yaxis[e].labels.rotate, " ").concat(u.x, " ").concat(g.y, ")"))), w += m
                }
                void 0 !== i.config.yaxis[e].title.text && (S = s.group({class: "apexcharts-yaxis-title"}), C = 0, i.config.yaxis[e].opposite && (C = i.globals.translateYAxisX[e]), C = s.drawText({
                    x: C,
                    y: i.globals.gridHeight / 2 + i.globals.translateY + i.config.yaxis[e].title.offsetY,
                    text: i.config.yaxis[e].title.text,
                    textAnchor: "end",
                    foreColor: i.config.yaxis[e].title.style.color,
                    fontSize: i.config.yaxis[e].title.style.fontSize,
                    fontWeight: i.config.yaxis[e].title.style.fontWeight,
                    fontFamily: i.config.yaxis[e].title.style.fontFamily,
                    cssClass: "apexcharts-yaxis-title-text " + i.config.yaxis[e].title.style.cssClass
                }), S.add(C), l.add(S));
                var A, C = i.config.yaxis[e].axisBorder, S = 31 + C.offsetX;
                i.config.yaxis[e].opposite && (S = -31 - C.offsetX), C.show && (A = s.drawLine(S, i.globals.translateY + C.offsetY - 2, S, i.globals.gridHeight + i.globals.translateY + C.offsetY + 2, C.color, 0, C.width), l.add(A)), i.config.yaxis[e].axisTicks.show && this.axesUtils.drawYAxisTicks(S, x, C, i.config.yaxis[e].axisTicks, e, m, l)
            }
            return l
        }
    }, {
        key: "drawYaxisInversed", value: function (e) {
            var t = this.w, i = new Y(this.ctx), s = i.group({class: "apexcharts-xaxis apexcharts-yaxis-inversed"}),
                a = i.group({
                    class: "apexcharts-xaxis-texts-g",
                    transform: "translate(".concat(t.globals.translateXAxisX, ", ").concat(t.globals.translateXAxisY, ")")
                }), n = (s.add(a), t.globals.yAxisScale[e].result.length - 1), r = t.globals.gridWidth / n + .1,
                o = r + t.config.xaxis.labels.offsetX, l = t.globals.xLabelFormatter,
                c = t.globals.yAxisScale[e].result.slice(), h = t.globals.timescaleLabels,
                d = (0 < h.length && (this.xaxisLabels = h.slice(), n = (c = h.slice()).length), c = this.axesUtils.checkForReversedLabels(e, c), h.length);
            if (t.config.xaxis.labels.show) for (var u = d ? 0 : n; d ? u < d : 0 <= u; d ? u++ : u--) {
                var g = c[u],
                    p = (g = l(g, u, t), t.globals.gridWidth + t.globals.padHorizontal - (o - r + t.config.xaxis.labels.offsetX)),
                    f = (h.length && (p = (f = this.axesUtils.getLabel(c, h, p, u, this.drawnLabels, this.xaxisFontSize)).x, this.drawnLabels.push(g = f.text), 0 === u && t.globals.skipFirstTimelinelabel && (g = ""), u === c.length - 1) && t.globals.skipLastTimelinelabel && (g = ""), i.drawText({
                        x: p,
                        y: this.xAxisoffX + t.config.xaxis.labels.offsetY + 30 - ("top" === t.config.xaxis.position ? t.globals.xAxisHeight + t.config.xaxis.axisTicks.height - 2 : 0),
                        text: g,
                        textAnchor: "middle",
                        foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[e] : this.xaxisForeColors,
                        fontSize: this.xaxisFontSize,
                        fontFamily: this.xaxisFontFamily,
                        fontWeight: t.config.xaxis.labels.style.fontWeight,
                        isPlainText: !1,
                        cssClass: "apexcharts-xaxis-label " + t.config.xaxis.labels.style.cssClass
                    })), p = (a.add(f), f.tspan(g), document.createElementNS(t.globals.SVGNS, "title"));
                p.textContent = g, f.node.appendChild(p), o += r
            }
            return this.inversedYAxisTitleText(s), this.inversedYAxisBorder(s), s
        }
    }, {
        key: "inversedYAxisBorder", value: function (e) {
            var t, i = this.w, s = new Y(this.ctx), a = i.config.xaxis.axisBorder;
            a.show && (t = 0, "bar" === i.config.chart.type && i.globals.isXNumeric && (t -= 15), s = s.drawLine(i.globals.padHorizontal + t + a.offsetX, this.xAxisoffX, i.globals.gridWidth, this.xAxisoffX, a.color, 0, a.height), (this.elgrid && this.elgrid.elGridBorders && i.config.grid.show ? this.elgrid.elGridBorders : e).add(s))
        }
    }, {
        key: "inversedYAxisTitleText", value: function (e) {
            var t, i = this.w, s = new Y(this.ctx);
            void 0 !== i.config.xaxis.title.text && (t = s.group({class: "apexcharts-xaxis-title apexcharts-yaxis-title-inversed"}), s = s.drawText({
                x: i.globals.gridWidth / 2 + i.config.xaxis.title.offsetX,
                y: this.xAxisoffX + parseFloat(this.xaxisFontSize) + parseFloat(i.config.xaxis.title.style.fontSize) + i.config.xaxis.title.offsetY + 20,
                text: i.config.xaxis.title.text,
                textAnchor: "middle",
                fontSize: i.config.xaxis.title.style.fontSize,
                fontFamily: i.config.xaxis.title.style.fontFamily,
                fontWeight: i.config.xaxis.title.style.fontWeight,
                foreColor: i.config.xaxis.title.style.color,
                cssClass: "apexcharts-xaxis-title-text " + i.config.xaxis.title.style.cssClass
            }), t.add(s), e.add(t))
        }
    }, {
        key: "yAxisTitleRotate", value: function (e, t) {
            var i = this.w, s = new Y(this.ctx), a = {width: 0, height: 0}, n = {width: 0, height: 0},
                r = i.globals.dom.baseEl.querySelector(" .apexcharts-yaxis[rel='".concat(e, "'] .apexcharts-yaxis-texts-g")),
                r = (null !== r && (a = r.getBoundingClientRect()), i.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(e, "'] .apexcharts-yaxis-title text")));
            null !== r && (n = r.getBoundingClientRect()), null !== r && (a = this.xPaddingForYAxisTitle(e, a, n, t), r.setAttribute("x", a.xPos - (t ? 10 : 0))), null !== r && (n = s.rotateAroundCenter(r), r.setAttribute("transform", "rotate(".concat(t ? -1 * i.config.yaxis[e].title.rotate : i.config.yaxis[e].title.rotate, " ").concat(n.x, " ").concat(n.y, ")")))
        }
    }, {
        key: "xPaddingForYAxisTitle", value: function (e, t, i, s) {
            var a = this.w, n = 0, r = 10;
            return void 0 === a.config.yaxis[e].title.text || e < 0 ? {
                xPos: n,
                padd: 0
            } : (s ? n = t.width + a.config.yaxis[e].title.offsetX + i.width / 2 + r / 2 : (n = -1 * t.width + a.config.yaxis[e].title.offsetX + r / 2 + i.width / 2, a.globals.isBarHorizontal && (n = -1 * t.width - a.config.yaxis[e].title.offsetX - (r = 25))), {
                xPos: n,
                padd: r
            })
        }
    }, {
        key: "setYAxisXPosition", value: function (a, n) {
            var r, o = this.w, l = 0, c = 18, h = 1;
            1 < o.config.yaxis.length && (this.multipleYs = !0), o.config.yaxis.map(function (e, t) {
                var i = -1 < o.globals.ignoreYAxisIndexes.indexOf(t) || !e.show || e.floating || 0 === a[t].width,
                    s = a[t].width + n[t].width;
                e.opposite ? o.globals.isBarHorizontal ? (l = o.globals.gridWidth + o.globals.translateX - 1, o.globals.translateYAxisX[t] = l - e.labels.offsetX) : (l = o.globals.gridWidth + o.globals.translateX + h, i || (h = h + s + 20), o.globals.translateYAxisX[t] = l - e.labels.offsetX + 20) : (r = o.globals.translateX - c, i || (c = c + s + 20), o.globals.translateYAxisX[t] = r + e.labels.offsetX)
            })
        }
    }, {
        key: "setYAxisTextAlignments", value: function () {
            var n = this.w, e = n.globals.dom.baseEl.getElementsByClassName("apexcharts-yaxis");
            (e = R.listToArray(e)).forEach(function (e, t) {
                var i, s, a = n.config.yaxis[t];
                a && !a.floating && void 0 !== a.labels.align && (i = n.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(t, "'] .apexcharts-yaxis-texts-g")), t = n.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(t, "'] .apexcharts-yaxis-label")), t = R.listToArray(t), s = i.getBoundingClientRect(), "left" === a.labels.align ? (t.forEach(function (e, t) {
                    e.setAttribute("text-anchor", "start")
                }), a.opposite || i.setAttribute("transform", "translate(-".concat(s.width, ", 0)"))) : "center" === a.labels.align ? (t.forEach(function (e, t) {
                    e.setAttribute("text-anchor", "middle")
                }), i.setAttribute("transform", "translate(".concat(s.width / 2 * (a.opposite ? 1 : -1), ", 0)"))) : "right" === a.labels.align && (t.forEach(function (e, t) {
                    e.setAttribute("text-anchor", "end")
                }), a.opposite) && i.setAttribute("transform", "translate(".concat(s.width, ", 0)")))
            })
        }
    }]), Nt), Se = (e(Xt, [{
        key: "addEventListener", value: function (e, t) {
            var i = this.w;
            i.globals.events.hasOwnProperty(e) ? i.globals.events[e].push(t) : i.globals.events[e] = [t]
        }
    }, {
        key: "removeEventListener", value: function (e, t) {
            var i = this.w;
            i.globals.events.hasOwnProperty(e) && -1 !== (t = i.globals.events[e].indexOf(t)) && i.globals.events[e].splice(t, 1)
        }
    }, {
        key: "fireEvent", value: function (e, t) {
            var i = this.w;
            if (i.globals.events.hasOwnProperty(e)) {
                t && t.length || (t = []);
                for (var s = i.globals.events[e], a = s.length, n = 0; n < a; n++) s[n].apply(null, t)
            }
        }
    }, {
        key: "setupEventHandlers", value: function () {
            var t = this, i = this.w, s = this.ctx, a = i.globals.dom.baseEl.querySelector(i.globals.chartClass);
            this.ctx.eventList.forEach(function (e) {
                a.addEventListener(e, function (e) {
                    var t = Object.assign({}, i, {
                        seriesIndex: i.globals.axisCharts ? i.globals.capturedSeriesIndex : 0,
                        dataPointIndex: i.globals.capturedDataPointIndex
                    });
                    "mousemove" === e.type || "touchmove" === e.type ? "function" == typeof i.config.chart.events.mouseMove && i.config.chart.events.mouseMove(e, s, t) : "mouseleave" === e.type || "touchleave" === e.type ? "function" == typeof i.config.chart.events.mouseLeave && i.config.chart.events.mouseLeave(e, s, t) : ("mouseup" === e.type && 1 === e.which || "touchend" === e.type) && ("function" == typeof i.config.chart.events.click && i.config.chart.events.click(e, s, t), s.ctx.events.fireEvent("click", [e, s, t]))
                }, {capture: !1, passive: !0})
            }), this.ctx.eventList.forEach(function (e) {
                i.globals.dom.baseEl.addEventListener(e, t.documentEvent, {passive: !0})
            }), this.ctx.core.setupBrushHandler()
        }
    }, {
        key: "documentEvent", value: function (e) {
            var t, i = this.w, s = e.target.className;
            "click" === e.type && (t = i.globals.dom.baseEl.querySelector(".apexcharts-menu")) && t.classList.contains("apexcharts-menu-open") && "apexcharts-menu-icon" !== s && t.classList.remove("apexcharts-menu-open"), i.globals.clientX = ("touchmove" === e.type ? e.touches[0] : e).clientX, i.globals.clientY = ("touchmove" === e.type ? e.touches[0] : e).clientY
        }
    }]), Xt), Le = (e(zt, [{
        key: "setCurrentLocaleValues", value: function (t) {
            var e = this.w.config.chart.locales,
                e = (e = window.Apex.chart && window.Apex.chart.locales && 0 < window.Apex.chart.locales.length ? this.w.config.chart.locales.concat(window.Apex.chart.locales) : e).filter(function (e) {
                    return e.name === t
                })[0];
            if (!e) throw new Error("Wrong locale name provided. Please make sure you set the correct locale name in options");
            e = R.extend(pe, e);
            this.w.globals.locale = e.options
        }
    }]), zt), Te = (e(Dt, [{
        key: "drawAxis", value: function (e, t) {
            var i, s, a = this, n = this.w.globals, r = this.w.config, o = new g(this.ctx, t), l = new Ce(this.ctx, t);
            n.axisCharts && "radar" !== e && (n.isBarHorizontal ? (s = l.drawYaxisInversed(0), i = o.drawXaxisInversed(0), n.dom.elGraphical.add(i), n.dom.elGraphical.add(s)) : (i = o.drawXaxis(), n.dom.elGraphical.add(i), r.yaxis.map(function (e, t) {
                -1 === n.ignoreYAxisIndexes.indexOf(t) && (s = l.drawYaxis(t), n.dom.Paper.add(s), "back" === a.w.config.grid.position) && ((t = n.dom.Paper.children()[1]).remove(), n.dom.Paper.add(t))
            })))
        }
    }]), Dt), Ee = (e(Ot, [{
        key: "drawXCrosshairs", value: function () {
            var e = this.w, t = new Y(this.ctx), i = new P(this.ctx), s = e.config.xaxis.crosshairs.fill.gradient,
                a = e.config.xaxis.crosshairs.dropShadow, n = e.config.xaxis.crosshairs.fill.type, r = s.colorFrom,
                o = a.enabled, l = a.left, c = a.top, h = a.blur, d = a.color, a = a.opacity,
                u = e.config.xaxis.crosshairs.fill.color;
            e.config.xaxis.crosshairs.show && ("gradient" === n && (u = t.drawGradient("vertical", r, s.colorTo, s.opacityFrom, s.opacityTo, null, s.stops, null)), n = t.drawRect(), 1 === e.config.xaxis.crosshairs.width && (n = t.drawLine()), r = e.globals.gridHeight, (!R.isNumber(r) || r < 0) && (r = 0), s = e.config.xaxis.crosshairs.width, (!R.isNumber(s) || s < 0) && (s = 0), n.attr({
                class: "apexcharts-xcrosshairs",
                x: 0,
                y: 0,
                y2: r,
                width: s,
                height: r,
                fill: u,
                filter: "none",
                "fill-opacity": e.config.xaxis.crosshairs.opacity,
                stroke: e.config.xaxis.crosshairs.stroke.color,
                "stroke-width": e.config.xaxis.crosshairs.stroke.width,
                "stroke-dasharray": e.config.xaxis.crosshairs.stroke.dashArray
            }), o && (n = i.dropShadow(n, {
                left: l,
                top: c,
                blur: h,
                color: d,
                opacity: a
            })), e.globals.dom.elGraphical.add(n))
        }
    }, {
        key: "drawYCrosshairs", value: function () {
            var e = this.w, t = new Y(this.ctx), i = e.config.yaxis[0].crosshairs, s = e.globals.barPadForNumericAxis,
                a = (e.config.yaxis[0].crosshairs.show && ((a = t.drawLine(-s, 0, e.globals.gridWidth + s, 0, i.stroke.color, i.stroke.dashArray, i.stroke.width)).attr({class: "apexcharts-ycrosshairs"}), e.globals.dom.elGraphical.add(a)), t.drawLine(-s, 0, e.globals.gridWidth + s, 0, i.stroke.color, 0, 0));
            a.attr({class: "apexcharts-ycrosshairs-hidden"}), e.globals.dom.elGraphical.add(a)
        }
    }]), Ot), Pe = (e(It, [{
        key: "checkResponsiveConfig", value: function (e) {
            var a, n, t, r = this, o = this.w, i = o.config;
            0 !== i.responsive.length && ((a = i.responsive.slice()).sort(function (e, t) {
                return e.breakpoint > t.breakpoint ? 1 : t.breakpoint > e.breakpoint ? -1 : 0
            }).reverse(), n = new p({}), i = function () {
                var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {}, t = a[0].breakpoint,
                    i = 0 < window.innerWidth ? window.innerWidth : screen.width;
                if (t < i) {
                    t = R.clone(o.globals.initialConfig), t = (t.series = R.clone(o.config.series), I.extendArrayProps(n, t, o)), e = R.extend(t, e);
                    e = R.extend(o.config, e), r.overrideResponsiveOptions(e)
                } else for (var s = 0; s < a.length; s++) i < a[s].breakpoint && (e = I.extendArrayProps(n, a[s].options, o), e = R.extend(o.config, e), r.overrideResponsiveOptions(e))
            }, e ? (t = I.extendArrayProps(n, e, o), t = R.extend(o.config, t), i(t = R.extend(t, e))) : i({}))
        }
    }, {
        key: "overrideResponsiveOptions", value: function (e) {
            e = new p(e).init({responsiveOverride: !0});
            this.w.config = e
        }
    }]), It), _e = (e(Mt, [{
        key: "init", value: function () {
            this.setDefaultColors()
        }
    }, {
        key: "setDefaultColors", value: function () {
            var e, s = this, a = this.w, t = new R;
            if (a.globals.dom.elWrap.classList.add("apexcharts-theme-".concat(a.config.theme.mode)), void 0 === a.config.colors || 0 === (null == (e = a.config.colors) ? void 0 : e.length) ? a.globals.colors = this.predefined() : (a.globals.colors = a.config.colors, Array.isArray(a.config.colors) && 0 < a.config.colors.length && "function" == typeof a.config.colors[0] && (a.globals.colors = a.config.series.map(function (e, t) {
                var i = a.config.colors[t];
                return "function" == typeof (i = i || a.config.colors[0]) ? (s.isColorFn = !0, i({
                    value: a.globals.axisCharts ? a.globals.series[t][0] || 0 : a.globals.series[t],
                    seriesIndex: t,
                    dataPointIndex: t,
                    w: a
                })) : i
            }))), a.globals.seriesColors.map(function (e, t) {
                e && (a.globals.colors[t] = e)
            }), a.config.theme.monochrome.enabled) {
                var i = [], n = a.globals.series.length;
                (this.isBarDistributed || this.isHeatmapDistributed) && (n = a.globals.series[0].length * a.globals.series.length);
                for (var r = a.config.theme.monochrome.color, o = 1 / (n / a.config.theme.monochrome.shadeIntensity), l = a.config.theme.monochrome.shadeTo, c = 0, h = 0; h < n; h++) {
                    var d = void 0, d = "dark" === l ? t.shadeColor(-1 * c, r) : t.shadeColor(c, r);
                    c += o, i.push(d)
                }
                a.globals.colors = i.slice()
            }
            var u = a.globals.colors.slice();
            this.pushExtraColors(a.globals.colors), ["fill", "stroke"].forEach(function (e) {
                void 0 === a.config[e].colors ? a.globals[e].colors = s.isColorFn ? a.config.colors : u : a.globals[e].colors = a.config[e].colors.slice(), s.pushExtraColors(a.globals[e].colors)
            }), void 0 === a.config.dataLabels.style.colors ? a.globals.dataLabels.style.colors = u : a.globals.dataLabels.style.colors = a.config.dataLabels.style.colors.slice(), this.pushExtraColors(a.globals.dataLabels.style.colors, 50), void 0 === a.config.plotOptions.radar.polygons.fill.colors ? a.globals.radarPolygons.fill.colors = ["dark" === a.config.theme.mode ? "#424242" : "none"] : a.globals.radarPolygons.fill.colors = a.config.plotOptions.radar.polygons.fill.colors.slice(), this.pushExtraColors(a.globals.radarPolygons.fill.colors, 20), void 0 === a.config.markers.colors ? a.globals.markers.colors = u : a.globals.markers.colors = a.config.markers.colors.slice(), this.pushExtraColors(a.globals.markers.colors)
        }
    }, {
        key: "pushExtraColors", value: function (e, t) {
            var i = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null, s = this.w,
                t = t || s.globals.series.length;
            if ((i = null === i ? this.isBarDistributed || this.isHeatmapDistributed || "heatmap" === s.config.chart.type && s.config.plotOptions.heatmap.colorScale.inverse : i) && s.globals.series.length && (t = s.globals.series[s.globals.maxValsInArrayIndex].length * s.globals.series.length), e.length < t) for (var a = t - e.length, n = 0; n < a; n++) e.push(e[n])
        }
    }, {
        key: "updateThemeOptions", value: function (e) {
            e.chart = e.chart || {}, e.tooltip = e.tooltip || {};
            var t = e.theme.mode, i = "dark" === t ? "palette4" : "light" !== t && e.theme.palette || "palette1",
                s = "dark" === t ? "#f6f7f8" : "light" !== t && e.chart.foreColor || "#373d3f";
            return e.tooltip.theme = t || "light", e.chart.foreColor = s, e.theme.palette = i, e
        }
    }, {
        key: "predefined", value: function () {
            switch (this.w.config.theme.palette) {
                case"palette1":
                default:
                    this.colors = ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"];
                    break;
                case"palette2":
                    this.colors = ["#3f51b5", "#03a9f4", "#4caf50", "#f9ce1d", "#FF9800"];
                    break;
                case"palette3":
                    this.colors = ["#33b2df", "#546E7A", "#d4526e", "#13d8aa", "#A5978B"];
                    break;
                case"palette4":
                    this.colors = ["#4ecdc4", "#c7f464", "#81D4FA", "#fd6a6a", "#546E7A"];
                    break;
                case"palette5":
                    this.colors = ["#2b908f", "#f9a3a4", "#90ee7e", "#fa4443", "#69d2e7"];
                    break;
                case"palette6":
                    this.colors = ["#449DD1", "#F86624", "#EA3546", "#662E9B", "#C5D86D"];
                    break;
                case"palette7":
                    this.colors = ["#D7263D", "#1B998B", "#2E294E", "#F46036", "#E2C044"];
                    break;
                case"palette8":
                    this.colors = ["#662E9B", "#F86624", "#F9C80E", "#EA3546", "#43BCCD"];
                    break;
                case"palette9":
                    this.colors = ["#5C4742", "#A5978B", "#8D5B4C", "#5A2A27", "#C4BBAF"];
                    break;
                case"palette10":
                    this.colors = ["#A300D6", "#7D02EB", "#5653FE", "#2983FF", "#00B1F2"]
            }
            return this.colors
        }
    }]), Mt), Me = (e(_t, [{
        key: "draw", value: function () {
            this.drawTitleSubtitle("title"), this.drawTitleSubtitle("subtitle")
        }
    }, {
        key: "drawTitleSubtitle", value: function (e) {
            var t = this.w, i = "title" === e ? t.config.title : t.config.subtitle, s = t.globals.svgWidth / 2,
                a = i.offsetY, n = "middle";
            "left" === i.align ? (s = 10, n = "start") : "right" === i.align && (s = t.globals.svgWidth - 10, n = "end"), s += i.offsetX, a = a + parseInt(i.style.fontSize, 10) + i.margin / 2, void 0 !== i.text && ((s = new Y(this.ctx).drawText({
                x: s,
                y: a,
                text: i.text,
                textAnchor: n,
                fontSize: i.style.fontSize,
                fontFamily: i.style.fontFamily,
                fontWeight: i.style.fontWeight,
                foreColor: i.style.color,
                opacity: 1
            })).node.setAttribute("class", "apexcharts-".concat(e, "-text")), t.globals.dom.Paper.add(s))
        }
    }]), _t), Ie = (e(Pt, [{
        key: "getTitleSubtitleCoords", value: function (e) {
            var t = this.w, i = 0, s = 0, a = ("title" === e ? t.config.title : t.config.subtitle).floating,
                e = t.globals.dom.baseEl.querySelector(".apexcharts-".concat(e, "-text"));
            return null === e || a || (i = (a = e.getBoundingClientRect()).width, s = t.globals.axisCharts ? a.height + 5 : a.height), {
                width: i,
                height: s
            }
        }
    }, {
        key: "getLegendsRect", value: function () {
            var e = this.w, t = e.globals.dom.elLegendWrap,
                i = (e.config.legend.height || "top" !== e.config.legend.position && "bottom" !== e.config.legend.position || (t.style.maxHeight = e.globals.svgHeight / 2 + "px"), Object.assign({}, R.getBoundingClientRect(t)));
            return null !== t && !e.config.legend.floating && e.config.legend.show ? this.dCtx.lgRect = {
                x: i.x,
                y: i.y,
                height: i.height,
                width: 0 === i.height ? 0 : i.width
            } : this.dCtx.lgRect = {
                x: 0,
                y: 0,
                height: 0,
                width: 0
            }, "left" !== e.config.legend.position && "right" !== e.config.legend.position || 1.5 * this.dCtx.lgRect.width > e.globals.svgWidth && (this.dCtx.lgRect.width = e.globals.svgWidth / 1.5), this.dCtx.lgRect
        }
    }, {
        key: "getDatalabelsRect", value: function () {
            var a = this, n = this.w, r = [], o = (n.config.series.forEach(function (e, s) {
                    e.data.forEach(function (e, t) {
                        var i = n.globals.series[s][t];
                        o = n.config.dataLabels.formatter(i, {
                            ctx: a.dCtx.ctx,
                            seriesIndex: s,
                            dataPointIndex: t,
                            w: n
                        }), r.push(o)
                    })
                }), R.getLargestStringFromArr(r)), e = new Y(this.dCtx.ctx), t = n.config.dataLabels.style,
                e = e.getTextRects(o, parseInt(t.fontSize), t.fontFamily);
            return {width: 1.05 * e.width, height: e.height}
        }
    }, {
        key: "getLargestStringFromMultiArr", value: function (e, t) {
            var i, s;
            return this.w.globals.isMultiLineX && (i = t.map(function (e, t) {
                return Array.isArray(e) ? e.length : 1
            }), s = Math.max.apply(Math, C(i)), e = t[i.indexOf(s)]), e
        }
    }]), Pt), Oe = (e(Et, [{
        key: "getxAxisLabelsCoords", value: function () {
            var e, t, i, s, a, n, r, o = this.w, l = o.globals.labels.slice();
            return o.config.xaxis.convertedCatToNumeric && 0 === l.length && (l = o.globals.categoryLabels), 0 < o.globals.timescaleLabels.length ? (e = {
                width: (e = this.getxAxisTimeScaleLabelsCoords()).width,
                height: e.height
            }, o.globals.rotateXLabels = !1) : (this.dCtx.lgWidthForSideLegends = "left" !== o.config.legend.position && "right" !== o.config.legend.position || o.config.legend.floating ? 0 : this.dCtx.lgRect.width, a = o.globals.xLabelFormatter, t = R.getLargestStringFromArr(l), i = this.dCtx.dimHelpers.getLargestStringFromMultiArr(t, l), o.globals.isBarHorizontal && (i = t = o.globals.yAxisScale[0].result.reduce(function (e, t) {
                return e.length > t.length ? e : t
            }, 0)), n = t, t = (r = new f(this.dCtx.ctx)).xLabelFormat(a, t, n, {
                i: void 0,
                dateFormatter: new y(this.dCtx.ctx).formatDate,
                w: o
            }), i = r.xLabelFormat(a, i, n, {
                i: void 0,
                dateFormatter: new y(this.dCtx.ctx).formatDate,
                w: o
            }), (o.config.xaxis.convertedCatToNumeric && void 0 === t || "" === String(t).trim()) && (i = t = "1"), a = r = (s = new Y(this.dCtx.ctx)).getTextRects(t, o.config.xaxis.labels.style.fontSize), t !== i && (a = s.getTextRects(i, o.config.xaxis.labels.style.fontSize)), (e = {
                width: (r.width >= a.width ? r : a).width,
                height: (r.height >= a.height ? r : a).height
            }).width * l.length > o.globals.svgWidth - this.dCtx.lgWidthForSideLegends - this.dCtx.yAxisWidth - this.dCtx.gridPad.left - this.dCtx.gridPad.right && 0 !== o.config.xaxis.labels.rotate || o.config.xaxis.labels.rotateAlways ? o.globals.isBarHorizontal || (o.globals.rotateXLabels = !0, r = (n = function (e) {
                return s.getTextRects(e, o.config.xaxis.labels.style.fontSize, o.config.xaxis.labels.style.fontFamily, "rotate(".concat(o.config.xaxis.labels.rotate, " 0 0)"), !1)
            })(t), t !== i && (a = n(i)), e.height = (r.height > a.height ? r : a).height / 1.5, e.width = (r.width > a.width ? r : a).width) : o.globals.rotateXLabels = !1), {
                width: (e = o.config.xaxis.labels.show ? e : {
                    width: 0,
                    height: 0
                }).width, height: e.height
            }
        }
    }, {
        key: "getxAxisGroupLabelsCoords", value: function () {
            var e, t, i, s, a, n, r = this.w;
            return r.globals.hasXaxisGroups ? (e = (null == (e = r.config.xaxis.group.style) ? void 0 : e.fontSize) || r.config.xaxis.labels.style.fontSize, i = r.globals.groups.map(function (e) {
                return e.title
            }), t = R.getLargestStringFromArr(i), i = this.dCtx.dimHelpers.getLargestStringFromMultiArr(t, i), n = a = (s = new Y(this.dCtx.ctx)).getTextRects(t, e), t !== i && (n = s.getTextRects(i, e)), t = {
                width: (a.width >= n.width ? a : n).width,
                height: (a.height >= n.height ? a : n).height
            }, {
                width: (t = r.config.xaxis.labels.show ? t : {width: 0, height: 0}).width,
                height: t.height
            }) : {width: 0, height: 0}
        }
    }, {
        key: "getxAxisTitleCoords", value: function () {
            var e = this.w, t = 0, i = 0;
            return void 0 !== e.config.xaxis.title.text && (t = (e = new Y(this.dCtx.ctx).getTextRects(e.config.xaxis.title.text, e.config.xaxis.title.style.fontSize)).width, i = e.height), {
                width: t,
                height: i
            }
        }
    }, {
        key: "getxAxisTimeScaleLabelsCoords", value: function () {
            var e = this.w,
                t = (this.dCtx.timescaleLabels = e.globals.timescaleLabels.slice(), this.dCtx.timescaleLabels.map(function (e) {
                    return e.value
                })), i = t.reduce(function (e, t) {
                    return void 0 === e ? (console.error("You have possibly supplied invalid Date format. Please supply a valid JavaScript Date"), 0) : e.length > t.length ? e : t
                }, 0);
            return 1.05 * (i = new Y(this.dCtx.ctx).getTextRects(i, e.config.xaxis.labels.style.fontSize)).width * t.length > e.globals.gridWidth && 0 !== e.config.xaxis.labels.rotate && (e.globals.overlappingXLabels = !0), i
        }
    }, {
        key: "additionalPaddingXLabels", value: function (e) {
            var a = this, n = this.w, r = n.globals, o = n.config, l = o.xaxis.type, c = e.width,
                h = (r.skipLastTimelinelabel = !1, r.skipFirstTimelinelabel = !1, n.config.yaxis[0].opposite && n.globals.isBarHorizontal);
            o.yaxis.forEach(function (e, t) {
                var i, s;
                h ? (a.dCtx.gridPad.left < c && (a.dCtx.xPadLeft = c / 2 + 1), a.dCtx.xPadRight = c / 2 + 1) : (e = e, t = t, 1 < o.yaxis.length && -1 !== r.collapsedSeriesIndices.indexOf(t) || (t = e, a.dCtx.timescaleLabels && a.dCtx.timescaleLabels.length ? (e = a.dCtx.timescaleLabels[0], i = a.dCtx.timescaleLabels[a.dCtx.timescaleLabels.length - 1].position + c / 1.75 - a.dCtx.yAxisWidthRight, e = e.position - c / 1.75 + a.dCtx.yAxisWidthLeft, s = "right" === n.config.legend.position && 0 < a.dCtx.lgRect.width ? a.dCtx.lgRect.width : 0, i > r.svgWidth - r.translateX - s && (r.skipLastTimelinelabel = !0), e < -(t.show && !t.floating || "bar" !== o.chart.type && "candlestick" !== o.chart.type && "rangeBar" !== o.chart.type && "boxPlot" !== o.chart.type ? 10 : c / 1.75) && (r.skipFirstTimelinelabel = !0)) : "datetime" === l ? a.dCtx.gridPad.right < c && !r.rotateXLabels && (r.skipLastTimelinelabel = !0) : "datetime" !== l && a.dCtx.gridPad.right < c / 2 - a.dCtx.yAxisWidthRight && !r.rotateXLabels && !n.config.xaxis.labels.trim && (a.dCtx.xPadRight = c / 2 + 1)))
            })
        }
    }]), Et), De = (e(Tt, [{
        key: "getyAxisLabelsCoords", value: function () {
            var h = this, d = this.w, u = [], g = 10, p = new w(this.dCtx.ctx);
            return d.config.yaxis.map(function (e, t) {
                var s, i, a, n, r, o = {seriesIndex: t, dataPointIndex: -1, w: d}, l = d.globals.yAxisScale[t], c = 0;
                !p.isYAxisHidden(t) && e.labels.show && void 0 !== e.labels.minWidth && (c = e.labels.minWidth), !p.isYAxisHidden(t) && e.labels.show && l.result.length ? (s = d.globals.yLabelFormatters[t], a = l.niceMin === Number.MIN_VALUE ? 0 : l.niceMin, a = l.result.reduce(function (e, t) {
                    var i;
                    return (null == (i = String(s(e, o))) ? void 0 : i.length) > (null == (i = String(s(t, o))) ? void 0 : i.length) ? e : t
                }, a), i = a = s(a, o), void 0 !== a && 0 !== a.length || (a = l.niceMax), d.globals.isBarHorizontal && (g = 0, l = d.globals.labels.slice(), a = R.getLargestStringFromArr(l), a = s(a, {
                    seriesIndex: t,
                    dataPointIndex: -1,
                    w: d
                }), i = h.dCtx.dimHelpers.getLargestStringFromMultiArr(a, l)), t = new Y(h.dCtx.ctx), l = "rotate(".concat(e.labels.rotate, " 0 0)"), r = n = t.getTextRects(a, e.labels.style.fontSize, e.labels.style.fontFamily, l, !1), a !== i && (r = t.getTextRects(i, e.labels.style.fontSize, e.labels.style.fontFamily, l, !1)), u.push({
                    width: (c > r.width || c > n.width ? c : (r.width > n.width ? r : n).width) + g,
                    height: (r.height > n.height ? r : n).height
                })) : u.push({width: 0, height: 0})
            }), u
        }
    }, {
        key: "getyAxisTitleCoords", value: function () {
            var a = this, e = this.w, n = [];
            return e.config.yaxis.map(function (e, t) {
                var i, s;
                e.show && void 0 !== e.title.text ? (s = new Y(a.dCtx.ctx), i = "rotate(".concat(e.title.rotate, " 0 0)"), s = s.getTextRects(e.title.text, e.title.style.fontSize, e.title.style.fontFamily, i, !1), n.push({
                    width: s.width,
                    height: s.height
                })) : n.push({width: 0, height: 0})
            }), n
        }
    }, {
        key: "getTotalYAxisWidth", value: function () {
            function i(e, t) {
                var i = a.config.yaxis[t].floating, s = 0;
                0 < e.width && !i ? (s = e.width + l, -1 < a.globals.ignoreYAxisIndexes.indexOf(t) && (s = s - e.width - l)) : s = i || c.isYAxisHidden(t) ? 0 : 5, a.config.yaxis[t].opposite ? o += s : r += s, n += s
            }

            var a = this.w, n = 0, r = 0, o = 0, l = 1 < a.globals.yAxisScale.length ? 10 : 0, c = new w(this.dCtx.ctx);
            return a.globals.yLabelsCoords.map(function (e, t) {
                i(e, t)
            }), a.globals.yTitleCoords.map(function (e, t) {
                i(e, t)
            }), a.globals.isBarHorizontal && !a.config.yaxis[0].floating && (n = a.globals.yLabelsCoords[0].width + a.globals.yTitleCoords[0].width + 15), this.dCtx.yAxisWidthLeft = r, this.dCtx.yAxisWidthRight = o, n
        }
    }]), Tt), ze = (e(Lt, [{
        key: "gridPadForColumnsInNumericAxis", value: function (e) {
            var t, i, s, a, n, r, o = this.w, l = o.config, o = o.globals;
            return o.noData || o.collapsedSeries.length + o.ancillaryCollapsedSeries.length === l.series.length ? 0 : (r = l.chart.type, s = (t = function (e) {
                return "bar" === e || "rangeBar" === e || "candlestick" === e || "boxPlot" === e
            })(r) ? l.series.length : 1, (i = 0) < o.comboBarCount && (s = o.comboBarCount), o.collapsedSeries.forEach(function (e) {
                t(e.type) && --s
            }), l.chart.stacked && (s = 1), r = t(r) || 0 < o.comboBarCount, a = Math.abs(o.initialMaxX - o.initialMinX), r && o.isXNumeric && !o.isBarHorizontal && 0 < s && 0 !== a && (r = (a = a <= 3 ? o.dataPoints : a) / e, e / 2 < (n = o.minXDiff && 0 < o.minXDiff / r ? o.minXDiff / r : n) && (n /= 2), (i = n * parseInt(l.plotOptions.bar.columnWidth, 10) / 100) < 1 && (i = 1), o.barPadForNumericAxis = i), i)
        }
    }, {
        key: "gridPadFortitleSubtitle", value: function () {
            var t = this, i = this.w, e = i.globals, s = this.dCtx.isSparkline || !i.globals.axisCharts ? 0 : 10,
                a = (["title", "subtitle"].forEach(function (e) {
                    void 0 !== i.config[e].text ? s += i.config[e].margin : s += t.dCtx.isSparkline || !i.globals.axisCharts ? 0 : 5
                }), !i.config.legend.show || "bottom" !== i.config.legend.position || i.config.legend.floating || i.globals.axisCharts || (s += 10), this.dCtx.dimHelpers.getTitleSubtitleCoords("title")),
                n = this.dCtx.dimHelpers.getTitleSubtitleCoords("subtitle");
            e.gridHeight = e.gridHeight - a.height - n.height - s, e.translateY = e.translateY + a.height + n.height + s
        }
    }, {
        key: "setGridXPosForDualYAxis", value: function (i, s) {
            var a = this.w, n = new w(this.dCtx.ctx);
            a.config.yaxis.map(function (e, t) {
                -1 !== a.globals.ignoreYAxisIndexes.indexOf(t) || e.floating || n.isYAxisHidden(t) || (e.opposite && (a.globals.translateX = a.globals.translateX - (s[t].width + i[t].width) - parseInt(a.config.yaxis[t].labels.style.fontSize, 10) / 1.2 - 12), a.globals.translateX < 2 && (a.globals.translateX = 2))
            })
        }
    }]), Lt), Xe = (e(St, [{
        key: "plotCoords", value: function () {
            var i = this, e = this.w, t = e.globals,
                s = (this.lgRect = this.dimHelpers.getLegendsRect(), this.datalabelsCoords = {
                    width: 0,
                    height: 0
                }, Array.isArray(e.config.stroke.width) ? Math.max.apply(Math, C(e.config.stroke.width)) : e.config.stroke.width),
                e = (this.isSparkline && ((0 < e.config.markers.discrete.length || 0 < e.config.markers.size) && Object.entries(this.gridPad).forEach(function (e) {
                    var e = B(e, 2), t = e[0];
                    i.gridPad[t] = Math.max(e[1], i.w.globals.markers.largestSize / 1.5)
                }), this.gridPad.top = Math.max(s / 2, this.gridPad.top), this.gridPad.bottom = Math.max(s / 2, this.gridPad.bottom)), t.axisCharts ? this.setDimensionsForAxisCharts() : this.setDimensionsForNonAxisCharts(), this.dimGrid.gridPadFortitleSubtitle(), t.gridHeight = t.gridHeight - this.gridPad.top - this.gridPad.bottom, t.gridWidth = t.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft, this.dimGrid.gridPadForColumnsInNumericAxis(t.gridWidth));
            t.gridWidth = t.gridWidth - 2 * e, t.translateX = t.translateX + this.gridPad.left + this.xPadLeft + (0 < e ? e : 0), t.translateY = t.translateY + this.gridPad.top
        }
    }, {
        key: "setDimensionsForAxisCharts", value: function () {
            function e() {
                s.translateX = c + t.datalabelsCoords.width, s.gridHeight = s.svgHeight - t.lgRect.height - h - (t.isSparkline || "treemap" === i.config.chart.type ? 0 : i.globals.rotateXLabels ? 10 : 15), s.gridWidth = s.svgWidth - c - 2 * t.datalabelsCoords.width
            }

            var t = this, i = this.w, s = i.globals, a = this.dimYAxis.getyAxisLabelsCoords(),
                n = this.dimYAxis.getyAxisTitleCoords(),
                r = (s.isSlopeChart && (this.datalabelsCoords = this.dimHelpers.getDatalabelsRect()), i.globals.yLabelsCoords = [], i.globals.yTitleCoords = [], i.config.yaxis.map(function (e, t) {
                    i.globals.yLabelsCoords.push({
                        width: a[t].width,
                        index: t
                    }), i.globals.yTitleCoords.push({width: n[t].width, index: t})
                }), this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth(), this.dimXAxis.getxAxisLabelsCoords()),
                o = this.dimXAxis.getxAxisGroupLabelsCoords(), l = this.dimXAxis.getxAxisTitleCoords(),
                c = (this.conditionalChecksForAxisCoords(r, l, o), s.translateXAxisY = i.globals.rotateXLabels ? this.xAxisHeight / 8 : -4, s.translateXAxisX = i.globals.rotateXLabels && i.globals.isXNumeric && i.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0, i.globals.isBarHorizontal && (s.rotateXLabels = !1, s.translateXAxisY = parseInt(i.config.xaxis.labels.style.fontSize, 10) / 1.5 * -1), s.translateXAxisY = s.translateXAxisY + i.config.xaxis.labels.offsetY, s.translateXAxisX = s.translateXAxisX + i.config.xaxis.labels.offsetX, this.yAxisWidth),
                h = this.xAxisHeight,
                d = (s.xAxisLabelsHeight = this.xAxisHeight - l.height, s.xAxisGroupLabelsHeight = s.xAxisLabelsHeight - r.height, s.xAxisLabelsWidth = this.xAxisWidth, s.xAxisHeight = this.xAxisHeight, 10);
            "radar" !== i.config.chart.type && !this.isSparkline || (c = 0, h = s.goldenPadding), this.isSparkline && (this.lgRect = {
                height: 0,
                width: 0
            }), !this.isSparkline && "treemap" !== i.config.chart.type || (d = h = c = 0), this.isSparkline || "treemap" === i.config.chart.type || this.dimXAxis.additionalPaddingXLabels(r);
            switch ("top" === i.config.xaxis.position && (d = s.xAxisHeight - i.config.xaxis.axisTicks.height - 5), i.config.legend.position) {
                case"bottom":
                    s.translateY = d, e();
                    break;
                case"top":
                    s.translateY = this.lgRect.height + d, e();
                    break;
                case"left":
                    s.translateY = d, s.translateX = this.lgRect.width + c + this.datalabelsCoords.width, s.gridHeight = s.svgHeight - h - 12, s.gridWidth = s.svgWidth - this.lgRect.width - c - 2 * this.datalabelsCoords.width;
                    break;
                case"right":
                    s.translateY = d, s.translateX = c + this.datalabelsCoords.width, s.gridHeight = s.svgHeight - h - 12, s.gridWidth = s.svgWidth - this.lgRect.width - c - 2 * this.datalabelsCoords.width - 5;
                    break;
                default:
                    throw new Error("Legend position not supported")
            }
            this.dimGrid.setGridXPosForDualYAxis(n, a), new Ce(this.ctx).setYAxisXPosition(a, n)
        }
    }, {
        key: "setDimensionsForNonAxisCharts", value: function () {
            var e = this.w, t = e.globals, i = e.config, s = 0,
                e = (e.config.legend.show && !e.config.legend.floating && (s = 20), "pie" === i.chart.type || "polarArea" === i.chart.type || "donut" === i.chart.type ? "pie" : "radialBar"),
                a = i.plotOptions[e].offsetY, n = i.plotOptions[e].offsetX;
            if (!i.legend.show || i.legend.floating) t.gridHeight = t.svgHeight - i.grid.padding.top - i.grid.padding.bottom, e = t.dom.elWrap.getBoundingClientRect().width, t.gridWidth = Math.min(e, t.gridHeight) - i.grid.padding.left - i.grid.padding.right, t.translateY = a, t.translateX = n + (t.svgWidth - t.gridWidth) / 2; else switch (i.legend.position) {
                case"bottom":
                    t.gridHeight = t.svgHeight - this.lgRect.height - t.goldenPadding, t.gridWidth = t.svgWidth, t.translateY = a - 10, t.translateX = n + (t.svgWidth - t.gridWidth) / 2;
                    break;
                case"top":
                    t.gridHeight = t.svgHeight - this.lgRect.height - t.goldenPadding, t.gridWidth = t.svgWidth, t.translateY = this.lgRect.height + a + 10, t.translateX = n + (t.svgWidth - t.gridWidth) / 2;
                    break;
                case"left":
                    t.gridWidth = t.svgWidth - this.lgRect.width - s, t.gridHeight = "auto" !== i.chart.height ? t.svgHeight : t.gridWidth, t.translateY = a, t.translateX = n + this.lgRect.width + s;
                    break;
                case"right":
                    t.gridWidth = t.svgWidth - this.lgRect.width - s - 5, t.gridHeight = "auto" !== i.chart.height ? t.svgHeight : t.gridWidth, t.translateY = a, t.translateX = n + 10;
                    break;
                default:
                    throw new Error("Legend position not supported")
            }
        }
    }, {
        key: "conditionalChecksForAxisCoords", value: function (e, t, i) {
            var s = this.w, a = s.globals.hasXaxisGroups ? 2 : 1, i = i.height + e.height + t.height,
                n = s.globals.isMultiLineX ? 1.2 : s.globals.LINE_HEIGHT_RATIO, r = s.globals.rotateXLabels ? 22 : 10,
                o = s.globals.rotateXLabels && "bottom" === s.config.legend.position ? 10 : 0,
                l = (this.xAxisHeight = i * n + a * r + o, this.xAxisWidth = e.width, this.xAxisHeight - t.height > s.config.xaxis.labels.maxHeight && (this.xAxisHeight = s.config.xaxis.labels.maxHeight), s.config.xaxis.labels.minHeight && this.xAxisHeight < s.config.xaxis.labels.minHeight && (this.xAxisHeight = s.config.xaxis.labels.minHeight), s.config.xaxis.floating && (this.xAxisHeight = 0), 0),
                c = 0;
            s.config.yaxis.forEach(function (e) {
                l += e.labels.minWidth, c += e.labels.maxWidth
            }), this.yAxisWidth < l && (this.yAxisWidth = l), this.yAxisWidth > c && (this.yAxisWidth = c)
        }
    }]), St), Ne = (e(Ct, [{
        key: "getLegendStyles", value: function () {
            var e = document.createElement("style"),
                t = (e.setAttribute("type", "text/css"), (null == (t = this.lgCtx.ctx) || null == (t = t.opts) || null == (t = t.chart) ? void 0 : t.nonce) || this.w.config.chart.nonce),
                t = (t && e.setAttribute("nonce", t), document.createTextNode("\n      .apexcharts-legend {\n        display: flex;\n        overflow: auto;\n        padding: 0 10px;\n      }\n      .apexcharts-legend.apx-legend-position-bottom, .apexcharts-legend.apx-legend-position-top {\n        flex-wrap: wrap\n      }\n      .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\n        flex-direction: column;\n        bottom: 0;\n      }\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-left, .apexcharts-legend.apx-legend-position-top.apexcharts-align-left, .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\n        justify-content: flex-start;\n      }\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-center, .apexcharts-legend.apx-legend-position-top.apexcharts-align-center {\n        justify-content: center;\n      }\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-right, .apexcharts-legend.apx-legend-position-top.apexcharts-align-right {\n        justify-content: flex-end;\n      }\n      .apexcharts-legend-series {\n        cursor: pointer;\n        line-height: normal;\n        display: flex;\n        align-items: center;\n      }\n      .apexcharts-legend-text {\n        position: relative;\n        font-size: 14px;\n      }\n      .apexcharts-legend-text *, .apexcharts-legend-marker * {\n        pointer-events: none;\n      }\n      .apexcharts-legend-marker {\n        position: relative;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        cursor: pointer;\n        margin-right: 1px;\n      }\n\n      .apexcharts-legend-series.apexcharts-no-click {\n        cursor: auto;\n      }\n      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {\n        display: none !important;\n      }\n      .apexcharts-inactive-legend {\n        opacity: 0.45;\n      }"));
            return e.appendChild(t), e
        }
    }, {
        key: "getLegendDimensions", value: function () {
            var e = this.w.globals.dom.baseEl.querySelector(".apexcharts-legend"), t = e.offsetWidth;
            return {clwh: e.offsetHeight, clww: t}
        }
    }, {
        key: "appendToForeignObject", value: function () {
            this.w.globals.dom.elLegendForeign.appendChild(this.getLegendStyles())
        }
    }, {
        key: "toggleDataSeries", value: function (e, t) {
            var i, s, a = this, n = this.w;
            n.globals.axisCharts || "radialBar" === n.config.chart.type ? (n.globals.resized = !0, i = s = null, n.globals.risingSeries = [], i = n.globals.axisCharts ? (s = n.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(e, "']")), parseInt(s.getAttribute("data:realIndex"), 10)) : (s = n.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(e + 1, "']")), parseInt(s.getAttribute("rel"), 10) - 1), t ? [{
                cs: n.globals.collapsedSeries,
                csi: n.globals.collapsedSeriesIndices
            }, {
                cs: n.globals.ancillaryCollapsedSeries,
                csi: n.globals.ancillaryCollapsedSeriesIndices
            }].forEach(function (e) {
                a.riseCollapsedSeries(e.cs, e.csi, i)
            }) : this.hideSeries({
                seriesEl: s,
                realIndex: i
            })) : (t = n.globals.dom.Paper.select(" .apexcharts-series[rel='".concat(e + 1, "'] path")), "pie" !== (s = n.config.chart.type) && "polarArea" !== s && "donut" !== s || (e = n.config.plotOptions.pie.donut.labels, new Y(this.lgCtx.ctx).pathMouseDown(t.members[0], null), this.lgCtx.ctx.pie.printDataLabelsInner(t.members[0].node, e)), t.fire("click"))
        }
    }, {
        key: "getSeriesAfterCollapsing", value: function (e) {
            var t, i, e = e.realIndex, s = this.w, a = s.globals, n = R.clone(s.config.series);
            return a.axisCharts ? (i = s.config.yaxis[a.seriesYAxisReverseMap[e]], t = {
                index: e,
                data: n[e].data.slice(),
                type: n[e].type || s.config.chart.type
            }, i && i.show && i.showAlways ? a.ancillaryCollapsedSeriesIndices.indexOf(e) < 0 && (a.ancillaryCollapsedSeries.push(t), a.ancillaryCollapsedSeriesIndices.push(e)) : a.collapsedSeriesIndices.indexOf(e) < 0 && (a.collapsedSeries.push(t), a.collapsedSeriesIndices.push(e), i = a.risingSeries.indexOf(e), a.risingSeries.splice(i, 1))) : (a.collapsedSeries.push({
                index: e,
                data: n[e]
            }), a.collapsedSeriesIndices.push(e)), a.allSeriesCollapsed = a.collapsedSeries.length + a.ancillaryCollapsedSeries.length === s.config.series.length, this._getSeriesBasedOnCollapsedState(n)
        }
    }, {
        key: "hideSeries", value: function (e) {
            for (var t = e.seriesEl, i = this.w, e = this.getSeriesAfterCollapsing({realIndex: e.realIndex}), s = t.childNodes, a = 0; a < s.length; a++) s[a].classList.contains("apexcharts-series-markers-wrap") && (s[a].classList.contains("apexcharts-hide") ? s[a].classList.remove("apexcharts-hide") : s[a].classList.add("apexcharts-hide"));
            this.lgCtx.ctx.updateHelpers._updateSeries(e, i.config.chart.animations.dynamicAnimation.enabled)
        }
    }, {
        key: "riseCollapsedSeries", value: function (e, t, i) {
            var s = this.w, a = R.clone(s.config.series);
            if (0 < e.length) {
                for (var n = 0; n < e.length; n++) e[n].index === i && (s.globals.axisCharts ? a[i].data = e[n].data.slice() : a[i] = e[n].data, a[i].hidden = !1, e.splice(n, 1), t.splice(n, 1), s.globals.risingSeries.push(i));
                a = this._getSeriesBasedOnCollapsedState(a), this.lgCtx.ctx.updateHelpers._updateSeries(a, s.config.chart.animations.dynamicAnimation.enabled)
            }
        }
    }, {
        key: "_getSeriesBasedOnCollapsedState", value: function (i) {
            var s = this.w, a = 0;
            return s.globals.axisCharts ? i.forEach(function (e, t) {
                s.globals.collapsedSeriesIndices.indexOf(t) < 0 && s.globals.ancillaryCollapsedSeriesIndices.indexOf(t) < 0 || (i[t].data = [], a++)
            }) : i.forEach(function (e, t) {
                !s.globals.collapsedSeriesIndices.indexOf(t) < 0 && (i[t] = 0, a++)
            }), s.globals.allSeriesCollapsed = a === i.length, i
        }
    }]), Ct), Fe = (e(At, [{
        key: "init", value: function () {
            var e = this.w, t = e.globals, e = e.config;
            if ((e.legend.showForSingleSeries && 1 === t.series.length || this.isBarsDistributed || 1 < t.series.length || !t.axisCharts) && e.legend.show) {
                for (; t.dom.elLegendWrap.firstChild;) t.dom.elLegendWrap.removeChild(t.dom.elLegendWrap.firstChild);
                this.drawLegends(), this.legendHelpers.appendToForeignObject(), "bottom" === e.legend.position || "top" === e.legend.position ? this.legendAlignHorizontal() : "right" !== e.legend.position && "left" !== e.legend.position || this.legendAlignVertical()
            }
        }
    }, {
        key: "createLegendMarker", value: function (e) {
            var t = e.i, e = e.fillcolor, i = this.w, s = document.createElement("span"),
                a = (s.classList.add("apexcharts-legend-marker"), i.config.legend.markers.shape || i.config.markers.shape),
                n = a,
                a = (Array.isArray(a) && (n = a[t]), Array.isArray(i.config.legend.markers.size) ? parseFloat(i.config.legend.markers.size[t]) : parseFloat(i.config.legend.markers.size)),
                r = Array.isArray(i.config.legend.markers.offsetX) ? parseFloat(i.config.legend.markers.offsetX[t]) : parseFloat(i.config.legend.markers.offsetX),
                o = Array.isArray(i.config.legend.markers.offsetY) ? parseFloat(i.config.legend.markers.offsetY[t]) : parseFloat(i.config.legend.markers.offsetY),
                l = Array.isArray(i.config.legend.markers.strokeWidth) ? parseFloat(i.config.legend.markers.strokeWidth[t]) : parseFloat(i.config.legend.markers.strokeWidth),
                c = s.style;
            return c.height = 2 * (a + l) + "px", c.width = 2 * (a + l) + "px", c.left = r + "px", c.top = o + "px", i.config.legend.markers.customHTML ? (c.background = "transparent", c.color = e[t], Array.isArray(i.config.legend.markers.customHTML) ? i.config.legend.markers.customHTML[t] && (s.innerHTML = i.config.legend.markers.customHTML[t]()) : s.innerHTML = i.config.legend.markers.customHTML()) : (r = new k(this.ctx).getMarkerConfig({
                cssClass: "apexcharts-legend-marker apexcharts-marker apexcharts-marker-".concat(n),
                seriesIndex: t,
                strokeWidth: l,
                size: a
            }), o = SVG(s).size("100%", "100%"), c = new Y(this.ctx).drawMarker(0, 0, M(M({}, r), {}, {
                pointFillColor: Array.isArray(e) ? e[t] : r.pointFillColor,
                shape: n
            })), SVG.select(".apexcharts-legend-marker.apexcharts-marker").members.forEach(function (e) {
                e.node.classList.contains("apexcharts-marker-triangle") ? e.node.style.transform = "translate(50%, 45%)" : e.node.style.transform = "translate(50%, 50%)"
            }), o.add(c)), s
        }
    }, {
        key: "drawLegends", value: function () {
            var e, t = this.w, i = t.config.legend.fontFamily, s = t.globals.seriesNames,
                a = (t.config.legend.markers.fillColors || t.globals.colors).slice();
            "heatmap" === t.config.chart.type ? (s = (e = t.config.plotOptions.heatmap.colorScale.ranges).map(function (e) {
                return e.name || e.from + " - " + e.to
            }), a = e.map(function (e) {
                return e.color
            })) : this.isBarsDistributed && (s = t.globals.labels.slice()), t.config.legend.customLegendItems.length && (s = t.config.legend.customLegendItems);
            for (var n = t.globals.legendFormatter, r = t.config.legend.inverseOrder, o = r ? s.length - 1 : 0; r ? 0 <= o : o <= s.length - 1; r ? o-- : o++) {
                var l = n(s[o], {seriesIndex: o, w: t}), c = !1, h = !1;
                if (0 < t.globals.collapsedSeries.length) for (var d = 0; d < t.globals.collapsedSeries.length; d++) t.globals.collapsedSeries[d].index === o && (c = !0);
                if (0 < t.globals.ancillaryCollapsedSeriesIndices.length) for (var u = 0; u < t.globals.ancillaryCollapsedSeriesIndices.length; u++) t.globals.ancillaryCollapsedSeriesIndices[u] === o && (h = !0);
                var g = this.createLegendMarker({i: o, fillcolor: a}), p = (Y.setAttrs(g, {
                        rel: o + 1,
                        "data:collapsed": c || h
                    }), (c || h) && g.classList.add("apexcharts-inactive-legend"), document.createElement("div")),
                    f = document.createElement("span");
                f.classList.add("apexcharts-legend-text"), f.innerHTML = Array.isArray(l) ? l.join(" ") : l;
                var x = (x = t.config.legend.labels.useSeriesColors ? t.globals.colors[o] : Array.isArray(t.config.legend.labels.colors) ? null == (x = t.config.legend.labels.colors) ? void 0 : x[o] : t.config.legend.labels.colors) || t.config.chart.foreColor,
                    l = (f.style.color = x, f.style.fontSize = parseFloat(t.config.legend.fontSize) + "px", f.style.fontWeight = t.config.legend.fontWeight, f.style.fontFamily = i || t.config.chart.fontFamily, Y.setAttrs(f, {
                        rel: o + 1,
                        i: o,
                        "data:default-text": encodeURIComponent(l),
                        "data:collapsed": c || h
                    }), p.appendChild(g), p.appendChild(f), new I(this.ctx));
                t.config.legend.showForZeroSeries || 0 === l.getSeriesTotalByIndex(o) && l.seriesHaveSameValues(o) && !l.isSeriesNull(o) && -1 === t.globals.collapsedSeriesIndices.indexOf(o) && -1 === t.globals.ancillaryCollapsedSeriesIndices.indexOf(o) && p.classList.add("apexcharts-hidden-zero-series"), t.config.legend.showForNullSeries || l.isSeriesNull(o) && -1 === t.globals.collapsedSeriesIndices.indexOf(o) && -1 === t.globals.ancillaryCollapsedSeriesIndices.indexOf(o) && p.classList.add("apexcharts-hidden-null-series"), t.globals.dom.elLegendWrap.appendChild(p), t.globals.dom.elLegendWrap.classList.add("apexcharts-align-".concat(t.config.legend.horizontalAlign)), t.globals.dom.elLegendWrap.classList.add("apx-legend-position-" + t.config.legend.position), p.classList.add("apexcharts-legend-series"), p.style.margin = "".concat(t.config.legend.itemMargin.vertical, "px ").concat(t.config.legend.itemMargin.horizontal, "px"), t.globals.dom.elLegendWrap.style.width = t.config.legend.width ? t.config.legend.width + "px" : "", t.globals.dom.elLegendWrap.style.height = t.config.legend.height ? t.config.legend.height + "px" : "", Y.setAttrs(p, {
                    rel: o + 1,
                    seriesName: R.escapeString(s[o]),
                    "data:collapsed": c || h
                }), (c || h) && p.classList.add("apexcharts-inactive-legend"), t.config.legend.onItemClick.toggleDataSeries || p.classList.add("apexcharts-no-click")
            }
            t.globals.dom.elWrap.addEventListener("click", this.onLegendClick, !0), t.config.legend.onItemHover.highlightDataSeries && 0 === t.config.legend.customLegendItems.length && (t.globals.dom.elWrap.addEventListener("mousemove", this.onLegendHovered, !0), t.globals.dom.elWrap.addEventListener("mouseout", this.onLegendHovered, !0))
        }
    }, {
        key: "setLegendWrapXY", value: function (e, t) {
            var i, s = this.w, a = s.globals.dom.elLegendWrap, n = a.getBoundingClientRect(), r = 0;
            "bottom" === s.config.legend.position ? r += s.globals.svgHeight - n.height / 2 : "top" === s.config.legend.position && (r = r + (0 < (i = (n = new Xe(this.ctx)).dimHelpers.getTitleSubtitleCoords("title").height) ? i - 10 : 0) + (0 < (i = n.dimHelpers.getTitleSubtitleCoords("subtitle").height) ? i - 10 : 0)), a.style.position = "absolute", n = 0 + e + s.config.legend.offsetX, r = r + t + s.config.legend.offsetY, a.style.left = n + "px", a.style.top = r + "px", "bottom" === s.config.legend.position ? (a.style.top = "auto", a.style.bottom = 5 - s.config.legend.offsetY + "px") : "right" === s.config.legend.position && (a.style.left = "auto", a.style.right = 25 + s.config.legend.offsetX + "px"), ["width", "height"].forEach(function (e) {
                a.style[e] && (a.style[e] = parseInt(s.config.legend[e], 10) + "px")
            })
        }
    }, {
        key: "legendAlignHorizontal", value: function () {
            var e = this.w, t = (e.globals.dom.elLegendWrap.style.right = 0, this.legendHelpers.getLegendDimensions()),
                i = new Xe(this.ctx), s = i.dimHelpers.getTitleSubtitleCoords("title"),
                i = i.dimHelpers.getTitleSubtitleCoords("subtitle"), a = 0;
            "bottom" === e.config.legend.position ? a = -t.clwh / 1.8 : "top" === e.config.legend.position && (a = s.height + i.height + e.config.title.margin + e.config.subtitle.margin - 10), this.setLegendWrapXY(20, a)
        }
    }, {
        key: "legendAlignVertical", value: function () {
            var e = this.w, t = this.legendHelpers.getLegendDimensions(), i = 0;
            "left" === e.config.legend.position && (i = 20), "right" === e.config.legend.position && (i = e.globals.svgWidth - t.clww - 10), this.setLegendWrapXY(i, 20)
        }
    }, {
        key: "onLegendHovered", value: function (e) {
            var t = this.w,
                i = e.target.classList.contains("apexcharts-legend-series") || e.target.classList.contains("apexcharts-legend-text") || e.target.classList.contains("apexcharts-legend-marker");
            "heatmap" === t.config.chart.type || this.isBarsDistributed ? i && (t = parseInt(e.target.getAttribute("rel"), 10) - 1, this.ctx.events.fireEvent("legendHover", [this.ctx, t, this.w]), new T(this.ctx).highlightRangeInSeries(e, e.target)) : !e.target.classList.contains("apexcharts-inactive-legend") && i && new T(this.ctx).toggleSeriesOnHover(e, e.target)
        }
    }, {
        key: "onLegendClick", value: function (e) {
            var t, i, s, a = this.w;
            !a.config.legend.customLegendItems.length && (e.target.classList.contains("apexcharts-legend-series") || e.target.classList.contains("apexcharts-legend-text") || e.target.classList.contains("apexcharts-legend-marker")) && (t = parseInt(e.target.getAttribute("rel"), 10) - 1, i = "true" === e.target.getAttribute("data:collapsed"), "function" == typeof (s = this.w.config.chart.events.legendClick) && s(this.ctx, t, this.w), this.ctx.events.fireEvent("legendClick", [this.ctx, t, this.w]), "function" == typeof (s = this.w.config.legend.markers.onClick) && e.target.classList.contains("apexcharts-legend-marker") && (s(this.ctx, t, this.w), this.ctx.events.fireEvent("legendMarkerClick", [this.ctx, t, this.w])), "treemap" !== a.config.chart.type) && "heatmap" !== a.config.chart.type && !this.isBarsDistributed && a.config.legend.onItemClick.toggleDataSeries && this.legendHelpers.toggleDataSeries(t, i)
        }
    }]), At), He = (e(kt, [{
        key: "createToolbar", value: function () {
            function e() {
                return document.createElement("div")
            }

            var a = this, n = this.w, t = e();
            if (t.setAttribute("class", "apexcharts-toolbar"), t.style.top = n.config.chart.toolbar.offsetY + "px", t.style.right = 3 - n.config.chart.toolbar.offsetX + "px", n.globals.dom.elWrap.appendChild(t), this.elZoom = e(), this.elZoomIn = e(), this.elZoomOut = e(), this.elPan = e(), this.elSelection = e(), this.elZoomReset = e(), this.elMenuIcon = e(), this.elMenu = e(), this.elCustomIcons = [], this.t = n.config.chart.toolbar.tools, Array.isArray(this.t.customIcons)) for (var i = 0; i < this.t.customIcons.length; i++) this.elCustomIcons.push(e());

            function s(e, t, i) {
                var s = e.toLowerCase();
                a.t[s] && n.config.chart.zoom.enabled && o.push({
                    el: t,
                    icon: "string" == typeof a.t[s] ? a.t[s] : i,
                    title: a.localeValues[e],
                    class: "apexcharts-".concat(s, "-icon")
                })
            }

            function r(e) {
                a.t[e] && n.config.chart[e].enabled && o.push({
                    el: "zoom" === e ? a.elZoom : a.elSelection,
                    icon: "string" == typeof a.t[e] ? a.t[e] : "zoom" === e ? '<svg xmlns="http://www.w3.org/2000/svg" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>\n    <path d="M0 0h24v24H0V0z" fill="none"/>\n    <path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/>\n</svg>' : '<svg fill="#6E8192" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z"/>\n</svg>',
                    title: a.localeValues["zoom" === e ? "selectionZoom" : "selection"],
                    class: n.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-".concat(e, "-icon")
                })
            }

            var o = [];
            s("zoomIn", this.elZoomIn, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n'), s("zoomOut", this.elZoomOut, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n');
            r("zoom"), r("selection"), this.t.pan && n.config.chart.zoom.enabled && o.push({
                el: this.elPan,
                icon: "string" == typeof this.t.pan ? this.t.pan : '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <defs>\n        <path d="M0 0h24v24H0z" id="a"/>\n    </defs>\n    <clipPath id="b">\n        <use overflow="visible" xlink:href="#a"/>\n    </clipPath>\n    <path clip-path="url(#b)" d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>\n</svg>',
                title: this.localeValues.pan,
                class: n.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-pan-icon"
            }), s("reset", this.elZoomReset, '<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>\n    <path d="M0 0h24v24H0z" fill="none"/>\n</svg>'), this.t.download && o.push({
                el: this.elMenuIcon,
                icon: "string" == typeof this.t.download ? this.t.download : '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>',
                title: this.localeValues.menu,
                class: "apexcharts-menu-icon"
            });
            for (var l = 0; l < this.elCustomIcons.length; l++) o.push({
                el: this.elCustomIcons[l],
                icon: this.t.customIcons[l].icon,
                title: this.t.customIcons[l].title,
                index: this.t.customIcons[l].index,
                class: "apexcharts-toolbar-custom-icon " + this.t.customIcons[l].class
            });
            o.forEach(function (e, t) {
                e.index && R.moveIndexInArray(o, t, e.index)
            });
            for (var c = 0; c < o.length; c++) Y.setAttrs(o[c].el, {
                class: o[c].class,
                title: o[c].title
            }), o[c].el.innerHTML = o[c].icon, t.appendChild(o[c].el);
            this._createHamburgerMenu(t), n.globals.zoomEnabled ? this.elZoom.classList.add(this.selectedClass) : n.globals.panEnabled ? this.elPan.classList.add(this.selectedClass) : n.globals.selectionEnabled && this.elSelection.classList.add(this.selectedClass), this.addToolbarEventListeners()
        }
    }, {
        key: "_createHamburgerMenu", value: function (e) {
            this.elMenuItems = [], e.appendChild(this.elMenu), Y.setAttrs(this.elMenu, {class: "apexcharts-menu"});
            for (var t = [{name: "exportSVG", title: this.localeValues.exportToSVG}, {
                name: "exportPNG",
                title: this.localeValues.exportToPNG
            }, {
                name: "exportCSV",
                title: this.localeValues.exportToCSV
            }], i = 0; i < t.length; i++) this.elMenuItems.push(document.createElement("div")), this.elMenuItems[i].innerHTML = t[i].title, Y.setAttrs(this.elMenuItems[i], {
                class: "apexcharts-menu-item ".concat(t[i].name),
                title: t[i].title
            }), this.elMenu.appendChild(this.elMenuItems[i])
        }
    }, {
        key: "addToolbarEventListeners", value: function () {
            var t = this;
            this.elZoomReset.addEventListener("click", this.handleZoomReset.bind(this)), this.elSelection.addEventListener("click", this.toggleZoomSelection.bind(this, "selection")), this.elZoom.addEventListener("click", this.toggleZoomSelection.bind(this, "zoom")), this.elZoomIn.addEventListener("click", this.handleZoomIn.bind(this)), this.elZoomOut.addEventListener("click", this.handleZoomOut.bind(this)), this.elPan.addEventListener("click", this.togglePanning.bind(this)), this.elMenuIcon.addEventListener("click", this.toggleMenu.bind(this)), this.elMenuItems.forEach(function (e) {
                e.classList.contains("exportSVG") ? e.addEventListener("click", t.handleDownload.bind(t, "svg")) : e.classList.contains("exportPNG") ? e.addEventListener("click", t.handleDownload.bind(t, "png")) : e.classList.contains("exportCSV") && e.addEventListener("click", t.handleDownload.bind(t, "csv"))
            });
            for (var e = 0; e < this.t.customIcons.length; e++) this.elCustomIcons[e].addEventListener("click", this.t.customIcons[e].click.bind(this, this.ctx, this.ctx.w))
        }
    }, {
        key: "toggleZoomSelection", value: function (s) {
            this.ctx.getSyncedCharts().forEach(function (e) {
                e.ctx.toolbar.toggleOtherControls();
                var t = "selection" === s ? e.ctx.toolbar.elSelection : e.ctx.toolbar.elZoom,
                    i = "selection" === s ? "selectionEnabled" : "zoomEnabled";
                e.w.globals[i] = !e.w.globals[i], t.classList.contains(e.ctx.toolbar.selectedClass) ? t.classList.remove(e.ctx.toolbar.selectedClass) : t.classList.add(e.ctx.toolbar.selectedClass)
            })
        }
    }, {
        key: "getToolbarIconsReference", value: function () {
            var e = this.w;
            this.elZoom || (this.elZoom = e.globals.dom.baseEl.querySelector(".apexcharts-zoom-icon")), this.elPan || (this.elPan = e.globals.dom.baseEl.querySelector(".apexcharts-pan-icon")), this.elSelection || (this.elSelection = e.globals.dom.baseEl.querySelector(".apexcharts-selection-icon"))
        }
    }, {
        key: "enableZoomPanFromToolbar", value: function (e) {
            this.toggleOtherControls(), "pan" === e ? this.w.globals.panEnabled = !0 : this.w.globals.zoomEnabled = !0;
            var t = "pan" === e ? this.elPan : this.elZoom, e = "pan" === e ? this.elZoom : this.elPan;
            t && t.classList.add(this.selectedClass), e && e.classList.remove(this.selectedClass)
        }
    }, {
        key: "togglePanning", value: function () {
            this.ctx.getSyncedCharts().forEach(function (e) {
                e.ctx.toolbar.toggleOtherControls(), e.w.globals.panEnabled = !e.w.globals.panEnabled, e.ctx.toolbar.elPan.classList.contains(e.ctx.toolbar.selectedClass) ? e.ctx.toolbar.elPan.classList.remove(e.ctx.toolbar.selectedClass) : e.ctx.toolbar.elPan.classList.add(e.ctx.toolbar.selectedClass)
            })
        }
    }, {
        key: "toggleOtherControls", value: function () {
            var t = this, e = this.w;
            e.globals.panEnabled = !1, e.globals.zoomEnabled = !1, e.globals.selectionEnabled = !1, this.getToolbarIconsReference(), [this.elPan, this.elSelection, this.elZoom].forEach(function (e) {
                e && e.classList.remove(t.selectedClass)
            })
        }
    }, {
        key: "handleZoomIn", value: function () {
            var e = this.w,
                t = (e.globals.isRangeBar && (this.minX = e.globals.minY, this.maxX = e.globals.maxY), (this.minX + this.maxX) / 2),
                i = (this.minX + t) / 2, t = (this.maxX + t) / 2, i = this._getNewMinXMaxX(i, t);
            e.globals.disableZoomIn || this.zoomUpdateOptions(i.minX, i.maxX)
        }
    }, {
        key: "handleZoomOut", value: function () {
            var e, t, i = this.w;
            i.globals.isRangeBar && (this.minX = i.globals.minY, this.maxX = i.globals.maxY), "datetime" === i.config.xaxis.type && new Date(this.minX).getUTCFullYear() < 1e3 || (e = (this.minX + this.maxX) / 2, t = this.minX - (e - this.minX), e = this.maxX - (e - this.maxX), t = this._getNewMinXMaxX(t, e), i.globals.disableZoomOut) || this.zoomUpdateOptions(t.minX, t.maxX)
        }
    }, {
        key: "_getNewMinXMaxX", value: function (e, t) {
            var i = this.w.config.xaxis.convertedCatToNumeric;
            return {minX: i ? Math.floor(e) : e, maxX: i ? Math.floor(t) : t}
        }
    }, {
        key: "zoomUpdateOptions", value: function (e, t) {
            var i, s = this.w;
            void 0 !== e || void 0 !== t ? s.config.xaxis.convertedCatToNumeric && (e < 1 && (e = 1, t = s.globals.dataPoints), t - e < 2) || (t = {
                xaxis: e = (t = this.getBeforeZoomRange(e = {
                    min: e,
                    max: t
                })) ? t.xaxis : e
            }, i = R.clone(s.globals.initialConfig.yaxis), s.config.chart.group || (t.yaxis = i), this.w.globals.zoomed = !0, this.ctx.updateHelpers._updateOptions(t, !1, this.w.config.chart.animations.dynamicAnimation.enabled), this.zoomCallback(e, i)) : this.handleZoomReset()
        }
    }, {
        key: "zoomCallback", value: function (e, t) {
            "function" == typeof this.ev.zoomed && this.ev.zoomed(this.ctx, {xaxis: e, yaxis: t})
        }
    }, {
        key: "getBeforeZoomRange", value: function (e, t) {
            var i = null;
            return i = "function" == typeof this.ev.beforeZoom ? this.ev.beforeZoom(this, {xaxis: e, yaxis: t}) : i
        }
    }, {
        key: "toggleMenu", value: function () {
            var e = this;
            window.setTimeout(function () {
                e.elMenu.classList.contains("apexcharts-menu-open") ? e.elMenu.classList.remove("apexcharts-menu-open") : e.elMenu.classList.add("apexcharts-menu-open")
            }, 0)
        }
    }, {
        key: "handleDownload", value: function (e) {
            var t = this.w, i = new ye(this.ctx);
            switch (e) {
                case"svg":
                    i.exportToSVG(this.ctx);
                    break;
                case"png":
                    i.exportToPng(this.ctx);
                    break;
                case"csv":
                    i.exportToCSV({
                        series: t.config.series,
                        columnDelimiter: t.config.chart.toolbar.export.csv.columnDelimiter
                    })
            }
        }
    }, {
        key: "handleZoomReset", value: function (e) {
            this.ctx.getSyncedCharts().forEach(function (e) {
                var t = e.w,
                    i = (t.globals.lastXAxis.min = t.globals.initialConfig.xaxis.min, t.globals.lastXAxis.max = t.globals.initialConfig.xaxis.max, e.updateHelpers.revertDefaultAxisMinMax(), "function" == typeof t.config.chart.events.beforeResetZoom && (i = t.config.chart.events.beforeResetZoom(e, t)) && e.updateHelpers.revertDefaultAxisMinMax(i), "function" == typeof t.config.chart.events.zoomed && e.ctx.toolbar.zoomCallback({
                        min: t.config.xaxis.min,
                        max: t.config.xaxis.max
                    }), t.globals.zoomed = !1, e.ctx.series.emptyCollapsedSeries(R.clone(t.globals.initialSeries)));
                e.updateHelpers._updateSeries(i, t.config.chart.animations.dynamicAnimation.enabled)
            })
        }
    }, {
        key: "destroy", value: function () {
            this.elZoom = null, this.elZoomIn = null, this.elZoomOut = null, this.elPan = null, this.elSelection = null, this.elZoomReset = null, this.elMenuIcon = null
        }
    }]), kt), Re = (i(x, He), ge = t(x), e(x, [{
        key: "init", value: function (e) {
            var t = this, i = e.xyRatios, e = this.w, s = this;
            this.xyRatios = i, this.zoomRect = this.graphics.drawRect(0, 0, 0, 0), this.selectionRect = this.graphics.drawRect(0, 0, 0, 0), this.gridRect = e.globals.dom.baseEl.querySelector(".apexcharts-grid"), this.zoomRect.node.classList.add("apexcharts-zoom-rect"), this.selectionRect.node.classList.add("apexcharts-selection-rect"), e.globals.dom.elGraphical.add(this.zoomRect), e.globals.dom.elGraphical.add(this.selectionRect), "x" === e.config.chart.selection.type ? this.slDraggableRect = this.selectionRect.draggable({
                minX: 0,
                minY: 0,
                maxX: e.globals.gridWidth,
                maxY: e.globals.gridHeight
            }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : "y" === e.config.chart.selection.type ? this.slDraggableRect = this.selectionRect.draggable({
                minX: 0,
                maxX: e.globals.gridWidth
            }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : this.slDraggableRect = this.selectionRect.draggable().on("dragmove", this.selectionDragging.bind(this, "dragging")), this.preselectedSelection(), this.hoverArea = e.globals.dom.baseEl.querySelector("".concat(e.globals.chartClass, " .apexcharts-svg")), this.hoverArea.classList.add("apexcharts-zoomable"), this.eventList.forEach(function (e) {
                t.hoverArea.addEventListener(e, s.svgMouseEvents.bind(s, i), {capture: !1, passive: !0})
            }), e.config.chart.zoom.allowMouseWheelZoom && this.hoverArea.addEventListener("wheel", s.mouseWheelEvent.bind(s), {
                capture: !1,
                passive: !1
            })
        }
    }, {
        key: "destroy", value: function () {
            this.slDraggableRect && (this.slDraggableRect.draggable(!1), this.slDraggableRect.off(), this.selectionRect.off()), this.selectionRect = null, this.zoomRect = null, this.gridRect = null
        }
    }, {
        key: "svgMouseEvents", value: function (e, t) {
            var i, s = this.w, a = this, n = this.ctx.toolbar,
                r = (s.globals.zoomEnabled ? s.config.chart.zoom : s.config.chart.selection).type,
                o = s.config.chart.toolbar.autoSelected;
            t.shiftKey ? (this.shiftWasPressed = !0, n.enableZoomPanFromToolbar("pan" === o ? "zoom" : "pan")) : this.shiftWasPressed && (n.enableZoomPanFromToolbar(o), this.shiftWasPressed = !1), t.target && (n = t.target.classList, t.target.parentNode && null !== t.target.parentNode && (i = t.target.parentNode.classList), n.contains("apexcharts-selection-rect") || n.contains("apexcharts-legend-marker") || n.contains("apexcharts-legend-text") || i && i.contains("apexcharts-toolbar") || (a.clientX = ("touchmove" === t.type || "touchstart" === t.type ? t.touches[0] : "touchend" === t.type ? t.changedTouches[0] : t).clientX, a.clientY = ("touchmove" === t.type || "touchstart" === t.type ? t.touches[0] : "touchend" === t.type ? t.changedTouches[0] : t).clientY, "mousedown" === t.type && 1 === t.which && (o = a.gridRect.getBoundingClientRect(), a.startX = a.clientX - o.left, a.startY = a.clientY - o.top, a.dragged = !1, a.w.globals.mousedown = !0), ("mousemove" === t.type && 1 === t.which || "touchmove" === t.type) && (a.dragged = !0, s.globals.panEnabled ? (s.globals.selection = null, a.w.globals.mousedown && a.panDragging({
                context: a,
                zoomtype: r,
                xyRatios: e
            })) : (a.w.globals.mousedown && s.globals.zoomEnabled || a.w.globals.mousedown && s.globals.selectionEnabled) && (a.selection = a.selectionDrawing({
                context: a,
                zoomtype: r
            }))), "mouseup" !== t.type && "touchend" !== t.type && "mouseleave" !== t.type || ((i = null == (n = a.gridRect) ? void 0 : n.getBoundingClientRect()) && a.w.globals.mousedown && (a.endX = a.clientX - i.left, a.endY = a.clientY - i.top, a.dragX = Math.abs(a.endX - a.startX), a.dragY = Math.abs(a.endY - a.startY), (s.globals.zoomEnabled || s.globals.selectionEnabled) && a.selectionDrawn({
                context: a,
                zoomtype: r
            }), s.globals.panEnabled) && s.config.xaxis.convertedCatToNumeric && a.delayedPanScrolled(), s.globals.zoomEnabled && a.hideSelectionRect(this.selectionRect), a.dragged = !1, a.w.globals.mousedown = !1), this.makeSelectionRectDraggable()))
        }
    }, {
        key: "mouseWheelEvent", value: function (e) {
            var t = this, i = this.w, s = (e.preventDefault(), Date.now());
            s - i.globals.lastWheelExecution > this.wheelDelay && (this.executeMouseWheelZoom(e), i.globals.lastWheelExecution = s), this.debounceTimer && clearTimeout(this.debounceTimer), this.debounceTimer = setTimeout(function () {
                s - i.globals.lastWheelExecution > t.wheelDelay && (t.executeMouseWheelZoom(e), i.globals.lastWheelExecution = s)
            }, this.debounceDelay)
        }
    }, {
        key: "executeMouseWheelZoom", value: function (e) {
            var t, i, s, a, n, r = this.w,
                o = (this.minX = r.globals.isRangeBar ? r.globals.minY : r.globals.minX, this.maxX = r.globals.isRangeBar ? r.globals.maxY : r.globals.maxX, null == (o = this.gridRect) ? void 0 : o.getBoundingClientRect());
            o && (o = (e.clientX - o.left) / o.width, a = this.minX, n = (i = this.maxX) - a, o = e.deltaY < 0 ? (s = (e = a + o * n) - (t = .5 * n) / 2, e + t / 2) : (s = a - (t = 1.5 * n) / 2, i + t / 2), s = Math.max(s, r.globals.initialMinX), (o = Math.min(o, r.globals.initialMaxX)) - s < (e = .01 * (r.globals.initialMaxX - r.globals.initialMinX)) && (s = (a = (s + o) / 2) - e / 2, o = a + e / 2), n = this._getNewMinXMaxX(s, o), isNaN(n.minX) || isNaN(n.maxX) || this.zoomUpdateOptions(n.minX, n.maxX))
        }
    }, {
        key: "makeSelectionRectDraggable", value: function () {
            var e, t = this.w;
            this.selectionRect && 0 < (e = this.selectionRect.node.getBoundingClientRect()).width && 0 < e.height && this.slDraggableRect.selectize({
                points: "l, r",
                pointSize: 8,
                pointType: "rect"
            }).resize({
                constraint: {
                    minX: 0,
                    minY: 0,
                    maxX: t.globals.gridWidth,
                    maxY: t.globals.gridHeight
                }
            }).on("resizing", this.selectionDragging.bind(this, "resizing"))
        }
    }, {
        key: "preselectedSelection", value: function () {
            var e, t, i = this.w, s = this.xyRatios;
            i.globals.zoomEnabled || (null != i.globals.selection ? this.drawSelectionRect(i.globals.selection) : void 0 !== i.config.chart.selection.xaxis.min && void 0 !== i.config.chart.selection.xaxis.max && (e = (i.config.chart.selection.xaxis.min - i.globals.minX) / s.xRatio, t = i.globals.gridWidth - (i.globals.maxX - i.config.chart.selection.xaxis.max) / s.xRatio - e, i.globals.isRangeBar && (e = (i.config.chart.selection.xaxis.min - i.globals.yAxisScale[0].niceMin) / s.invertedYRatio, t = (i.config.chart.selection.xaxis.max - i.config.chart.selection.xaxis.min) / s.invertedYRatio), s = {
                x: e,
                y: 0,
                width: t,
                height: i.globals.gridHeight,
                translateX: 0,
                translateY: 0,
                selectionEnabled: !0
            }, this.drawSelectionRect(s), this.makeSelectionRectDraggable(), "function" == typeof i.config.chart.events.selection) && i.config.chart.events.selection(this.ctx, {
                xaxis: {
                    min: i.config.chart.selection.xaxis.min,
                    max: i.config.chart.selection.xaxis.max
                }, yaxis: {}
            }))
        }
    }, {
        key: "drawSelectionRect", value: function (e) {
            var t = e.x, i = e.y, s = e.width, a = e.height, n = e.translateX, e = e.translateY, r = this.w,
                o = this.zoomRect, l = this.selectionRect;
            (this.dragged || null !== r.globals.selection) && (n = {transform: "translate(" + (void 0 === n ? 0 : n) + ", " + (void 0 === e ? 0 : e) + ")"}, r.globals.zoomEnabled && this.dragged && (o.attr({
                x: t,
                y: i,
                width: s = s < 0 ? 1 : s,
                height: a,
                fill: r.config.chart.zoom.zoomedArea.fill.color,
                "fill-opacity": r.config.chart.zoom.zoomedArea.fill.opacity,
                stroke: r.config.chart.zoom.zoomedArea.stroke.color,
                "stroke-width": r.config.chart.zoom.zoomedArea.stroke.width,
                "stroke-opacity": r.config.chart.zoom.zoomedArea.stroke.opacity
            }), Y.setAttrs(o.node, n)), r.globals.selectionEnabled) && (l.attr({
                x: t,
                y: i,
                width: 0 < s ? s : 0,
                height: 0 < a ? a : 0,
                fill: r.config.chart.selection.fill.color,
                "fill-opacity": r.config.chart.selection.fill.opacity,
                stroke: r.config.chart.selection.stroke.color,
                "stroke-width": r.config.chart.selection.stroke.width,
                "stroke-dasharray": r.config.chart.selection.stroke.dashArray,
                "stroke-opacity": r.config.chart.selection.stroke.opacity
            }), Y.setAttrs(l.node, n))
        }
    }, {
        key: "hideSelectionRect", value: function (e) {
            e && e.attr({x: 0, y: 0, width: 0, height: 0})
        }
    }, {
        key: "selectionDrawing", value: function (e) {
            var t = e.context, e = e.zoomtype, i = this.w, s = this.gridRect.getBoundingClientRect(), a = t.startX - 1,
                n = t.startY, r = !1, o = !1, l = t.clientX - s.left - a, c = t.clientY - s.top - n;
            return Math.abs(l + a) > i.globals.gridWidth ? l = i.globals.gridWidth - a : t.clientX - s.left < 0 && (l = a), a > t.clientX - s.left && (r = !0, l = Math.abs(l)), n > t.clientY - s.top && (o = !0, c = Math.abs(c)), s = "x" === e ? {
                x: r ? a - l : a,
                y: 0,
                width: l,
                height: i.globals.gridHeight
            } : "y" === e ? {x: 0, y: o ? n - c : n, width: i.globals.gridWidth, height: c} : {
                x: r ? a - l : a,
                y: o ? n - c : n,
                width: l,
                height: c
            }, t.drawSelectionRect(s), t.selectionDragging("resizing"), s
        }
    }, {
        key: "selectionDragging", value: function (e, t) {
            function i(e) {
                return parseFloat(l.node.getAttribute(e))
            }

            var n = this, r = this.w, o = this.xyRatios, l = this.selectionRect, s = 0,
                e = ("resizing" === e && (s = 30), {x: i("x"), y: i("y"), width: i("width"), height: i("height")});
            r.globals.selection = e, "function" == typeof r.config.chart.events.selection && r.globals.selectionEnabled && (clearTimeout(this.w.globals.selectionResizeTimer), this.w.globals.selectionResizeTimer = window.setTimeout(function () {
                var e, t, i, s = n.gridRect.getBoundingClientRect(), a = l.node.getBoundingClientRect(),
                    a = r.globals.isRangeBar ? (e = r.globals.yAxisScale[0].niceMin + (a.left - s.left) * o.invertedYRatio, t = r.globals.yAxisScale[0].niceMin + (a.right - s.left) * o.invertedYRatio, i = 0, 1) : (e = r.globals.xAxisScale.niceMin + (a.left - s.left) * o.xRatio, t = r.globals.xAxisScale.niceMin + (a.right - s.left) * o.xRatio, i = r.globals.yAxisScale[0].niceMin + (s.bottom - a.bottom) * o.yRatio[0], r.globals.yAxisScale[0].niceMax - (a.top - s.top) * o.yRatio[0]),
                    s = {xaxis: {min: e, max: t}, yaxis: {min: i, max: a}};
                r.config.chart.events.selection(n.ctx, s), r.config.chart.brush.enabled && void 0 !== r.config.chart.events.brushScrolled && r.config.chart.events.brushScrolled(n.ctx, s)
            }, s))
        }
    }, {
        key: "selectionDrawn", value: function (e) {
            var i, t, s, a, n = e.context, e = e.zoomtype, r = this.w, o = n, l = this.xyRatios, n = this.ctx.toolbar,
                c = (o.startX > o.endX && (c = o.startX, o.startX = o.endX, o.endX = c), o.endY < o.startY && (c = o.startY, o.startY = o.endY, o.endY = c), void 0),
                h = void 0,
                h = r.globals.isRangeBar ? (c = r.globals.yAxisScale[0].niceMin + o.startX * l.invertedYRatio, r.globals.yAxisScale[0].niceMin + o.endX * l.invertedYRatio) : (c = r.globals.xAxisScale.niceMin + o.startX * l.xRatio, r.globals.xAxisScale.niceMin + o.endX * l.xRatio),
                d = [], u = [];
            r.config.yaxis.forEach(function (e, t) {
                var i = r.globals.seriesYAxisMap[t][0];
                d.push(r.globals.yAxisScale[t].niceMax - l.yRatio[i] * o.startY), u.push(r.globals.yAxisScale[t].niceMax - l.yRatio[i] * o.endY)
            }), o.dragged && (10 < o.dragX || 10 < o.dragY) && c !== h && (r.globals.zoomEnabled ? (i = R.clone(r.globals.initialConfig.yaxis), t = R.clone(r.globals.initialConfig.xaxis), r.globals.zoomed = !0, r.config.xaxis.convertedCatToNumeric && (c = Math.floor(c), h = Math.floor(h), c < 1 && (c = 1, h = r.globals.dataPoints), h - c < 2) && (h = c + 1), "xy" !== e && "x" !== e || (t = {
                min: c,
                max: h
            }), "xy" !== e && "y" !== e || i.forEach(function (e, t) {
                i[t].min = u[t], i[t].max = d[t]
            }), n && (a = n.getBeforeZoomRange(t, i)) && (t = a.xaxis || t, i = a.yaxis || i), a = {xaxis: t}, r.config.chart.group || (a.yaxis = i), o.ctx.updateHelpers._updateOptions(a, !1, o.w.config.chart.animations.dynamicAnimation.enabled), "function" == typeof r.config.chart.events.zoomed && n.zoomCallback(t, i)) : r.globals.selectionEnabled && (s = null, a = {
                min: c,
                max: h
            }, "xy" !== e && "y" !== e || (s = R.clone(r.config.yaxis)).forEach(function (e, t) {
                s[t].min = u[t], s[t].max = d[t]
            }), r.globals.selection = o.selection, "function" == typeof r.config.chart.events.selection) && r.config.chart.events.selection(o.ctx, {
                xaxis: a,
                yaxis: s
            }))
        }
    }, {
        key: "panDragging", value: function (e) {
            var e = e.context, t = this.w,
                i = (void 0 !== t.globals.lastClientPosition.x && (i = t.globals.lastClientPosition.x - e.clientX, s = t.globals.lastClientPosition.y - e.clientY, Math.abs(i) > Math.abs(s) && 0 < i ? this.moveDirection = "left" : Math.abs(i) > Math.abs(s) && i < 0 ? this.moveDirection = "right" : Math.abs(s) > Math.abs(i) && 0 < s ? this.moveDirection = "up" : Math.abs(s) > Math.abs(i) && s < 0 && (this.moveDirection = "down")), t.globals.lastClientPosition = {
                    x: e.clientX,
                    y: e.clientY
                }, t.globals.isRangeBar ? t.globals.minY : t.globals.minX),
                s = t.globals.isRangeBar ? t.globals.maxY : t.globals.maxX;
            t.config.xaxis.convertedCatToNumeric || e.panScrolled(i, s)
        }
    }, {
        key: "delayedPanScrolled", value: function () {
            var e = this.w, t = e.globals.minX, i = e.globals.maxX, s = (e.globals.maxX - e.globals.minX) / 2;
            "left" === this.moveDirection ? (t = e.globals.minX + s, i = e.globals.maxX + s) : "right" === this.moveDirection && (t = e.globals.minX - s, i = e.globals.maxX - s), t = Math.floor(t), i = Math.floor(i), this.updateScrolledChart({
                xaxis: {
                    min: t,
                    max: i
                }
            }, t, i)
        }
    }, {
        key: "panScrolled", value: function (e, t) {
            var i = this.w, s = this.xyRatios, a = R.clone(i.globals.initialConfig.yaxis), n = s.xRatio,
                r = i.globals.minX, o = i.globals.maxX,
                s = (i.globals.isRangeBar && (n = s.invertedYRatio, r = i.globals.minY, o = i.globals.maxY), "left" === this.moveDirection ? (e = r + i.globals.gridWidth / 15 * n, t = o + i.globals.gridWidth / 15 * n) : "right" === this.moveDirection && (e = r - i.globals.gridWidth / 15 * n, t = o - i.globals.gridWidth / 15 * n), i.globals.isRangeBar || (e < i.globals.initialMinX || t > i.globals.initialMaxX) && (e = r, t = o), {
                    xaxis: {
                        min: e,
                        max: t
                    }
                });
            i.config.chart.group || (s.yaxis = a), this.updateScrolledChart(s, e, t)
        }
    }, {
        key: "updateScrolledChart", value: function (e, t, i) {
            var s = this.w;
            this.ctx.updateHelpers._updateOptions(e, !1, !1), "function" == typeof s.config.chart.events.scrolled && s.config.chart.events.scrolled(this.ctx, {
                xaxis: {
                    min: t,
                    max: i
                }
            })
        }
    }]), x), Ye = (e(wt, [{
        key: "getNearestValues", value: function (e) {
            var t, i = e.hoverArea, s = e.elGrid, a = e.clientX, e = e.clientY, n = this.w,
                s = s.getBoundingClientRect(), r = s.width, o = s.height, l = r / (n.globals.dataPoints - 1),
                c = o / n.globals.dataPoints, h = this.hasBars(),
                a = (!n.globals.comboCharts && !h || n.config.xaxis.convertedCatToNumeric || (l = r / n.globals.dataPoints), a - s.left - n.globals.barPadForNumericAxis),
                e = e - s.top,
                s = (a < 0 || e < 0 || r < a || o < e ? (i.classList.remove("hovering-zoom"), i.classList.remove("hovering-pan")) : n.globals.zoomEnabled ? (i.classList.remove("hovering-pan"), i.classList.add("hovering-zoom")) : n.globals.panEnabled && (i.classList.remove("hovering-zoom"), i.classList.add("hovering-pan")), Math.round(a / l)),
                i = Math.floor(e / c),
                c = (h && !n.config.xaxis.convertedCatToNumeric && (s = Math.ceil(a / l), --s), null),
                h = n.globals.seriesXvalues.map(function (e) {
                    return e.filter(function (e) {
                        return R.isNumber(e)
                    })
                }), l = n.globals.seriesYvalues.map(function (e) {
                    return e.filter(function (e) {
                        return R.isNumber(e)
                    })
                });
            return n.globals.isXNumeric && (r = a * ((t = this.ttCtx.getElGrid().getBoundingClientRect()).width / r), c = (t = this.closestInMultiArray(r, t.height / o * e, h, l)).index, s = t.j, null !== c) && (h = n.globals.seriesXvalues[c], s = this.closestInArray(r, h).index), n.globals.capturedSeriesIndex = null === c ? -1 : c, (!s || s < 1) && (s = 0), n.globals.isBarHorizontal ? n.globals.capturedDataPointIndex = i : n.globals.capturedDataPointIndex = s, {
                capturedSeries: c,
                j: n.globals.isBarHorizontal ? i : s,
                hoverX: a,
                hoverY: e
            }
        }
    }, {
        key: "closestInMultiArray", value: function (i, s, e, t) {
            var a, n = this.w, r = 0, o = null, l = -1,
                n = (1 < n.globals.series.length ? r = this.getFirstActiveXArray(e) : o = 0, e[r][0]),
                c = Math.abs(i - n);
            return e.forEach(function (e) {
                e.forEach(function (e, t) {
                    e = Math.abs(i - e);
                    e <= c && (c = e, l = t)
                })
            }), -1 !== l && (n = t[r][l], a = Math.abs(s - n), o = r, t.forEach(function (e, t) {
                e = Math.abs(s - e[l]);
                e <= a && (a = e, o = t)
            })), {index: o, j: l}
        }
    }, {
        key: "getFirstActiveXArray", value: function (e) {
            for (var t = this.w, i = 0, s = e.map(function (e, t) {
                return 0 < e.length ? t : -1
            }), a = 0; a < s.length; a++) if (-1 !== s[a] && -1 === t.globals.collapsedSeriesIndices.indexOf(a) && -1 === t.globals.ancillaryCollapsedSeriesIndices.indexOf(a)) {
                i = s[a];
                break
            }
            return i
        }
    }, {
        key: "closestInArray", value: function (e, t) {
            for (var i = t[0], s = null, a = Math.abs(e - i), n = 0; n < t.length; n++) {
                var r = Math.abs(e - t[n]);
                r < a && (a = r, s = n)
            }
            return {index: s}
        }
    }, {
        key: "isXoverlap", value: function (e) {
            var t = [], i = this.w.globals.seriesX.filter(function (e) {
                return void 0 !== e[0]
            });
            if (0 < i.length) for (var s = 0; s < i.length - 1; s++) void 0 !== i[s][e] && void 0 !== i[s + 1][e] && i[s][e] !== i[s + 1][e] && t.push("unEqual");
            return 0 === t.length
        }
    }, {
        key: "isInitialSeriesSameLen", value: function () {
            for (var e = !0, t = this.w.globals.initialSeries, i = 0; i < t.length - 1; i++) if (t[i].data.length !== t[i + 1].data.length) {
                e = !1;
                break
            }
            return e
        }
    }, {
        key: "getBarsHeight", value: function (e) {
            return C(e).reduce(function (e, t) {
                return e + t.getBBox().height
            }, 0)
        }
    }, {
        key: "getElMarkers", value: function (e) {
            return "number" == typeof e ? this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:realIndex='".concat(e, "'] .apexcharts-series-markers-wrap > *")) : this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap > *")
        }
    }, {
        key: "getAllMarkers", value: function () {
            var e = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap"),
                t = ((e = C(e)).sort(function (e, t) {
                    e = Number(e.getAttribute("data:realIndex")), t = Number(t.getAttribute("data:realIndex"));
                    return t < e ? 1 : e < t ? -1 : 0
                }), []);
            return e.forEach(function (e) {
                t.push(e.querySelector(".apexcharts-marker"))
            }), t
        }
    }, {
        key: "hasMarkers", value: function (e) {
            return 0 < this.getElMarkers(e).length
        }
    }, {
        key: "getPathFromPoint", value: function (e, t) {
            var i = Number(e.getAttribute("cx")), s = Number(e.getAttribute("cy")), e = e.getAttribute("shape");
            return new Y(this.ctx).getMarkerPath(i, s, e, t)
        }
    }, {
        key: "getElBars", value: function () {
            return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-boxPlot-series, .apexcharts-rangebar-series")
        }
    }, {
        key: "hasBars", value: function () {
            return 0 < this.getElBars().length
        }
    }, {
        key: "getHoverMarkerSize", value: function (e) {
            var t = this.w, i = t.config.markers.hover.size;
            return i = void 0 === i ? t.globals.markers.size[e] + t.config.markers.hover.sizeOffset : i
        }
    }, {
        key: "toggleAllTooltipSeriesGroups", value: function (e) {
            var t = this.w, i = this.ttCtx;
            0 === i.allTooltipSeriesGroups.length && (i.allTooltipSeriesGroups = t.globals.dom.baseEl.querySelectorAll(".apexcharts-tooltip-series-group"));
            for (var s = i.allTooltipSeriesGroups, a = 0; a < s.length; a++) "enable" === e ? (s[a].classList.add("apexcharts-active"), s[a].style.display = t.config.tooltip.items.display) : (s[a].classList.remove("apexcharts-active"), s[a].style.display = "none")
        }
    }]), wt), We = (e(yt, [{
        key: "drawSeriesTexts", value: function (e) {
            var t = e.shared, t = void 0 === t || t, i = e.ttItems, s = e.i, s = void 0 === s ? 0 : s, a = e.j,
                a = void 0 === a ? null : a, n = e.e, r = this.w,
                e = (void 0 !== r.config.tooltip.custom ? this.handleCustomTooltip({
                    i: s,
                    j: a,
                    y1: e.y1,
                    y2: e.y2,
                    w: r
                }) : this.toggleActiveInactiveSeries(t, s), this.getValuesToPrint({i: s, j: a})),
                r = (this.printLabels({i: s, j: a, values: e, ttItems: i, shared: t, e: n}), this.ttCtx.getElTooltip());
            this.ttCtx.tooltipRect.ttWidth = r.getBoundingClientRect().width, this.ttCtx.tooltipRect.ttHeight = r.getBoundingClientRect().height
        }
    }, {
        key: "printLabels", value: function (e) {
            function a(e) {
                return u.globals.seriesGoals[e] && u.globals.seriesGoals[e][l] && Array.isArray(u.globals.seriesGoals[e][l])
            }

            var n, r = this, o = e.i, l = e.j, t = e.values, c = e.ttItems, h = e.shared, d = e.e, u = this.w, g = [],
                p = t.xVal, f = t.zVal, x = t.xAxisTTVal, m = "", b = u.globals.colors[o];
            null !== l && u.config.plotOptions.bar.distributed && (b = u.globals.colors[l]);
            for (var i = 0, s = u.globals.series.length - 1; i < u.globals.series.length; i++, s--) ((e, t) => {
                var i = r.getFormatters(o), s = (m = r.getSeriesName({
                    fn: i.yLbTitleFormatter,
                    index: o,
                    seriesIndex: o,
                    j: l
                }), "treemap" === u.config.chart.type && (m = i.yLbTitleFormatter(String(u.config.series[o].data[l].x), {
                    series: u.globals.series,
                    seriesIndex: o,
                    dataPointIndex: l,
                    w: u
                })), u.config.tooltip.inverseOrder ? t : e);
                u.globals.axisCharts && (t = function (e) {
                    var t;
                    return u.globals.isRangeData ? i.yLbFormatter(null == (t = u.globals.seriesRangeStart) || null == (t = t[e]) ? void 0 : t[l], {
                        series: u.globals.seriesRangeStart,
                        seriesIndex: e,
                        dataPointIndex: l,
                        w: u
                    }) + " - " + i.yLbFormatter(null == (t = u.globals.seriesRangeEnd) || null == (t = t[e]) ? void 0 : t[l], {
                        series: u.globals.seriesRangeEnd,
                        seriesIndex: e,
                        dataPointIndex: l,
                        w: u
                    }) : i.yLbFormatter(u.globals.series[e][l], {
                        series: u.globals.series,
                        seriesIndex: e,
                        dataPointIndex: l,
                        w: u
                    })
                }, h ? (i = r.getFormatters(s), m = r.getSeriesName({
                    fn: i.yLbTitleFormatter,
                    index: s,
                    seriesIndex: o,
                    j: l
                }), b = u.globals.colors[s], n = t(s), a(s) && (g = u.globals.seriesGoals[s][l].map(function (e) {
                    return {attrs: e, val: i.yLbFormatter(e.value, {seriesIndex: s, dataPointIndex: l, w: u})}
                }))) : ((e = null == d || null == (e = d.target) ? void 0 : e.getAttribute("fill")) && (b = -1 !== e.indexOf("url") ? document.querySelector(e.substr(4).slice(0, -1)).childNodes[0].getAttribute("stroke") : e), n = t(o), a(o) && Array.isArray(u.globals.seriesGoals[o][l]) && (g = u.globals.seriesGoals[o][l].map(function (e) {
                    return {attrs: e, val: i.yLbFormatter(e.value, {seriesIndex: o, dataPointIndex: l, w: u})}
                })))), null === l && (n = i.yLbFormatter(u.globals.series[o], M(M({}, u), {}, {
                    seriesIndex: o,
                    dataPointIndex: o
                }))), r.DOMHandling({
                    i: o,
                    t: s,
                    j: l,
                    ttItems: c,
                    values: {val: n, goalVals: g, xVal: p, xAxisTTVal: x, zVal: f},
                    seriesName: m,
                    shared: h,
                    pColor: b
                })
            })(i, s)
        }
    }, {
        key: "getFormatters", value: function (e) {
            var t, i = this.w, s = i.globals.yLabelFormatters[e];
            return void 0 !== i.globals.ttVal ? Array.isArray(i.globals.ttVal) ? (s = i.globals.ttVal[e] && i.globals.ttVal[e].formatter, t = i.globals.ttVal[e] && i.globals.ttVal[e].title && i.globals.ttVal[e].title.formatter) : (s = i.globals.ttVal.formatter, "function" == typeof i.globals.ttVal.title.formatter && (t = i.globals.ttVal.title.formatter)) : t = i.config.tooltip.y.title.formatter, {
                yLbFormatter: s = "function" != typeof s ? i.globals.yLabelFormatters[0] || function (e) {
                    return e
                } : s, yLbTitleFormatter: t = "function" != typeof t ? function (e) {
                    return e
                } : t
            }
        }
    }, {
        key: "getSeriesName", value: function (e) {
            var t = e.fn, i = e.seriesIndex, s = e.j, a = this.w;
            return t(String(a.globals.seriesNames[e.index]), {
                series: a.globals.series,
                seriesIndex: i,
                dataPointIndex: s,
                w: a
            })
        }
    }, {
        key: "DOMHandling", value: function (e) {
            e.i;
            var t = e.t, i = e.j, s = e.ttItems, a = e.values, n = e.seriesName, r = e.shared, e = e.pColor, o = this.w,
                l = this.ttCtx, c = a.val, h = a.goalVals, d = a.xVal, u = a.xAxisTTVal, a = a.zVal, g = null,
                g = s[t].children,
                u = (o.config.tooltip.fillSeriesColor && (s[t].style.backgroundColor = e, g[0].style.display = "none"), l.showTooltipTitle && (null === l.tooltipTitle && (l.tooltipTitle = o.globals.dom.baseEl.querySelector(".apexcharts-tooltip-title")), l.tooltipTitle.innerHTML = d), l.isXAxisTooltipEnabled && (l.xaxisTooltipText.innerHTML = "" !== u ? u : d), s[t].querySelector(".apexcharts-tooltip-text-y-label")),
                d = (u && (u.innerHTML = n || ""), s[t].querySelector(".apexcharts-tooltip-text-y-value")),
                p = (d && (d.innerHTML = void 0 !== c ? c : ""), g[0] && g[0].classList.contains("apexcharts-tooltip-marker") && (o.config.tooltip.marker.fillColors && Array.isArray(o.config.tooltip.marker.fillColors) && (e = o.config.tooltip.marker.fillColors[t]), g[0].style.backgroundColor = e), o.config.tooltip.marker.show || (g[0].style.display = "none"), s[t].querySelector(".apexcharts-tooltip-text-goals-label")),
                f = s[t].querySelector(".apexcharts-tooltip-text-goals-value");
            h.length && o.globals.seriesGoals[t] && (u = function () {
                var i = "<div >", s = "<div>";
                h.forEach(function (e, t) {
                    i += ' <div style="display: flex"><span class="apexcharts-tooltip-marker" style="background-color: '.concat(e.attrs.strokeColor, '; height: 3px; border-radius: 0; top: 5px;"></span> ').concat(e.attrs.name, "</div>"), s += "<div>".concat(e.val, "</div>")
                }), p.innerHTML = i + "</div>", f.innerHTML = s + "</div>"
            }, !r || o.globals.seriesGoals[t][i] && Array.isArray(o.globals.seriesGoals[t][i])) ? u() : (p.innerHTML = "", f.innerHTML = ""), null !== a && (s[t].querySelector(".apexcharts-tooltip-text-z-label").innerHTML = o.config.tooltip.z.title, s[t].querySelector(".apexcharts-tooltip-text-z-value").innerHTML = void 0 !== a ? a : ""), r && g[0] ? (o.config.tooltip.hideEmptySeries && (n = s[t].querySelector(".apexcharts-tooltip-marker"), d = s[t].querySelector(".apexcharts-tooltip-text"), 0 == parseFloat(c) ? (n.style.display = "none", d.style.display = "none") : (n.style.display = "block", d.style.display = "block")), null == c || -1 < o.globals.ancillaryCollapsedSeriesIndices.indexOf(t) || -1 < o.globals.collapsedSeriesIndices.indexOf(t) || Array.isArray(l.tConfig.enabledOnSeries) && -1 === l.tConfig.enabledOnSeries.indexOf(t) ? g[0].parentNode.style.display = "none" : g[0].parentNode.style.display = o.config.tooltip.items.display) : Array.isArray(l.tConfig.enabledOnSeries) && -1 === l.tConfig.enabledOnSeries.indexOf(t) && (g[0].parentNode.style.display = "none")
        }
    }, {
        key: "toggleActiveInactiveSeries", value: function (e, t) {
            var i = this.w;
            e ? this.tooltipUtil.toggleAllTooltipSeriesGroups("enable") : (this.tooltipUtil.toggleAllTooltipSeriesGroups("disable"), (e = i.globals.dom.baseEl.querySelector(".apexcharts-tooltip-series-group-".concat(t))) && (e.classList.add("apexcharts-active"), e.style.display = i.config.tooltip.items.display))
        }
    }, {
        key: "getValuesToPrint", value: function (e) {
            var t = e.i, e = e.j, i = this.w, s = this.ctx.series.filteredSeriesX(), a = "", n = "", r = null, o = null,
                l = {series: i.globals.series, seriesIndex: t, dataPointIndex: e, w: i}, c = i.globals.ttZFormatter,
                s = (null === e ? o = i.globals.series[t] : i.globals.isXNumeric && "treemap" !== i.config.chart.type ? (a = s[t][e], 0 === s[t].length && (a = s[this.tooltipUtil.getFirstActiveXArray(s)][e])) : a = void 0 !== i.globals.labels[e] ? i.globals.labels[e] : "", a),
                a = i.globals.isXNumeric && "datetime" === i.config.xaxis.type ? new f(this.ctx).xLabelFormat(i.globals.ttKeyFormatter, s, s, {
                    i: void 0,
                    dateFormatter: new y(this.ctx).formatDate,
                    w: this.w
                }) : i.globals.isBarHorizontal ? i.globals.yLabelFormatters[0](s, l) : i.globals.xLabelFormatter(s, l);
            return void 0 !== i.config.tooltip.x.formatter && (a = i.globals.ttKeyFormatter(s, l)), 0 < i.globals.seriesZ.length && 0 < i.globals.seriesZ[t].length && (r = c(i.globals.seriesZ[t][e], i)), n = "function" == typeof i.config.xaxis.tooltip.formatter ? i.globals.xaxisTooltipFormatter(s, l) : a, {
                val: Array.isArray(o) ? o.join(" ") : o,
                xVal: Array.isArray(a) ? a.join(" ") : a,
                xAxisTTVal: Array.isArray(n) ? n.join(" ") : n,
                zVal: r
            }
        }
    }, {
        key: "handleCustomTooltip", value: function (e) {
            var t = e.i, i = e.j, s = e.y1, a = e.y2, e = e.w, n = this.ttCtx.getElTooltip(),
                r = e.config.tooltip.custom;
            Array.isArray(r) && r[t] && (r = r[t]), n.innerHTML = r({
                ctx: this.ctx,
                series: e.globals.series,
                seriesIndex: t,
                dataPointIndex: i,
                y1: s,
                y2: a,
                w: e
            })
        }
    }]), yt), Be = (e(vt, [{
        key: "moveXCrosshairs", value: function (e) {
            var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : null, i = this.ttCtx, s = this.w,
                a = i.getElXCrosshairs(), e = e - i.xcrosshairsWidth / 2, n = s.globals.labels.slice().length;
            null !== t && (e = s.globals.gridWidth / n * t), null === a || s.globals.isBarHorizontal || (a.setAttribute("x", e), a.setAttribute("x1", e), a.setAttribute("x2", e), a.setAttribute("y2", s.globals.gridHeight), a.classList.add("apexcharts-active")), (e = e < 0 ? 0 : e) > s.globals.gridWidth && (e = s.globals.gridWidth), i.isXAxisTooltipEnabled && (n = e, "tickWidth" !== s.config.xaxis.crosshairs.width && "barWidth" !== s.config.xaxis.crosshairs.width || (n = e + i.xcrosshairsWidth / 2), this.moveXAxisTooltip(n))
        }
    }, {
        key: "moveYCrosshairs", value: function (e) {
            var t = this.ttCtx;
            null !== t.ycrosshairs && Y.setAttrs(t.ycrosshairs, {
                y1: e,
                y2: e
            }), null !== t.ycrosshairsHidden && Y.setAttrs(t.ycrosshairsHidden, {y1: e, y2: e})
        }
    }, {
        key: "moveXAxisTooltip", value: function (e) {
            var t, i = this.w, s = this.ttCtx;
            null !== s.xaxisTooltip && 0 !== s.xcrosshairsWidth && (s.xaxisTooltip.classList.add("apexcharts-active"), t = s.xaxisOffY + i.config.xaxis.tooltip.offsetY + i.globals.translateY + 1 + i.config.xaxis.offsetY, e -= s.xaxisTooltip.getBoundingClientRect().width / 2, isNaN(e) || (e += i.globals.translateX, i = new Y(this.ctx).getTextRects(s.xaxisTooltipText.innerHTML), s.xaxisTooltipText.style.minWidth = i.width + "px", s.xaxisTooltip.style.left = e + "px", s.xaxisTooltip.style.top = t + "px"))
        }
    }, {
        key: "moveYAxisTooltip", value: function (e) {
            var t = this.w, i = this.ttCtx,
                s = (null === i.yaxisTTEls && (i.yaxisTTEls = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip")), parseInt(i.ycrosshairsHidden.getAttribute("y1"), 10)),
                s = t.globals.translateY + s, a = i.yaxisTTEls[e].getBoundingClientRect().height,
                n = t.globals.translateYAxisX[e] - 2;
            t.config.yaxis[e].opposite && (n -= 26), s -= a / 2, -1 === t.globals.ignoreYAxisIndexes.indexOf(e) ? (i.yaxisTTEls[e].classList.add("apexcharts-active"), i.yaxisTTEls[e].style.top = s + "px", i.yaxisTTEls[e].style.left = n + t.config.yaxis[e].tooltip.offsetX + "px") : i.yaxisTTEls[e].classList.remove("apexcharts-active")
        }
    }, {
        key: "moveTooltip", value: function (e, t) {
            var i = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null, s = this.w, a = this.ttCtx,
                n = a.getElTooltip(), r = a.tooltipRect, i = null !== i ? parseFloat(i) : 1, e = parseFloat(e) + i + 5,
                t = parseFloat(t) + i / 2;
            (e = (e = e > s.globals.gridWidth / 2 ? e - r.ttWidth - i - 10 : e) > s.globals.gridWidth - r.ttWidth - 10 ? s.globals.gridWidth - r.ttWidth : e) < -20 && (e = -20), s.config.tooltip.followCursor ? (i = a.getElGrid().getBoundingClientRect(), (e = a.e.clientX - i.left) > s.globals.gridWidth / 2 && (e -= a.tooltipRect.ttWidth), (t = a.e.clientY + s.globals.translateY - i.top) > s.globals.gridHeight / 2 && (t -= a.tooltipRect.ttHeight)) : s.globals.isBarHorizontal || r.ttHeight / 2 + t > s.globals.gridHeight && (t = s.globals.gridHeight - r.ttHeight + s.globals.translateY), isNaN(e) || (e += s.globals.translateX, n.style.left = e + "px", n.style.top = t + "px")
        }
    }, {
        key: "moveMarkers", value: function (e, t) {
            var i = this.w, s = this.ttCtx;
            if (0 < i.globals.markers.size[e]) for (var a = i.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(e, "'] .apexcharts-marker")), n = 0; n < a.length; n++) parseInt(a[n].getAttribute("rel"), 10) === t && (s.marker.resetPointsSize(), s.marker.enlargeCurrentPoint(t, a[n])); else s.marker.resetPointsSize(), this.moveDynamicPointOnHover(t, e)
        }
    }, {
        key: "moveDynamicPointOnHover", value: function (e, t) {
            var i = this.w, s = this.ttCtx, a = new Y(this.ctx), n = i.globals.pointsArray,
                r = s.tooltipUtil.getHoverMarkerSize(t), o = i.config.series[t].type;
            o && ("column" === o || "candlestick" === o || "boxPlot" === o) || (o = null == (o = n[t][e]) ? void 0 : o[0], e = (null == (n = n[t][e]) ? void 0 : n[1]) || 0, (n = i.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(t, "'] .apexcharts-series-markers path"))) && e < i.globals.gridHeight && 0 < e && (t = n.getAttribute("shape"), i = a.getMarkerPath(o, e, t, 1.5 * r), n.setAttribute("d", i)), this.moveXCrosshairs(o), s.fixedTooltip) || this.moveTooltip(o, e, r)
        }
    }, {
        key: "moveDynamicPointsOnHover", value: function (e) {
            var t = this.ttCtx, i = t.w, s = 0, a = 0, n = i.globals.pointsArray, r = new T(this.ctx),
                o = new Y(this.ctx), r = r.getActiveConfigSeriesIndex("asc", ["line", "area", "scatter", "bubble"]),
                l = t.tooltipUtil.getHoverMarkerSize(r),
                c = (n[r] && (s = n[r][e][0], a = n[r][e][1]), t.tooltipUtil.getAllMarkers());
            if (null !== c) for (var h = 0; h < i.globals.series.length; h++) {
                var d, u, g, p = n[h];
                i.globals.comboCharts && void 0 === p && c.splice(h, 0, null), p && p.length && (p = n[h][e][1], u = void 0, c[h].setAttribute("cx", s), d = c[h].getAttribute("shape"), "rangeArea" !== i.config.chart.type || i.globals.comboCharts || (g = e + i.globals.series[h].length, u = n[h][g][1], p -= Math.abs(p - u) / 2), null !== p && !isNaN(p) && p < i.globals.gridHeight + l && 0 < p + l ? (g = o.getMarkerPath(s, p, d, l), c[h].setAttribute("d", g)) : c[h].setAttribute("d", ""))
            }
            this.moveXCrosshairs(s), t.fixedTooltip || this.moveTooltip(s, a || i.globals.gridHeight, l)
        }
    }, {
        key: "moveStickyTooltipOverBars", value: function (e, t) {
            var i = this.w, s = this.ttCtx, a = (i.globals.columnSeries || i.globals.series).length,
                n = 2 <= a && a % 2 == 0 ? Math.floor(a / 2) : Math.floor(a / 2) + 1,
                n = (i.globals.isBarHorizontal && (n = new T(this.ctx).getActiveConfigSeriesIndex("desc") + 1), i.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(n, "'] path[j='").concat(e, "'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(n, "'] path[j='").concat(e, "'], .apexcharts-boxPlot-series .apexcharts-series[rel='").concat(n, "'] path[j='").concat(e, "'], .apexcharts-rangebar-series .apexcharts-series[rel='").concat(n, "'] path[j='").concat(e, "']"))),
                t = (n = n || "number" != typeof t ? n : i.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[data\\:realIndex='".concat(t, "'] path[j='").concat(e, "'],\n        .apexcharts-candlestick-series .apexcharts-series[data\\:realIndex='").concat(t, "'] path[j='").concat(e, "'],\n        .apexcharts-boxPlot-series .apexcharts-series[data\\:realIndex='").concat(t, "'] path[j='").concat(e, "'],\n        .apexcharts-rangebar-series .apexcharts-series[data\\:realIndex='").concat(t, "'] path[j='").concat(e, "']"))) ? parseFloat(n.getAttribute("cx")) : 0,
                r = n ? parseFloat(n.getAttribute("cy")) : 0, o = n ? parseFloat(n.getAttribute("barWidth")) : 0,
                l = s.getElGrid().getBoundingClientRect(),
                c = n && (n.classList.contains("apexcharts-candlestick-area") || n.classList.contains("apexcharts-boxPlot-area"));
            i.globals.isXNumeric ? (n && !c && (t -= a % 2 != 0 ? o / 2 : 0), n && c && i.globals.comboCharts && (t -= o / 2)) : i.globals.isBarHorizontal || (t = s.xAxisTicksPositions[e - 1] + s.dataPointsDividedWidth / 2, isNaN(t) && (t = s.xAxisTicksPositions[e] - s.dataPointsDividedWidth / 2)), i.globals.isBarHorizontal ? r -= s.tooltipRect.ttHeight : i.config.tooltip.followCursor ? r = s.e.clientY - l.top - s.tooltipRect.ttHeight / 2 : r + s.tooltipRect.ttHeight + 15 > i.globals.gridHeight && (r = i.globals.gridHeight), i.globals.isBarHorizontal || this.moveXCrosshairs(t), s.fixedTooltip || this.moveTooltip(t, r || i.globals.gridHeight)
        }
    }]), vt), je = (e(bt, [{
        key: "drawDynamicPoints", value: function () {
            var e = this.w, t = new Y(this.ctx), i = new k(this.ctx),
                s = C(s = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series"));
            e.config.chart.stacked && s.sort(function (e, t) {
                return parseFloat(e.getAttribute("data:realIndex")) - parseFloat(t.getAttribute("data:realIndex"))
            });
            for (var a = 0; a < s.length; a++) {
                var n, r, o = s[a].querySelector(".apexcharts-series-markers-wrap");
                null !== o && (n = void 0, r = "apexcharts-marker w".concat((Math.random() + 1).toString(36).substring(4)), "line" !== e.config.chart.type && "area" !== e.config.chart.type || e.globals.comboCharts || e.config.tooltip.intersect || (r += " no-pointer-events"), r = i.getMarkerConfig({
                    cssClass: r,
                    seriesIndex: Number(o.getAttribute("data:realIndex"))
                }), (n = t.drawMarker(0, 0, r)).node.setAttribute("default-marker-size", 0), (r = document.createElementNS(e.globals.SVGNS, "g")).classList.add("apexcharts-series-markers"), r.appendChild(n.node), o.appendChild(r))
            }
        }
    }, {
        key: "enlargeCurrentPoint", value: function (e, t) {
            var i = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null,
                s = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null, a = this.w,
                e = ("bubble" !== a.config.chart.type && this.newPointSize(e, t), t.getAttribute("cx")),
                t = t.getAttribute("cy");
            null !== i && null !== s && (e = i, t = s), this.tooltipPosition.moveXCrosshairs(e), this.fixedTooltip || ("radar" === a.config.chart.type && (i = this.ttCtx.getElGrid().getBoundingClientRect(), e = this.ttCtx.e.clientX - i.left), this.tooltipPosition.moveTooltip(e, t, a.config.markers.hover.size))
        }
    }, {
        key: "enlargePoints", value: function (e) {
            for (var t = this.w, i = this.ttCtx, s = e, a = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), n = t.config.markers.hover.size, r = 0; r < a.length; r++) {
                var o = a[r].getAttribute("rel"), l = a[r].getAttribute("index");
                void 0 === n && (n = t.globals.markers.size[l] + t.config.markers.hover.sizeOffset), s === parseInt(o, 10) ? (this.newPointSize(s, a[r]), l = a[r].getAttribute("cx"), o = a[r].getAttribute("cy"), this.tooltipPosition.moveXCrosshairs(l), i.fixedTooltip || this.tooltipPosition.moveTooltip(l, o, n)) : this.oldPointSize(a[r])
            }
        }
    }, {
        key: "newPointSize", value: function (e, t) {
            var i = this.w, s = i.config.markers.hover.size,
                e = 0 === e ? t.parentNode.firstChild : t.parentNode.lastChild;
            "0" !== e.getAttribute("default-marker-size") && (e = parseInt(e.getAttribute("index"), 10), void 0 === s && (s = i.globals.markers.size[e] + i.config.markers.hover.sizeOffset), e = this.ttCtx.tooltipUtil.getPathFromPoint(t, s = s < 0 ? 0 : s), t.setAttribute("d", e))
        }
    }, {
        key: "oldPointSize", value: function (e) {
            var t = parseFloat(e.getAttribute("default-marker-size")),
                t = this.ttCtx.tooltipUtil.getPathFromPoint(e, t);
            e.setAttribute("d", t)
        }
    }, {
        key: "resetPointsSize", value: function () {
            for (var e = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), t = 0; t < e.length; t++) {
                var i = parseFloat(e[t].getAttribute("default-marker-size"));
                R.isNumber(i) && 0 <= i ? (i = this.ttCtx.tooltipUtil.getPathFromPoint(e[t], i), e[t].setAttribute("d", i)) : e[t].setAttribute("d", "M0,0")
            }
        }
    }]), bt), Ge = (e(mt, [{
        key: "getAttr", value: function (e, t) {
            return parseFloat(e.target.getAttribute(t))
        }
    }, {
        key: "handleHeatTreeTooltip", value: function (e) {
            var t, i, s, a, n, r = e.e, o = e.opt, l = e.x, c = e.y, h = this.ttCtx, d = this.w;
            return r.target.classList.contains("apexcharts-".concat(e.type, "-rect")) && (e = this.getAttr(r, "i"), t = this.getAttr(r, "j"), i = this.getAttr(r, "cx"), s = this.getAttr(r, "cy"), a = this.getAttr(r, "width"), n = this.getAttr(r, "height"), h.tooltipLabels.drawSeriesTexts({
                ttItems: o.ttItems,
                i: e,
                j: t,
                shared: !1,
                e: r
            }), d.globals.capturedSeriesIndex = e, d.globals.capturedDataPointIndex = t, l = i + h.tooltipRect.ttWidth / 2 + a, c = s + h.tooltipRect.ttHeight / 2 - n / 2, h.tooltipPosition.moveXCrosshairs(i + a / 2), l > d.globals.gridWidth / 2 && (l = i - h.tooltipRect.ttWidth / 2 + a), h.w.config.tooltip.followCursor) && (o = d.globals.dom.elWrap.getBoundingClientRect(), l = d.globals.clientX - o.left - (l > d.globals.gridWidth / 2 ? h.tooltipRect.ttWidth : 0), c = d.globals.clientY - o.top - (c > d.globals.gridHeight / 2 ? h.tooltipRect.ttHeight : 0)), {
                x: l,
                y: c
            }
        }
    }, {
        key: "handleMarkerTooltip", value: function (e) {
            var t, i, s, a, n, r, o = e.e, l = e.opt, c = e.x, e = e.y, h = this.w, d = this.ttCtx;
            return o.target.classList.contains("apexcharts-marker") && (t = parseInt(l.paths.getAttribute("cx"), 10), i = parseInt(l.paths.getAttribute("cy"), 10), s = parseFloat(l.paths.getAttribute("val")), a = parseInt(l.paths.getAttribute("rel"), 10), n = parseInt(l.paths.parentNode.parentNode.parentNode.getAttribute("rel"), 10) - 1, d.intersect && (r = R.findAncestor(l.paths, "apexcharts-series")) && (n = parseInt(r.getAttribute("data:realIndex"), 10)), d.tooltipLabels.drawSeriesTexts({
                ttItems: l.ttItems,
                i: n,
                j: a,
                shared: !d.showOnIntersect && h.config.tooltip.shared,
                e: o
            }), "mouseup" === o.type && d.markerClick(o, n, a), h.globals.capturedSeriesIndex = n, h.globals.capturedDataPointIndex = a, c = t, e = i + h.globals.translateY - 1.4 * d.tooltipRect.ttHeight, d.w.config.tooltip.followCursor && (r = d.getElGrid().getBoundingClientRect(), e = d.e.clientY + h.globals.translateY - r.top), d.marker.enlargeCurrentPoint(a, l.paths, c, e = s < 0 ? i : e)), {
                x: c,
                y: e
            }
        }
    }, {
        key: "handleBarTooltip", value: function (e) {
            var t, i = e.e, e = e.opt, s = this.w, a = this.ttCtx, n = a.getElTooltip(), r = 0, o = 0, l = 0,
                i = this.getBarTooltipXY({e: i, opt: e}), c = i.i, h = i.j,
                h = (s.globals.capturedSeriesIndex = c, s.globals.capturedDataPointIndex = h, s.globals.isBarHorizontal && a.tooltipUtil.hasBars() || !s.config.tooltip.shared ? (o = i.x, l = i.y, t = Array.isArray(s.config.stroke.width) ? s.config.stroke.width[c] : s.config.stroke.width, r = o) : s.globals.comboCharts || s.config.tooltip.shared || (r /= 2), isNaN(l) && (l = s.globals.svgHeight - a.tooltipRect.ttHeight), parseInt(e.paths.parentNode.getAttribute("data:realIndex"), 10));
            s.globals.isMultipleYAxis ? s.config.yaxis[h] && s.config.yaxis[h].reversed : s.config.yaxis[0].reversed, o + a.tooltipRect.ttWidth > s.globals.gridWidth ? o -= a.tooltipRect.ttWidth : o < 0 && (o = 0), a.w.config.tooltip.followCursor && (i = a.getElGrid().getBoundingClientRect(), l = a.e.clientY - i.top), null === a.tooltip && (a.tooltip = s.globals.dom.baseEl.querySelector(".apexcharts-tooltip")), s.config.tooltip.shared || (0 < s.globals.comboBarCount ? a.tooltipPosition.moveXCrosshairs(r + t / 2) : a.tooltipPosition.moveXCrosshairs(r)), !a.fixedTooltip && (!s.config.tooltip.shared || s.globals.isBarHorizontal && a.tooltipUtil.hasBars()) && (l = l + s.globals.translateY - a.tooltipRect.ttHeight / 2, n.style.left = o + s.globals.translateX + "px", n.style.top = l + "px")
        }
    }, {
        key: "getBarTooltipXY", value: function (e) {
            var t, i, s, a, n, r, o, l, c, h = this, d = e.e, e = e.opt, u = this.w, g = null, p = this.ttCtx, f = 0,
                x = 0, m = 0, b = 0, v = 0, y = d.target.classList;
            return (y.contains("apexcharts-bar-area") || y.contains("apexcharts-candlestick-area") || y.contains("apexcharts-boxPlot-area") || y.contains("apexcharts-rangebar-area")) && (r = (y = d.target).getBoundingClientRect(), t = e.elGrid.getBoundingClientRect(), i = r.height, v = r.height, s = r.width, a = parseInt(y.getAttribute("cx"), 10), n = parseInt(y.getAttribute("cy"), 10), b = parseFloat(y.getAttribute("barWidth")), r = ("touchmove" === d.type ? d.touches[0] : d).clientX, g = parseInt(y.getAttribute("j"), 10), f = parseInt(y.parentNode.getAttribute("rel"), 10) - 1, o = y.getAttribute("data-range-y1"), l = y.getAttribute("data-range-y2"), u.globals.comboCharts && (f = parseInt(y.parentNode.getAttribute("data:realIndex"), 10)), y = function (e) {
                return u.globals.isXNumeric ? a - s / 2 : h.isVerticalGroupedRangeBar ? a + s / 2 : a - p.dataPointsDividedWidth + s / 2
            }, c = function () {
                return n - p.dataPointsDividedHeight + i / 2 - p.tooltipRect.ttHeight / 2
            }, p.tooltipLabels.drawSeriesTexts({
                ttItems: e.ttItems,
                i: f,
                j: g,
                y1: o ? parseInt(o, 10) : null,
                y2: l ? parseInt(l, 10) : null,
                shared: !p.showOnIntersect && u.config.tooltip.shared,
                e: d
            }), m = u.config.tooltip.followCursor ? u.globals.isBarHorizontal ? (x = r - t.left + 15, c()) : (x = y(), d.clientY - t.top - p.tooltipRect.ttHeight / 2 - 15) : u.globals.isBarHorizontal ? ((x = a) < p.xyRatios.baseLineInvertedY && (x = a - p.tooltipRect.ttWidth), c()) : (x = y(), n)), {
                x: x,
                y: m,
                barHeight: v,
                barWidth: b,
                i: f,
                j: g
            }
        }
    }]), mt), Ve = (e(xt, [{
        key: "drawXaxisTooltip", value: function () {
            var e = this.w, t = this.ttCtx, i = "bottom" === e.config.xaxis.position,
                i = (t.xaxisOffY = i ? e.globals.gridHeight + 1 : -e.globals.xAxisHeight - e.config.xaxis.axisTicks.height + 3, i ? "apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom" : "apexcharts-xaxistooltip apexcharts-xaxistooltip-top"),
                s = e.globals.dom.elWrap;
            t.isXAxisTooltipEnabled && null === e.globals.dom.baseEl.querySelector(".apexcharts-xaxistooltip") && (t.xaxisTooltip = document.createElement("div"), t.xaxisTooltip.setAttribute("class", i + " apexcharts-theme-" + e.config.tooltip.theme), s.appendChild(t.xaxisTooltip), t.xaxisTooltipText = document.createElement("div"), t.xaxisTooltipText.classList.add("apexcharts-xaxistooltip-text"), t.xaxisTooltipText.style.fontFamily = e.config.xaxis.tooltip.style.fontFamily || e.config.chart.fontFamily, t.xaxisTooltipText.style.fontSize = e.config.xaxis.tooltip.style.fontSize, t.xaxisTooltip.appendChild(t.xaxisTooltipText))
        }
    }, {
        key: "drawYaxisTooltip", value: function () {
            for (var e = this.w, t = this.ttCtx, i = 0; i < e.config.yaxis.length; i++) {
                var s = e.config.yaxis[i].opposite || e.config.yaxis[i].crosshairs.opposite,
                    s = (t.yaxisOffX = s ? e.globals.gridWidth + 1 : 1, "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i, s ? " apexcharts-yaxistooltip-right" : " apexcharts-yaxistooltip-left")),
                    a = e.globals.dom.elWrap;
                null === e.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i)) && (t.yaxisTooltip = document.createElement("div"), t.yaxisTooltip.setAttribute("class", s + " apexcharts-theme-" + e.config.tooltip.theme), a.appendChild(t.yaxisTooltip), 0 === i && (t.yaxisTooltipText = []), t.yaxisTooltipText[i] = document.createElement("div"), t.yaxisTooltipText[i].classList.add("apexcharts-yaxistooltip-text"), t.yaxisTooltip.appendChild(t.yaxisTooltipText[i]))
            }
        }
    }, {
        key: "setXCrosshairWidth", value: function () {
            var e, t = this.w, i = this.ttCtx, s = i.getElXCrosshairs();
            i.xcrosshairsWidth = parseInt(t.config.xaxis.crosshairs.width, 10), t.globals.comboCharts ? null !== (e = t.globals.dom.baseEl.querySelector(".apexcharts-bar-area")) && "barWidth" === t.config.xaxis.crosshairs.width ? (e = parseFloat(e.getAttribute("barWidth")), i.xcrosshairsWidth = e) : "tickWidth" === t.config.xaxis.crosshairs.width && (e = t.globals.labels.length, i.xcrosshairsWidth = t.globals.gridWidth / e) : "tickWidth" === t.config.xaxis.crosshairs.width ? (e = t.globals.labels.length, i.xcrosshairsWidth = t.globals.gridWidth / e) : "barWidth" === t.config.xaxis.crosshairs.width && (null !== (e = t.globals.dom.baseEl.querySelector(".apexcharts-bar-area")) ? (e = parseFloat(e.getAttribute("barWidth")), i.xcrosshairsWidth = e) : i.xcrosshairsWidth = 1), t.globals.isBarHorizontal && (i.xcrosshairsWidth = 0), null !== s && 0 < i.xcrosshairsWidth && s.setAttribute("width", i.xcrosshairsWidth)
        }
    }, {
        key: "handleYCrosshair", value: function () {
            var e = this.w, t = this.ttCtx;
            t.ycrosshairs = e.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs"), t.ycrosshairsHidden = e.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs-hidden")
        }
    }, {
        key: "drawYaxisTooltipText", value: function (e, t, i) {
            var s, a, n, r, o = this.ttCtx, l = this.w, c = l.globals, h = c.seriesYAxisMap[e];
            o.yaxisTooltips[e] && 0 < h.length && (s = c.yLabelFormatters[e], a = o.getElGrid().getBoundingClientRect(), h = h[0], n = 0, 1 < i.yRatio.length && (n = h), i = (t - a.top) * i.yRatio[n], n = c.maxYArr[h] - c.minYArr[h], r = c.minYArr[h] + (n - i), l.config.yaxis[e].reversed && (r = c.maxYArr[h] - (n - i)), o.tooltipPosition.moveYCrosshairs(t - a.top), o.yaxisTooltipText[e].innerHTML = s(r), o.tooltipPosition.moveYAxisTooltip(e))
        }
    }]), xt), qe = (e(ft, [{
        key: "getElTooltip", value: function (e) {
            return (e = e || this).w.globals.dom.baseEl ? e.w.globals.dom.baseEl.querySelector(".apexcharts-tooltip") : null
        }
    }, {
        key: "getElXCrosshairs", value: function () {
            return this.w.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs")
        }
    }, {
        key: "getElGrid", value: function () {
            return this.w.globals.dom.baseEl.querySelector(".apexcharts-grid")
        }
    }, {
        key: "drawTooltip", value: function (e) {
            var t, i = this.w,
                e = (this.xyRatios = e, this.isXAxisTooltipEnabled = i.config.xaxis.tooltip.enabled && i.globals.axisCharts, this.yaxisTooltips = i.config.yaxis.map(function (e, t) {
                    return !!(e.show && e.tooltip.enabled && i.globals.axisCharts)
                }), this.allTooltipSeriesGroups = [], i.globals.axisCharts || (this.showTooltipTitle = !1), document.createElement("div"));
            e.classList.add("apexcharts-tooltip"), i.config.tooltip.cssClass && e.classList.add(i.config.tooltip.cssClass), e.classList.add("apexcharts-theme-".concat(this.tConfig.theme)), i.globals.dom.elWrap.appendChild(e), i.globals.axisCharts && (this.axesTooltip.drawXaxisTooltip(), this.axesTooltip.drawYaxisTooltip(), this.axesTooltip.setXCrosshairWidth(), this.axesTooltip.handleYCrosshair(), t = new g(this.ctx), this.xAxisTicksPositions = t.getXAxisTicksPositions()), !i.globals.comboCharts && !this.tConfig.intersect && "rangeBar" !== i.config.chart.type || this.tConfig.shared || (this.showOnIntersect = !0), 0 !== i.config.markers.size && 0 !== i.globals.markers.largestSize || this.marker.drawDynamicPoints(this), i.globals.collapsedSeries.length !== i.globals.series.length && (this.dataPointsDividedHeight = i.globals.gridHeight / i.globals.dataPoints, this.dataPointsDividedWidth = i.globals.gridWidth / i.globals.dataPoints, this.showTooltipTitle && (this.tooltipTitle = document.createElement("div"), this.tooltipTitle.classList.add("apexcharts-tooltip-title"), this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || i.config.chart.fontFamily, this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize, e.appendChild(this.tooltipTitle)), t = i.globals.series.length, (i.globals.xyCharts || i.globals.comboCharts) && this.tConfig.shared && (t = this.showOnIntersect ? 1 : i.globals.series.length), this.legendLabels = i.globals.dom.baseEl.querySelectorAll(".apexcharts-legend-text"), this.ttItems = this.createTTElements(t), this.addSVGEvents())
        }
    }, {
        key: "createTTElements", value: function (a) {
            for (var n = this, r = this.w, o = [], l = this.getElTooltip(), e = 0; e < a; e++) (e => {
                var t = document.createElement("div"),
                    i = (t.classList.add("apexcharts-tooltip-series-group", "apexcharts-tooltip-series-group-".concat(e)), t.style.order = r.config.tooltip.inverseOrder ? a - e : e + 1, document.createElement("span")),
                    s = (i.classList.add("apexcharts-tooltip-marker"), i.style.backgroundColor = r.globals.colors[e], t.appendChild(i), document.createElement("div"));
                s.classList.add("apexcharts-tooltip-text"), s.style.fontFamily = n.tConfig.style.fontFamily || r.config.chart.fontFamily, s.style.fontSize = n.tConfig.style.fontSize, ["y", "goals", "z"].forEach(function (e) {
                    var t = document.createElement("div"),
                        i = (t.classList.add("apexcharts-tooltip-".concat(e, "-group")), document.createElement("span")),
                        i = (i.classList.add("apexcharts-tooltip-text-".concat(e, "-label")), t.appendChild(i), document.createElement("span"));
                    i.classList.add("apexcharts-tooltip-text-".concat(e, "-value")), t.appendChild(i), s.appendChild(t)
                }), t.appendChild(s), l.appendChild(t), o.push(t)
            })(e);
            return o
        }
    }, {
        key: "addSVGEvents", value: function () {
            var e = this.w, t = e.config.chart.type, i = this.getElTooltip(),
                s = !("bar" !== t && "candlestick" !== t && "boxPlot" !== t && "rangeBar" !== t),
                a = "area" === t || "line" === t || "scatter" === t || "bubble" === t || "radar" === t,
                n = e.globals.dom.Paper.node, r = this.getElGrid();
            r && (this.seriesBound = r.getBoundingClientRect());
            var o, l = [], c = [],
                r = {hoverArea: n, elGrid: r, tooltipEl: i, tooltipY: l, tooltipX: c, ttItems: this.ttItems};
            if (e.globals.axisCharts && (a ? o = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker") : s ? o = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-boxPlot-area, .apexcharts-series .apexcharts-rangebar-area") : "heatmap" !== t && "treemap" !== t || (o = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-heatmap, .apexcharts-series .apexcharts-treemap")), o) && o.length) for (var h = 0; h < o.length; h++) l.push(o[h].getAttribute("cy")), c.push(o[h].getAttribute("cx"));
            e.globals.xyCharts && !this.showOnIntersect || e.globals.comboCharts && !this.showOnIntersect || s && this.tooltipUtil.hasBars() && this.tConfig.shared ? this.addPathsEventListeners([n], r) : s && !e.globals.comboCharts || a && this.showOnIntersect ? this.addDatapointEventsListeners(r) : e.globals.axisCharts && "heatmap" !== t && "treemap" !== t || (i = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series"), this.addPathsEventListeners(i, r)), this.showOnIntersect && (0 < (n = e.globals.dom.baseEl.querySelectorAll(".apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker")).length && this.addPathsEventListeners(n, r), this.tooltipUtil.hasBars()) && !this.tConfig.shared && this.addDatapointEventsListeners(r)
        }
    }, {
        key: "drawFixedTooltipRect", value: function () {
            var e = this.w, t = this.getElTooltip(), i = t.getBoundingClientRect(), s = i.width + 10, i = i.height + 10,
                a = this.tConfig.fixed.offsetX, n = this.tConfig.fixed.offsetY,
                r = this.tConfig.fixed.position.toLowerCase();
            return -1 < r.indexOf("right") && (a = a + e.globals.svgWidth - s + 10), -1 < r.indexOf("bottom") && (n = n + e.globals.svgHeight - i - 10), t.style.left = a + "px", t.style.top = n + "px", {
                x: a,
                y: n,
                ttWidth: s,
                ttHeight: i
            }
        }
    }, {
        key: "addDatapointEventsListeners", value: function (e) {
            var t = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-boxPlot-area, .apexcharts-rangebar-area");
            this.addPathsEventListeners(t, e)
        }
    }, {
        key: "addPathsEventListeners", value: function (s, e) {
            for (var a = this, t = 0; t < s.length; t++) (t => {
                var i = {
                    paths: s[t],
                    tooltipEl: e.tooltipEl,
                    tooltipY: e.tooltipY,
                    tooltipX: e.tooltipX,
                    elGrid: e.elGrid,
                    hoverArea: e.hoverArea,
                    ttItems: e.ttItems
                };
                ["mousemove", "mouseup", "touchmove", "mouseout", "touchend"].map(function (e) {
                    return s[t].addEventListener(e, a.onSeriesHover.bind(a, i), {capture: !1, passive: !0})
                })
            })(t)
        }
    }, {
        key: "onSeriesHover", value: function (e, t) {
            var i = this, s = Date.now() - this.lastHoverTime;
            100 <= s ? this.seriesHover(e, t) : (clearTimeout(this.seriesHoverTimeout), this.seriesHoverTimeout = setTimeout(function () {
                i.seriesHover(e, t)
            }, 100 - s))
        }
    }, {
        key: "seriesHover", value: function (i, s) {
            var a = this, e = (this.lastHoverTime = Date.now(), []), t = this.w;
            t.config.chart.group && (e = this.ctx.getGroupedCharts()), t.globals.axisCharts && (t.globals.minX === -1 / 0 && t.globals.maxX === 1 / 0 || 0 === t.globals.dataPoints) || (e.length ? e.forEach(function (e) {
                var t = a.getElTooltip(e), t = {
                    paths: i.paths,
                    tooltipEl: t,
                    tooltipY: i.tooltipY,
                    tooltipX: i.tooltipX,
                    elGrid: i.elGrid,
                    hoverArea: i.hoverArea,
                    ttItems: e.w.globals.tooltip.ttItems
                };
                e.w.globals.minX === a.w.globals.minX && e.w.globals.maxX === a.w.globals.maxX && e.w.globals.tooltip.seriesHoverByContext({
                    chartCtx: e,
                    ttCtx: e.w.globals.tooltip,
                    opt: t,
                    e: s
                })
            }) : this.seriesHoverByContext({chartCtx: this.ctx, ttCtx: this.w.globals.tooltip, opt: i, e: s}))
        }
    }, {
        key: "seriesHoverByContext", value: function (e) {
            var t = e.chartCtx, i = e.ttCtx, s = e.opt, e = e.e, a = t.w, n = this.getElTooltip(t);
            n && (i.tooltipRect = {
                x: 0,
                y: 0,
                ttWidth: n.getBoundingClientRect().width,
                ttHeight: n.getBoundingClientRect().height
            }, i.e = e, !i.tooltipUtil.hasBars() || a.globals.comboCharts || i.isBarShared || this.tConfig.onDatasetHover.highlightDataSeries && new T(t).toggleSeriesOnHover(e, e.target.parentNode), i.fixedTooltip && i.drawFixedTooltipRect(), a.globals.axisCharts ? i.axisChartsTooltips({
                e: e,
                opt: s,
                tooltipRect: i.tooltipRect
            }) : i.nonAxisChartsTooltips({e: e, opt: s, tooltipRect: i.tooltipRect}))
        }
    }, {
        key: "axisChartsTooltips", value: function (e) {
            var t = e.e, e = e.opt, i = this.w, s = e.elGrid.getBoundingClientRect(),
                a = ("touchmove" === t.type ? t.touches[0] : t).clientX,
                n = ("touchmove" === t.type ? t.touches[0] : t).clientY;
            if (this.clientY = n, this.clientX = a, i.globals.capturedSeriesIndex = -1, i.globals.capturedDataPointIndex = -1, n < s.top || n > s.top + s.height) this.handleMouseOut(e); else {
                if (Array.isArray(this.tConfig.enabledOnSeries) && !i.config.tooltip.shared) {
                    s = parseInt(e.paths.getAttribute("index"), 10);
                    if (this.tConfig.enabledOnSeries.indexOf(s) < 0) return void this.handleMouseOut(e)
                }
                var s = this.getElTooltip(), r = this.getElXCrosshairs(), o = [],
                    l = (i.config.chart.group && (o = this.ctx.getSyncedCharts()), i.globals.xyCharts || "bar" === i.config.chart.type && !i.globals.isBarHorizontal && this.tooltipUtil.hasBars() && this.tConfig.shared || i.globals.comboCharts && this.tooltipUtil.hasBars());
                if ("mousemove" === t.type || "touchmove" === t.type || "mouseup" === t.type) {
                    if (i.globals.collapsedSeries.length + i.globals.ancillaryCollapsedSeries.length !== i.globals.series.length) {
                        null !== r && r.classList.add("apexcharts-active");
                        var c, h, r = this.yaxisTooltips.filter(function (e) {
                            return !0 === e
                        });
                        if (null !== this.ycrosshairs && r.length && this.ycrosshairs.classList.add("apexcharts-active"), l && !this.showOnIntersect || 1 < o.length ? this.handleStickyTooltip(t, a, n, e) : "heatmap" === i.config.chart.type || "treemap" === i.config.chart.type ? (c = (r = this.intersect.handleHeatTreeTooltip({
                            e: t,
                            opt: e,
                            x: c,
                            y: h,
                            type: i.config.chart.type
                        })).x, h = r.y, s.style.left = c + "px", s.style.top = h + "px") : (this.tooltipUtil.hasBars() && this.intersect.handleBarTooltip({
                            e: t,
                            opt: e
                        }), this.tooltipUtil.hasMarkers() && this.intersect.handleMarkerTooltip({
                            e: t,
                            opt: e,
                            x: c,
                            y: h
                        })), this.yaxisTooltips.length) for (var d = 0; d < i.config.yaxis.length; d++) this.axesTooltip.drawYaxisTooltipText(d, n, this.xyRatios);
                        i.globals.dom.baseEl.classList.add("apexcharts-tooltip-active"), e.tooltipEl.classList.add("apexcharts-active")
                    }
                } else "mouseout" !== t.type && "touchend" !== t.type || this.handleMouseOut(e)
            }
        }
    }, {
        key: "nonAxisChartsTooltips", value: function (e) {
            var t = e.e, i = e.opt, e = e.tooltipRect, s = this.w, a = i.paths.getAttribute("rel"),
                n = this.getElTooltip(), r = s.globals.dom.elWrap.getBoundingClientRect();
            "mousemove" === t.type || "touchmove" === t.type ? (s.globals.dom.baseEl.classList.add("apexcharts-tooltip-active"), n.classList.add("apexcharts-active"), this.tooltipLabels.drawSeriesTexts({
                ttItems: i.ttItems,
                i: parseInt(a, 10) - 1,
                shared: !1
            }), i = s.globals.clientX - r.left - e.ttWidth / 2, r = s.globals.clientY - r.top - e.ttHeight - 10, n.style.left = i + "px", n.style.top = r + "px", s.config.legend.tooltipHoverFormatter && (i = (0, s.config.legend.tooltipHoverFormatter)(this.legendLabels[e = a - 1].getAttribute("data:default-text"), {
                seriesIndex: e,
                dataPointIndex: e,
                w: s
            }), this.legendLabels[e].innerHTML = i)) : "mouseout" !== t.type && "touchend" !== t.type || (n.classList.remove("apexcharts-active"), s.globals.dom.baseEl.classList.remove("apexcharts-tooltip-active"), s.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function (e) {
                var t = e.getAttribute("data:default-text");
                e.innerHTML = decodeURIComponent(t)
            }))
        }
    }, {
        key: "handleStickyTooltip", value: function (e, t, i, s) {
            var a = this.w, t = this.tooltipUtil.getNearestValues({
                    context: this,
                    hoverArea: s.hoverArea,
                    elGrid: s.elGrid,
                    clientX: t,
                    clientY: i
                }), i = t.j, n = t.capturedSeries,
                r = (a.globals.collapsedSeriesIndices.includes(n) && (n = null), s.elGrid.getBoundingClientRect());
            t.hoverX < 0 || t.hoverX > r.width ? this.handleMouseOut(s) : null !== n ? this.handleStickyCapturedSeries(e, n, s, i) : (this.tooltipUtil.isXoverlap(i) || a.globals.isBarHorizontal) && (t = a.globals.series.findIndex(function (e, t) {
                return !a.globals.collapsedSeriesIndices.includes(t)
            }), this.create(e, this, t, i, s.ttItems))
        }
    }, {
        key: "handleStickyCapturedSeries", value: function (e, t, i, s) {
            var a = this.w;
            this.tConfig.shared || null !== a.globals.series[t][s] ? void 0 !== a.globals.series[t][s] ? this.tConfig.shared && this.tooltipUtil.isXoverlap(s) && this.tooltipUtil.isInitialSeriesSameLen() ? this.create(e, this, t, s, i.ttItems) : this.create(e, this, t, s, i.ttItems, !1) : this.tooltipUtil.isXoverlap(s) && (t = a.globals.series.findIndex(function (e, t) {
                return !a.globals.collapsedSeriesIndices.includes(t)
            }), this.create(e, this, t, s, i.ttItems)) : this.handleMouseOut(i)
        }
    }, {
        key: "deactivateHoverFilter", value: function () {
            for (var e = this.w, t = new Y(this.ctx), i = e.globals.dom.Paper.select(".apexcharts-bar-area"), s = 0; s < i.length; s++) t.pathMouseLeave(i[s])
        }
    }, {
        key: "handleMouseOut", value: function (e) {
            var t = this.w, i = this.getElXCrosshairs();
            if (t.globals.dom.baseEl.classList.remove("apexcharts-tooltip-active"), e.tooltipEl.classList.remove("apexcharts-active"), this.deactivateHoverFilter(), "bubble" !== t.config.chart.type && this.marker.resetPointsSize(), null !== i && i.classList.remove("apexcharts-active"), null !== this.ycrosshairs && this.ycrosshairs.classList.remove("apexcharts-active"), this.isXAxisTooltipEnabled && this.xaxisTooltip.classList.remove("apexcharts-active"), this.yaxisTooltips.length) {
                null === this.yaxisTTEls && (this.yaxisTTEls = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
                for (var s = 0; s < this.yaxisTTEls.length; s++) this.yaxisTTEls[s].classList.remove("apexcharts-active")
            }
            t.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function (e) {
                var t = e.getAttribute("data:default-text");
                e.innerHTML = decodeURIComponent(t)
            })
        }
    }, {
        key: "markerClick", value: function (e, t, i) {
            var s = this.w;
            "function" == typeof s.config.chart.events.markerClick && s.config.chart.events.markerClick(e, this.ctx, {
                seriesIndex: t,
                dataPointIndex: i,
                w: s
            }), this.ctx.events.fireEvent("markerClick", [e, this.ctx, {seriesIndex: t, dataPointIndex: i, w: s}])
        }
    }, {
        key: "create", value: function (e, t, i, s, a) {
            var n = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : null, r = this.w,
                e = ("mouseup" === e.type && this.markerClick(e, i, s), null === n && (n = this.tConfig.shared), this.tooltipUtil.hasMarkers(i)),
                o = this.tooltipUtil.getElBars();
            if (r.config.legend.tooltipHoverFormatter) {
                var l = r.config.legend.tooltipHoverFormatter, c = Array.from(this.legendLabels);
                c.forEach(function (e) {
                    var t = e.getAttribute("data:default-text");
                    e.innerHTML = decodeURIComponent(t)
                });
                for (var h = 0; h < c.length; h++) {
                    var d = c[h], u = parseInt(d.getAttribute("i"), 10),
                        g = decodeURIComponent(d.getAttribute("data:default-text")),
                        p = l(g, {seriesIndex: n ? u : i, dataPointIndex: s, w: r});
                    if (n) d.innerHTML = r.globals.collapsedSeriesIndices.indexOf(u) < 0 ? p : g; else if (d.innerHTML = u === i ? p : g, i === u) break
                }
            }
            a = M(M({
                ttItems: a,
                i: i,
                j: s
            }, void 0 !== (null == (a = r.globals.seriesRange) || null == (a = a[i]) || null == (a = a[s]) || null == (a = a.y[0]) ? void 0 : a.y1) && {y1: null == (a = r.globals.seriesRange) || null == (a = a[i]) || null == (a = a[s]) || null == (a = a.y[0]) ? void 0 : a.y1}), void 0 !== (null == (a = r.globals.seriesRange) || null == (a = a[i]) || null == (a = a[s]) || null == (a = a.y[0]) ? void 0 : a.y2) && {y2: null == (a = r.globals.seriesRange) || null == (a = a[i]) || null == (a = a[s]) || null == (a = a.y[0]) ? void 0 : a.y2});
            if (n) {
                if (t.tooltipLabels.drawSeriesTexts(M(M({}, a), {}, {shared: !this.showOnIntersect && this.tConfig.shared})), e) 0 < r.globals.markers.largestSize ? t.marker.enlargePoints(s) : t.tooltipPosition.moveDynamicPointsOnHover(s); else if (this.tooltipUtil.hasBars() && (this.barSeriesHeight = this.tooltipUtil.getBarsHeight(o), 0 < this.barSeriesHeight)) {
                    var f = new Y(this.ctx), x = r.globals.dom.Paper.select(".apexcharts-bar-area[j='".concat(s, "']"));
                    this.deactivateHoverFilter(), this.tooltipPosition.moveStickyTooltipOverBars(s, i);
                    for (var m = 0; m < x.length; m++) f.pathMouseEnter(x[m])
                }
            } else t.tooltipLabels.drawSeriesTexts(M({shared: !1}, a)), this.tooltipUtil.hasBars() && t.tooltipPosition.moveStickyTooltipOverBars(s, i), e && t.tooltipPosition.moveMarkers(i, s)
        }
    }]), ft), Ue = (e(pt, [{
        key: "handleBarDataLabels", value: function (e) {
            var t, i = e.x, s = e.y, a = e.y1, n = e.y2, r = e.i, o = e.j, l = e.realIndex, c = e.columnGroupIndex,
                h = e.series, d = e.barHeight, u = e.barWidth, g = e.barXPosition, p = e.barYPosition,
                f = e.visibleSeries, e = e.renderedPath, x = this.w, m = new Y(this.barCtx.ctx),
                b = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[l] : this.barCtx.strokeWidth,
                f = x.globals.isXNumeric && !x.globals.isBarHorizontal ? (t = i + parseFloat(u * (f + 1)), s + parseFloat(d * (f + 1)) - b) : (t = i + parseFloat(u * f), s + parseFloat(d * f)),
                v = null, y = i, w = s, k = x.config.dataLabels, A = this.barCtx.barOptions.dataLabels,
                C = this.barCtx.barOptions.dataLabels.total,
                p = (void 0 !== p && this.barCtx.isRangeBar && (w = f = p), void 0 !== g && this.barCtx.isVerticalGroupedRangeBar && (y = t = g), k.offsetX),
                g = k.offsetY, S = {width: 0, height: 0},
                m = (x.config.dataLabels.enabled && (L = x.globals.series[r][o], S = m.getTextRects(x.config.dataLabels.formatter ? x.config.dataLabels.formatter(L, M(M({}, x), {}, {
                    seriesIndex: r,
                    dataPointIndex: o,
                    w: x
                })) : x.globals.yLabelFormatters[0](L), parseFloat(k.style.fontSize))), {
                    x: i,
                    y: s,
                    i: r,
                    j: o,
                    realIndex: l,
                    columnGroupIndex: c,
                    renderedPath: e,
                    bcx: t,
                    bcy: f,
                    barHeight: d,
                    barWidth: u,
                    textRects: S,
                    strokeWidth: b,
                    dataLabelsX: y,
                    dataLabelsY: w,
                    dataLabelsConfig: k,
                    barDataLabelsConfig: A,
                    barTotalDataLabelsConfig: C,
                    offX: p,
                    offY: g
                }),
                L = this.barCtx.isHorizontal ? this.calculateBarsDataLabelsPosition(m) : this.calculateColumnsDataLabelsPosition(m);
            return e.attr({
                cy: L.bcy,
                cx: L.bcx,
                j: o,
                val: x.globals.series[r][o],
                barHeight: d,
                barWidth: u
            }), {
                dataLabels: this.drawCalculatedDataLabels({
                    x: L.dataLabelsX,
                    y: L.dataLabelsY,
                    val: this.barCtx.isRangeBar ? [a, n] : ("100%" === x.config.chart.stackType ? h : x.globals.series)[l][o],
                    i: l,
                    j: o,
                    barWidth: u,
                    barHeight: d,
                    textRects: S,
                    dataLabelsConfig: k
                }),
                totalDataLabels: v = x.config.chart.stacked && C.enabled ? this.drawTotalDataLabels({
                    x: L.totalDataLabelsX,
                    y: L.totalDataLabelsY,
                    barWidth: u,
                    barHeight: d,
                    realIndex: l,
                    textAnchor: L.totalDataLabelsAnchor,
                    val: this.getStackedTotalDataLabel({realIndex: l, j: o}),
                    dataLabelsConfig: k,
                    barTotalDataLabelsConfig: C
                }) : v
            }
        }
    }, {
        key: "getStackedTotalDataLabel", value: function (e) {
            var t = e.realIndex, e = e.j, i = this.w, s = this.barCtx.stackedSeriesTotals[e];
            return s = this.totalFormatter ? this.totalFormatter(s, M(M({}, i), {}, {
                seriesIndex: t,
                dataPointIndex: e,
                w: i
            })) : s
        }
    }, {
        key: "calculateColumnsDataLabelsPosition", value: function (e) {
            var t, i, s = this.w, a = e.i, n = e.j, r = e.realIndex, o = e.y, l = e.bcx, c = e.barWidth,
                h = e.barHeight, d = e.textRects, u = e.dataLabelsX, g = e.dataLabelsY, p = e.dataLabelsConfig,
                f = e.barDataLabelsConfig, x = e.barTotalDataLabelsConfig, m = e.strokeWidth, b = e.offX, v = e.offY,
                e = l, h = Math.abs(h), y = "vertical" === s.config.plotOptions.bar.dataLabels.orientation,
                w = this.barCtx.barHelpers.getZeroValueEncounters({i: a, j: n}).zeroEncounters,
                k = (l -= m / 2, s.globals.gridWidth / s.globals.dataPoints),
                A = (this.barCtx.isVerticalGroupedRangeBar ? u += c / 2 : (u = s.globals.isXNumeric ? l - c / 2 + b : l - k + c / 2 + b, 0 < w && s.config.plotOptions.bar.hideZeroBarsWhenGrouped && (u -= c * w)), y && (u = u + d.height / 2 - m / 2 - 2), s.globals.series[a][n] < 0),
                C = o;
            switch (this.barCtx.isReversed && (C = o + (A ? h : -h)), f.position) {
                case"center":
                    g = y ? A ? C - h / 2 + v : C + h / 2 - v : A ? C - h / 2 + d.height / 2 + v : C + h / 2 + d.height / 2 - v;
                    break;
                case"bottom":
                    g = y ? A ? C - h + v : C + h - v : A ? C - h + d.height + m + v : C + h - d.height / 2 + m - v;
                    break;
                case"top":
                    g = y ? A ? C + v : C - v : A ? C - d.height / 2 - v : C + d.height + v
            }
            return this.barCtx.lastActiveBarSerieIndex === r && x.enabled && (b = new Y(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({
                realIndex: r,
                j: n
            }), p.fontSize), t = A ? C - b.height / 2 - v - x.offsetY + 18 : C + b.height + v + x.offsetY - 18, i = e + (s.globals.isXNumeric ? -c * s.globals.barGroups.length / 2 : s.globals.barGroups.length * c / 2 - (s.globals.barGroups.length - 1) * c - k) + x.offsetX), s.config.chart.stacked || (g < 0 ? g = 0 + m : g + d.height / 3 > s.globals.gridHeight && (g = s.globals.gridHeight - m)), {
                bcx: l,
                bcy: o,
                dataLabelsX: u,
                dataLabelsY: g,
                totalDataLabelsX: i,
                totalDataLabelsY: t,
                totalDataLabelsAnchor: "middle"
            }
        }
    }, {
        key: "calculateBarsDataLabelsPosition", value: function (e) {
            var t, i, s = this.w, a = e.x, n = e.i, r = e.j, o = e.realIndex, l = e.bcy, c = e.barHeight,
                h = e.barWidth, d = e.textRects, u = e.dataLabelsX, g = e.strokeWidth, p = e.dataLabelsConfig,
                f = e.barDataLabelsConfig, x = e.barTotalDataLabelsConfig, m = e.offX, e = e.offY,
                b = s.globals.gridHeight / s.globals.dataPoints, h = Math.abs(h),
                b = l - (this.barCtx.isRangeBar ? 0 : b) + c / 2 + d.height / 2 + e - 3, c = "start",
                v = s.globals.series[n][r] < 0, y = a;
            switch (this.barCtx.isReversed && (y = a + (v ? -h : h), c = v ? "start" : "end"), f.position) {
                case"center":
                    u = v ? y + h / 2 - m : Math.max(d.width / 2, y - h / 2) + m;
                    break;
                case"bottom":
                    u = v ? y + h - g - m : y - h + g + m;
                    break;
                case"top":
                    u = v ? y - g - m : y - g + m
            }
            return this.barCtx.lastActiveBarSerieIndex === o && x.enabled && (e = new Y(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({
                realIndex: o,
                j: r
            }), p.fontSize), v ? (t = y - g - m - x.offsetX, c = "end") : t = y + m + x.offsetX + (this.barCtx.isReversed ? -(h + g) : g), i = b - d.height / 2 + e.height / 2 + x.offsetY + g), s.config.chart.stacked || ("start" === p.textAnchor ? u - d.width < 0 ? u = v ? d.width + g : g : u + d.width > s.globals.gridWidth && (u = v ? s.globals.gridWidth - g : s.globals.gridWidth - d.width - g) : "middle" === p.textAnchor ? u - d.width / 2 < 0 ? u = d.width / 2 + g : u + d.width / 2 > s.globals.gridWidth && (u = s.globals.gridWidth - d.width / 2 - g) : "end" === p.textAnchor && (u < 1 ? u = d.width + g : u + 1 > s.globals.gridWidth && (u = s.globals.gridWidth - d.width - g))), {
                bcx: a,
                bcy: l,
                dataLabelsX: u,
                dataLabelsY: b,
                totalDataLabelsX: t,
                totalDataLabelsY: i,
                totalDataLabelsAnchor: c
            }
        }
    }, {
        key: "drawCalculatedDataLabels", value: function (e) {
            var t = e.x, i = e.y, s = e.val, a = e.i, n = e.j, r = e.textRects, o = e.barHeight, l = e.barWidth,
                e = e.dataLabelsConfig, c = this.w, h = "rotate(0)",
                d = ("vertical" === c.config.plotOptions.bar.dataLabels.orientation && (h = "rotate(-90, ".concat(t, ", ").concat(i, ")")), new L(this.barCtx.ctx)),
                u = new Y(this.barCtx.ctx), g = e.formatter, p = null,
                f = -1 < c.globals.collapsedSeriesIndices.indexOf(a);
            return e.enabled && !f && (p = u.group({
                class: "apexcharts-data-labels",
                transform: h
            }), f = "", void 0 !== s && (f = g(s, M(M({}, c), {}, {
                seriesIndex: a,
                dataPointIndex: n,
                w: c
            }))), !s && c.config.plotOptions.bar.hideZeroBarsWhenGrouped && (f = ""), h = c.globals.series[a][n] < 0, g = c.config.plotOptions.bar.dataLabels.position, "vertical" === c.config.plotOptions.bar.dataLabels.orientation && ("top" === g && (e.textAnchor = h ? "end" : "start"), "center" === g && (e.textAnchor = "middle"), "bottom" === g) && (e.textAnchor = h ? "end" : "start"), this.barCtx.isRangeBar && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && l < u.getTextRects(f, parseFloat(e.style.fontSize)).width && (f = ""), c.config.chart.stacked && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && (this.barCtx.isHorizontal ? r.width / 1.6 > Math.abs(l) && (f = "") : r.height / 1.6 > Math.abs(o) && (f = "")), g = M({}, e), this.barCtx.isHorizontal && s < 0 && ("start" === e.textAnchor ? g.textAnchor = "end" : "end" === e.textAnchor && (g.textAnchor = "start")), d.plotDataLabelsText({
                x: t,
                y: i,
                text: f,
                i: a,
                j: n,
                parent: p,
                dataLabelsConfig: g,
                alwaysDrawDataLabel: !0,
                offsetCorrection: !0
            })), p
        }
    }, {
        key: "drawTotalDataLabels", value: function (e) {
            var t = e.x, i = e.y, s = e.val, a = e.realIndex, n = e.textAnchor, e = e.barTotalDataLabelsConfig;
            this.w;
            var r, o = new Y(this.barCtx.ctx);
            return r = e.enabled && void 0 !== t && void 0 !== i && this.barCtx.lastActiveBarSerieIndex === a ? o.drawText({
                x: t,
                y: i,
                foreColor: e.style.color,
                text: s,
                textAnchor: n,
                fontFamily: e.style.fontFamily,
                fontSize: e.style.fontSize,
                fontWeight: e.style.fontWeight
            }) : r
        }
    }]), pt), Ze = (e(gt, [{
        key: "initVariables", value: function (e) {
            var t = this.w;
            this.barCtx.series = e, this.barCtx.totalItems = 0, this.barCtx.seriesLen = 0, this.barCtx.visibleI = -1, this.barCtx.visibleItems = 1;
            for (var i = 0; i < e.length; i++) if (0 < e[i].length && (this.barCtx.seriesLen = this.barCtx.seriesLen + 1, this.barCtx.totalItems += e[i].length), t.globals.isXNumeric) for (var s = 0; s < e[i].length; s++) t.globals.seriesX[i][s] > t.globals.minX && t.globals.seriesX[i][s] < t.globals.maxX && this.barCtx.visibleItems++; else this.barCtx.visibleItems = t.globals.dataPoints;
            0 === this.barCtx.seriesLen && (this.barCtx.seriesLen = 1), this.barCtx.zeroSerieses = [], t.globals.comboCharts || this.checkZeroSeries({series: e})
        }
    }, {
        key: "initialPositions", value: function () {
            var e, t, i, s, a, n, r, o, l = this.w, c = l.globals.dataPoints,
                h = (this.barCtx.isRangeBar && (c = l.globals.labels.length), this.barCtx.seriesLen);
            return l.config.plotOptions.bar.rangeBarGroupRows && (h = 1), this.barCtx.isHorizontal ? (s = (i = l.globals.gridHeight / c) / h, s = (s = l.globals.isXNumeric ? (i = l.globals.gridHeight / this.barCtx.totalItems) / this.barCtx.seriesLen : s) * parseInt(this.barCtx.barOptions.barHeight, 10) / 100, -1 === String(this.barCtx.barOptions.barHeight).indexOf("%") && (s = parseInt(this.barCtx.barOptions.barHeight, 10)), n = this.barCtx.baseLineInvertedY + l.globals.padHorizontal + (this.barCtx.isReversed ? l.globals.gridWidth : 0) - (this.barCtx.isReversed ? 2 * this.barCtx.baseLineInvertedY : 0), this.barCtx.isFunnel && (n = l.globals.gridWidth / 2), t = (i - s * this.barCtx.seriesLen) / 2) : (r = l.globals.gridWidth / this.barCtx.visibleItems, o = (r = l.config.xaxis.convertedCatToNumeric ? l.globals.gridWidth / l.globals.dataPoints : r) / h * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100, l.globals.isXNumeric && (c = this.barCtx.xRatio, (o = (r = l.globals.minXDiff && .5 !== l.globals.minXDiff && 0 < l.globals.minXDiff / c ? l.globals.minXDiff / c : r) / h * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100) < 1) && (o = 1), -1 === String(this.barCtx.barOptions.columnWidth).indexOf("%") && (o = parseInt(this.barCtx.barOptions.columnWidth, 10)), a = l.globals.gridHeight - this.barCtx.baseLineY[this.barCtx.translationsIndex] - (this.barCtx.isReversed ? l.globals.gridHeight : 0) + (this.barCtx.isReversed ? 2 * this.barCtx.baseLineY[this.barCtx.translationsIndex] : 0), e = l.globals.padHorizontal + (r - o * this.barCtx.seriesLen) / 2), {
                x: e,
                y: t,
                yDivision: i,
                xDivision: r,
                barHeight: l.globals.barHeight = s,
                barWidth: l.globals.barWidth = o,
                zeroH: a,
                zeroW: n
            }
        }
    }, {
        key: "initializeStackedPrevVars", value: function (t) {
            t.w.globals.seriesGroups.forEach(function (e) {
                t[e] || (t[e] = {}), t[e].prevY = [], t[e].prevX = [], t[e].prevYF = [], t[e].prevXF = [], t[e].prevYVal = [], t[e].prevXVal = []
            })
        }
    }, {
        key: "initializeStackedXYVars", value: function (t) {
            t.w.globals.seriesGroups.forEach(function (e) {
                t[e] || (t[e] = {}), t[e].xArrj = [], t[e].xArrjF = [], t[e].xArrjVal = [], t[e].yArrj = [], t[e].yArrjF = [], t[e].yArrjVal = []
            })
        }
    }, {
        key: "getPathFillColor", value: function (t, i, s, e) {
            var a, n = this.w, r = this.barCtx.ctx.fill, o = null, l = this.barCtx.barOptions.distributed ? s : i;
            return 0 < this.barCtx.barOptions.colors.ranges.length && this.barCtx.barOptions.colors.ranges.map(function (e) {
                t[i][s] >= e.from && t[i][s] <= e.to && (o = e.color)
            }), null != (a = n.config.series[i].data[s]) && a.fillColor && (o = n.config.series[i].data[s].fillColor), r.fillPath({
                seriesNumber: this.barCtx.barOptions.distributed ? l : e,
                dataPointIndex: s,
                color: o,
                value: t[i][s],
                fillConfig: null == (a = n.config.series[i].data[s]) ? void 0 : a.fill,
                fillType: null != (r = n.config.series[i].data[s]) && null != (l = r.fill) && l.type ? null == (a = n.config.series[i].data[s]) ? void 0 : a.fill.type : Array.isArray(n.config.fill.type) ? n.config.fill.type[e] : n.config.fill.type
            })
        }
    }, {
        key: "getStrokeWidth", value: function (e, t, i) {
            var s = 0, a = this.w;
            return null == this.barCtx.series[e][t] ? this.barCtx.isNullValue = !0 : this.barCtx.isNullValue = !1, s = !a.config.stroke.show || this.barCtx.isNullValue ? s : Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[i] : this.barCtx.strokeWidth
        }
    }, {
        key: "shouldApplyRadius", value: function (e) {
            var t = this.w, i = !1;
            return i = 0 < t.config.plotOptions.bar.borderRadius && (!t.config.chart.stacked || "last" !== t.config.plotOptions.bar.borderRadiusWhenStacked || this.barCtx.lastActiveBarSerieIndex === e) ? !0 : i
        }
    }, {
        key: "barBackground", value: function (e) {
            var t = e.j, i = e.i, s = e.x1, a = e.x2, n = e.y1, r = e.y2, e = e.elSeries, o = this.w,
                l = new Y(this.barCtx.ctx), c = new T(this.barCtx.ctx).getActiveConfigSeriesIndex();
            0 < this.barCtx.barOptions.colors.backgroundBarColors.length && c === i && (t >= this.barCtx.barOptions.colors.backgroundBarColors.length && (t %= this.barCtx.barOptions.colors.backgroundBarColors.length), c = this.barCtx.barOptions.colors.backgroundBarColors[t], i = l.drawRect(void 0 !== s ? s : 0, void 0 !== n ? n : 0, void 0 !== a ? a : o.globals.gridWidth, void 0 !== r ? r : o.globals.gridHeight, this.barCtx.barOptions.colors.backgroundBarRadius, c, this.barCtx.barOptions.colors.backgroundBarOpacity), e.add(i), i.node.classList.add("apexcharts-backgroundBar"))
        }
    }, {
        key: "getColumnPaths", value: function (e) {
            var t = e.barWidth, i = e.barXPosition, s = e.y1, a = e.y2, n = e.strokeWidth, r = e.seriesGroup,
                o = e.realIndex, l = e.i, c = e.j, e = e.w, h = new Y(this.barCtx.ctx),
                n = (n = Array.isArray(n) ? n[o] : n) || 0, d = t, u = i,
                g = (null != (g = e.config.series[o].data[c]) && g.columnWidthOffset && (u = i - e.config.series[o].data[c].columnWidthOffset / 2, d = t + e.config.series[o].data[c].columnWidthOffset), n / 2),
                i = u + g, t = u + d - g, u = (a += .001 + g, h.move(i, s += .001 - g)), d = h.move(i, s),
                p = h.line(t, s);
            return 0 < e.globals.previousPaths.length && (d = this.barCtx.getPreviousPath(o, c, !1)), u = u + h.line(i, a) + h.line(t, a) + h.line(t, s) + ("around" === e.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z"), d = d + h.line(i, s) + p + p + p + p + p + h.line(i, s) + ("around" === e.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z"), this.shouldApplyRadius(o) && (u = h.roundPathCorners(u, e.config.plotOptions.bar.borderRadius)), e.config.chart.stacked && (t = this.barCtx, (t = this.barCtx[r]).yArrj.push(a - g), t.yArrjF.push(Math.abs(s - a + n)), t.yArrjVal.push(this.barCtx.series[l][c])), {
                pathTo: u,
                pathFrom: d
            }
        }
    }, {
        key: "getBarpaths", value: function (e) {
            var t = e.barYPosition, i = e.barHeight, s = e.x1, a = e.x2, n = e.strokeWidth, r = e.seriesGroup,
                o = e.realIndex, l = e.i, c = e.j, e = e.w, h = new Y(this.barCtx.ctx),
                n = (n = Array.isArray(n) ? n[o] : n) || 0, d = t, u = i,
                g = (null != (g = e.config.series[o].data[c]) && g.barHeightOffset && (d = t - e.config.series[o].data[c].barHeightOffset / 2, u = i + e.config.series[o].data[c].barHeightOffset), n / 2),
                t = d + g, i = d + u - g, n = (a += .001 + g, h.move(s += .001 - g, t)), d = h.move(s, t),
                u = (0 < e.globals.previousPaths.length && (d = this.barCtx.getPreviousPath(o, c, !1)), h.line(s, i)),
                n = n + h.line(a, t) + h.line(a, i) + u + ("around" === e.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z"),
                d = d + h.line(s, t) + u + u + u + u + u + h.line(s, t) + ("around" === e.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z");
            return this.shouldApplyRadius(o) && (n = h.roundPathCorners(n, e.config.plotOptions.bar.borderRadius)), e.config.chart.stacked && (i = this.barCtx, (i = this.barCtx[r]).xArrj.push(a + g), i.xArrjF.push(Math.abs(s - a)), i.xArrjVal.push(this.barCtx.series[l][c])), {
                pathTo: n,
                pathFrom: d
            }
        }
    }, {
        key: "checkZeroSeries", value: function (e) {
            for (var t = e.series, i = this.w, s = 0; s < t.length; s++) {
                for (var a = 0, n = 0; n < t[i.globals.maxValsInArrayIndex].length; n++) a += t[s][n];
                0 === a && this.barCtx.zeroSerieses.push(s)
            }
        }
    }, {
        key: "getXForValue", value: function (e, t) {
            var i = 2 < arguments.length && void 0 !== arguments[2] && !arguments[2] ? null : t;
            return i = null != e ? t + e / this.barCtx.invertedYRatio - 2 * (this.barCtx.isReversed ? e / this.barCtx.invertedYRatio : 0) : i
        }
    }, {
        key: "getYForValue", value: function (e, t, i) {
            var s = 3 < arguments.length && void 0 !== arguments[3] && !arguments[3] ? null : t;
            return s = null != e ? t - e / this.barCtx.yRatio[i] + 2 * (this.barCtx.isReversed ? e / this.barCtx.yRatio[i] : 0) : s
        }
    }, {
        key: "getGoalValues", value: function (s, a, n, e, t, r) {
            function i(e, t) {
                var i;
                d.push((u(i = {}, s, "x" === s ? c.getXForValue(e, a, !1) : c.getYForValue(e, n, r, !1)), u(i, "attrs", t), i))
            }

            var o, l, c = this, h = this.w, d = [];
            return h.globals.seriesGoals[e] && h.globals.seriesGoals[e][t] && Array.isArray(h.globals.seriesGoals[e][t]) && h.globals.seriesGoals[e][t].forEach(function (e) {
                i(e.value, e)
            }), this.barCtx.barOptions.isDumbbell && h.globals.seriesRange.length && (o = this.barCtx.barOptions.dumbbellColors || h.globals.colors, l = {
                strokeHeight: "x" === s ? 0 : h.globals.markers.size[e],
                strokeWidth: "x" === s ? h.globals.markers.size[e] : 0,
                strokeDashArray: 0,
                strokeLineCap: "round",
                strokeColor: Array.isArray(o[e]) ? o[e][0] : o[e]
            }, i(h.globals.seriesRangeStart[e][t], l), i(h.globals.seriesRangeEnd[e][t], M(M({}, l), {}, {strokeColor: Array.isArray(o[e]) ? o[e][1] : o[e]}))), d
        }
    }, {
        key: "drawGoalLine", value: function (e) {
            var s = e.barXPosition, a = e.barYPosition, t = e.goalX, i = e.goalY, n = e.barWidth, r = e.barHeight,
                o = new Y(this.barCtx.ctx), l = o.group({className: "apexcharts-bar-goals-groups"}),
                c = (l.node.classList.add("apexcharts-element-hidden"), this.barCtx.w.globals.delayedElements.push({el: l.node}), l.attr("clip-path", "url(#gridRectMarkerMask".concat(this.barCtx.w.globals.cuid, ")")), null);
            return this.barCtx.isHorizontal ? Array.isArray(t) && t.forEach(function (e) {
                var t, i;
                -1 <= e.x && e.x <= o.w.globals.gridWidth + 1 && (t = void 0 !== e.attrs.strokeHeight ? e.attrs.strokeHeight : r / 2, c = o.drawLine(e.x, (i = a + t + r / 2) - 2 * t, e.x, i, e.attrs.strokeColor || void 0, e.attrs.strokeDashArray, e.attrs.strokeWidth || 2, e.attrs.strokeLineCap), l.add(c))
            }) : Array.isArray(i) && i.forEach(function (e) {
                var t, i;
                -1 <= e.y && e.y <= o.w.globals.gridHeight + 1 && (t = void 0 !== e.attrs.strokeWidth ? e.attrs.strokeWidth : n / 2, c = o.drawLine((i = s + t + n / 2) - 2 * t, e.y, i, e.y, e.attrs.strokeColor || void 0, e.attrs.strokeDashArray, e.attrs.strokeHeight || 2, e.attrs.strokeLineCap), l.add(c))
            }), l
        }
    }, {
        key: "drawBarShadow", value: function (e) {
            var t = e.prevPaths, i = e.currPaths, e = e.color, s = this.w, a = t.x, n = t.x1, r = i.x, o = i.x1,
                l = i.barYPosition, t = t.barYPosition + i.barHeight, i = new Y(this.barCtx.ctx), c = new R,
                a = i.move(n, t) + i.line(a, t) + i.line(r, l) + i.line(o, l) + i.line(n, t) + ("around" === s.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z");
            return i.drawPath({
                d: a,
                fill: c.shadeColor(.5, R.rgb2hex(e)),
                stroke: "none",
                strokeWidth: 0,
                fillOpacity: 1,
                classes: "apexcharts-bar-shadows"
            })
        }
    }, {
        key: "getZeroValueEncounters", value: function (e) {
            var i = e.i, s = e.j, a = this.w, n = 0, r = 0;
            return (a.config.plotOptions.bar.horizontal ? a.globals.series.map(function (e, t) {
                return t
            }) : (null == (e = a.globals.columnSeries) ? void 0 : e.i.map(function (e) {
                return e
            })) || []).forEach(function (e) {
                var t = a.globals.seriesPercent[e][s];
                t && n++, e < i && 0 === t && r++
            }), {nonZeroColumns: n, zeroEncounters: r}
        }
    }, {
        key: "getGroupIndex", value: function (t) {
            var i = this.w, e = i.globals.seriesGroups.findIndex(function (e) {
                return -1 < e.indexOf(i.globals.seriesNames[t])
            }), s = this.barCtx.columnGroupIndices, a = s.indexOf(e);
            return a < 0 && (s.push(e), a = s.length - 1), {groupIndex: e, columnGroupIndex: a}
        }
    }]), gt), _ = (e(ut, [{
        key: "draw", value: function (e, t) {
            var i = this.w, s = new Y(this.ctx), a = new I(this.ctx, i),
                n = (e = a.getLogSeries(e), this.series = e, this.yRatio = a.getLogYRatios(this.yRatio), this.barHelpers.initVariables(e), s.group({class: "apexcharts-bar-series apexcharts-plot-series"}));
            i.config.dataLabels.enabled && this.totalItems > this.barOptions.dataLabels.maxItems && console.warn("WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering - ApexCharts");
            for (var r = 0, o = 0; r < e.length; r++, o++) {
                var l = void 0, c = void 0, h = [], d = [], u = i.globals.comboCharts ? t[r] : r,
                    g = this.barHelpers.getGroupIndex(u).columnGroupIndex, p = s.group({
                        class: "apexcharts-series",
                        rel: r + 1,
                        seriesName: R.escapeString(i.globals.seriesNames[u]),
                        "data:realIndex": u
                    }),
                    f = (this.ctx.series.addCollapsedClassToSeries(p, u), 0 < e[r].length && (this.visibleI = this.visibleI + 1), 0),
                    x = 0,
                    m = (1 < this.yRatio.length && (this.yaxisIndex = i.globals.seriesYAxisReverseMap[u], this.translationsIndex = u), this.translationsIndex),
                    b = (this.isReversed = i.config.yaxis[this.yaxisIndex] && i.config.yaxis[this.yaxisIndex].reversed, this.barHelpers.initialPositions()),
                    c = b.y, f = b.barHeight, v = b.yDivision, y = b.zeroW, l = b.x, x = b.barWidth, w = b.xDivision,
                    k = b.zeroH, A = (this.horizontal || d.push(l + x / 2), s.group({
                        class: "apexcharts-datalabels",
                        "data:realIndex": u
                    })),
                    C = (i.globals.delayedElements.push({el: A.node}), A.node.classList.add("apexcharts-element-hidden"), s.group({class: "apexcharts-bar-goals-markers"})),
                    S = s.group({class: "apexcharts-bar-shadows"});
                i.globals.delayedElements.push({el: S.node}), S.node.classList.add("apexcharts-element-hidden");
                for (var L = 0; L < e[r].length; L++) {
                    var T = this.barHelpers.getStrokeWidth(r, L, u), E = null, P = {
                            indexes: {i: r, j: L, realIndex: u, translationsIndex: m, bc: o},
                            x: l,
                            y: c,
                            strokeWidth: T,
                            elSeries: p
                        }, P = (this.isHorizontal ? (E = this.drawBarPaths(M(M({}, P), {}, {
                            barHeight: f,
                            zeroW: y,
                            yDivision: v
                        })), x = this.series[r][L] / this.invertedYRatio) : (E = this.drawColumnPaths(M(M({}, P), {}, {
                            xDivision: w,
                            barWidth: x,
                            zeroH: k
                        })), f = this.series[r][L] / this.yRatio[m]), this.barHelpers.getPathFillColor(e, r, L, u)),
                        _ = (this.isFunnel && this.barOptions.isFunnel3d && this.pathArr.length && 0 < L && (_ = this.barHelpers.drawBarShadow({
                            color: "string" == typeof P && -1 === (null == P ? void 0 : P.indexOf("url")) ? P : R.hexToRgba(i.globals.colors[r]),
                            prevPaths: this.pathArr[this.pathArr.length - 1],
                            currPaths: E
                        })) && S.add(_), this.pathArr.push(E), this.barHelpers.drawGoalLine({
                            barXPosition: E.barXPosition,
                            barYPosition: E.barYPosition,
                            goalX: E.goalX,
                            goalY: E.goalY,
                            barHeight: f,
                            barWidth: x
                        }));
                    _ && C.add(_), c = E.y, l = E.x, 0 < L && d.push(l + x / 2), h.push(c), this.renderSeries({
                        realIndex: u,
                        pathFill: P,
                        j: L,
                        i: r,
                        columnGroupIndex: g,
                        pathFrom: E.pathFrom,
                        pathTo: E.pathTo,
                        strokeWidth: T,
                        elSeries: p,
                        x: l,
                        y: c,
                        series: e,
                        barHeight: Math.abs(E.barHeight || f),
                        barWidth: Math.abs(E.barWidth || x),
                        elDataLabelsWrap: A,
                        elGoalsMarkers: C,
                        elBarShadows: S,
                        visibleSeries: this.visibleI,
                        type: "bar"
                    })
                }
                i.globals.seriesXvalues[u] = d, i.globals.seriesYvalues[u] = h, n.add(p)
            }
            return n
        }
    }, {
        key: "renderSeries", value: function (e) {
            var t, i = e.realIndex, s = e.pathFill, a = e.lineFill, n = e.j, r = e.i, o = e.columnGroupIndex,
                l = e.pathFrom, c = e.pathTo, h = e.strokeWidth, d = e.elSeries, u = e.x, g = e.y, p = e.y1, f = e.y2,
                x = e.series, m = e.barHeight, b = e.barWidth, v = e.barXPosition, y = e.barYPosition,
                w = e.elDataLabelsWrap, k = e.elGoalsMarkers, A = e.elBarShadows, C = e.visibleSeries, e = e.type,
                S = this.w, L = new Y(this.ctx),
                T = (a || (t = "function" == typeof S.globals.stroke.colors[i] ? (T = i, t = S.config.stroke.colors, Array.isArray(t) && 0 < t.length && "function" == typeof (E = (E = t[T]) || "") ? E({
                    value: S.globals.series[T][n],
                    dataPointIndex: n,
                    w: S
                }) : E) : S.globals.stroke.colors[i], a = this.barOptions.distributed ? S.globals.stroke.colors[n] : t), S.config.series[r].data[n] && S.config.series[r].data[n].strokeColor && (a = S.config.series[r].data[n].strokeColor), this.isNullValue && (s = "none"), n / S.config.chart.animations.animateGradually.delay * (S.config.chart.animations.speed / S.globals.dataPoints) / 2.4),
                E = L.renderPaths({
                    i: r,
                    j: n,
                    realIndex: i,
                    pathFrom: l,
                    pathTo: c,
                    stroke: a,
                    strokeWidth: h,
                    strokeLineCap: S.config.stroke.lineCap,
                    fill: s,
                    animationDelay: T,
                    initialSpeed: S.config.chart.animations.speed,
                    dataChangeSpeed: S.config.chart.animations.dynamicAnimation.speed,
                    className: "apexcharts-".concat(e, "-area")
                }),
                L = (E.attr("clip-path", "url(#gridRectMask".concat(S.globals.cuid, ")")), S.config.forecastDataPoints),
                l = (0 < L.count && n >= S.globals.dataPoints - L.count && (E.node.setAttribute("stroke-dasharray", L.dashArray), E.node.setAttribute("stroke-width", L.strokeWidth), E.node.setAttribute("fill-opacity", L.fillOpacity)), void 0 !== p && void 0 !== f && (E.attr("data-range-y1", p), E.attr("data-range-y2", f)), new P(this.ctx).setSelectionFilter(E, i, n), d.add(E), new Ue(this).handleBarDataLabels({
                    x: u,
                    y: g,
                    y1: p,
                    y2: f,
                    i: r,
                    j: n,
                    series: x,
                    realIndex: i,
                    columnGroupIndex: o,
                    barHeight: m,
                    barWidth: b,
                    barXPosition: v,
                    barYPosition: y,
                    renderedPath: E,
                    visibleSeries: C
                }));
            return null !== l.dataLabels && w.add(l.dataLabels), l.totalDataLabels && w.add(l.totalDataLabels), d.add(w), k && d.add(k), A && d.add(A), d
        }
    }, {
        key: "drawBarPaths", value: function (e) {
            var t, i, s, a, n = e.indexes, r = e.barHeight, o = e.strokeWidth, l = e.zeroW, c = e.y, h = e.yDivision,
                e = e.elSeries, d = this.w, u = n.i, g = n.j,
                o = (d.globals.isXNumeric ? t = (c = (d.globals.seriesX[u][g] - d.globals.minX) / this.invertedXRatio - r) + r * this.visibleI : d.config.plotOptions.bar.hideZeroBarsWhenGrouped ? (a = s = 0, d.globals.seriesPercent.forEach(function (e, t) {
                    e[g] && s++, t < u && 0 === e[g] && a++
                }), t = c + (r = 0 < s ? this.seriesLen * r / s : r) * this.visibleI, t -= r * a) : t = c + r * this.visibleI, this.isFunnel && (l -= (this.barHelpers.getXForValue(this.series[u][g], l) - l) / 2), i = this.barHelpers.getXForValue(this.series[u][g], l), this.barHelpers.getBarpaths({
                    barYPosition: t,
                    barHeight: r,
                    x1: l,
                    x2: i,
                    strokeWidth: o,
                    series: this.series,
                    realIndex: n.realIndex,
                    i: u,
                    j: g,
                    w: d
                }));
            return d.globals.isXNumeric || (c += h), this.barHelpers.barBackground({
                j: g,
                i: u,
                y1: t - r * this.visibleI,
                y2: r * this.seriesLen,
                elSeries: e
            }), {
                pathTo: o.pathTo,
                pathFrom: o.pathFrom,
                x1: l,
                x: i,
                y: c,
                goalX: this.barHelpers.getGoalValues("x", l, null, u, g),
                barYPosition: t,
                barHeight: r
            }
        }
    }, {
        key: "drawColumnPaths", value: function (e) {
            var t, i, s = e.indexes, a = e.x, n = e.xDivision, r = e.barWidth, o = e.zeroH, l = e.strokeWidth,
                e = e.elSeries, c = this.w, h = s.realIndex, d = s.translationsIndex, u = s.i, g = s.j, s = s.bc,
                p = (c.globals.isXNumeric ? (a = (t = this.getBarXForNumericXAxis({
                    x: a,
                    j: g,
                    realIndex: h,
                    barWidth: r
                })).x, t = t.barXPosition) : c.config.plotOptions.bar.hideZeroBarsWhenGrouped ? (t = a + (r = 0 < (i = (p = this.barHelpers.getZeroValueEncounters({
                    i: u,
                    j: g
                })).nonZeroColumns) ? this.seriesLen * r / i : r) * this.visibleI, t -= r * p.zeroEncounters) : t = a + r * this.visibleI, i = this.barHelpers.getYForValue(this.series[u][g], o, d), this.barHelpers.getColumnPaths({
                    barXPosition: t,
                    barWidth: r,
                    y1: o,
                    y2: i,
                    strokeWidth: l,
                    series: this.series,
                    realIndex: h,
                    i: u,
                    j: g,
                    w: c
                }));
            return c.globals.isXNumeric || (a += n), this.barHelpers.barBackground({
                bc: s,
                j: g,
                i: u,
                x1: t - l / 2 - r * this.visibleI,
                x2: r * this.seriesLen + l / 2,
                elSeries: e
            }), {
                pathTo: p.pathTo,
                pathFrom: p.pathFrom,
                x: a,
                y: i,
                goalY: this.barHelpers.getGoalValues("y", null, o, u, g, d),
                barXPosition: t,
                barWidth: r
            }
        }
    }, {
        key: "getBarXForNumericXAxis", value: function (e) {
            var t = e.x, i = e.barWidth, s = e.realIndex, e = e.j, a = this.w, n = s;
            return a.globals.seriesX[s].length || (n = a.globals.maxValsInArrayIndex), {
                barXPosition: (t = a.globals.seriesX[n][e] ? (a.globals.seriesX[n][e] - a.globals.minX) / this.xRatio - i * this.seriesLen / 2 : t) + i * this.visibleI,
                x: t
            }
        }
    }, {
        key: "getPreviousPath", value: function (e, t) {
            for (var i, s = this.w, a = 0; a < s.globals.previousPaths.length; a++) {
                var n = s.globals.previousPaths[a];
                n.paths && 0 < n.paths.length && parseInt(n.realIndex, 10) === parseInt(e, 10) && void 0 !== s.globals.previousPaths[a].paths[t] && (i = s.globals.previousPaths[a].paths[t].d)
            }
            return i
        }
    }]), ut), $e = (i(h, _), ue = t(h), e(h, [{
        key: "draw", value: function (k, A) {
            var C = this, S = this.w,
                e = (this.graphics = new Y(this.ctx), this.bar = new _(this.ctx, this.xyRatios), new I(this.ctx, S));
            k = e.getLogSeries(k), this.yRatio = e.getLogYRatios(this.yRatio), this.barHelpers.initVariables(k), "100%" === S.config.chart.stackType && (k = S.globals.comboCharts ? A.map(function (e) {
                return S.globals.seriesPercent[e]
            }) : S.globals.seriesPercent.slice()), this.series = k, this.barHelpers.initializeStackedPrevVars(this);
            for (var L = this.graphics.group({class: "apexcharts-bar-series apexcharts-plot-series"}), T = 0, E = 0, t = 0, i = 0; t < k.length; t++, i++) ((e, t) => {
                var i, s, a, n, r = S.globals.comboCharts ? A[e] : e,
                    o = (m = C.barHelpers.getGroupIndex(r)).groupIndex, l = m.columnGroupIndex,
                    c = (C.groupCtx = C[S.globals.seriesGroups[o]], []), h = [], d = 0,
                    u = (1 < C.yRatio.length && (C.yaxisIndex = S.globals.seriesYAxisReverseMap[r][0], d = r), C.isReversed = S.config.yaxis[C.yaxisIndex] && S.config.yaxis[C.yaxisIndex].reversed, C.graphics.group({
                        class: "apexcharts-series",
                        seriesName: R.escapeString(S.globals.seriesNames[r]),
                        rel: e + 1,
                        "data:realIndex": r
                    })), g = (C.ctx.series.addCollapsedClassToSeries(u, r), C.graphics.group({
                        class: "apexcharts-datalabels",
                        "data:realIndex": r
                    })), p = C.graphics.group({class: "apexcharts-bar-goals-markers"}), f = 0, x = 0,
                    m = C.initialPositions(T, E, void 0, void 0, void 0, void 0, d);
                E = m.y, s = m.yDivision, n = m.zeroW, T = m.x, x = m.barWidth, i = m.xDivision, a = m.zeroH, S.globals.barHeight = f = m.barHeight, S.globals.barWidth = x, C.barHelpers.initializeStackedXYVars(C), 1 === C.groupCtx.prevY.length && C.groupCtx.prevY[0].every(function (e) {
                    return isNaN(e)
                }) && (C.groupCtx.prevY[0] = C.groupCtx.prevY[0].map(function () {
                    return a
                }), C.groupCtx.prevYF[0] = C.groupCtx.prevYF[0].map(function () {
                    return 0
                }));
                for (var b = 0; b < S.globals.dataPoints; b++) {
                    var v = C.barHelpers.getStrokeWidth(e, b, r), y = {
                        indexes: {i: e, j: b, realIndex: r, translationsIndex: d, bc: t},
                        strokeWidth: v,
                        x: T,
                        y: E,
                        elSeries: u,
                        columnGroupIndex: l,
                        seriesGroup: S.globals.seriesGroups[o]
                    }, w = null;
                    C.isHorizontal ? (w = C.drawStackedBarPaths(M(M({}, y), {}, {
                        zeroW: n,
                        barHeight: f,
                        yDivision: s
                    })), x = C.series[e][b] / C.invertedYRatio) : (w = C.drawStackedColumnPaths(M(M({}, y), {}, {
                        xDivision: i,
                        barWidth: x,
                        zeroH: a
                    })), f = C.series[e][b] / C.yRatio[d]);
                    y = ((y = C.barHelpers.drawGoalLine({
                        barXPosition: w.barXPosition,
                        barYPosition: w.barYPosition,
                        goalX: w.goalX,
                        goalY: w.goalY,
                        barHeight: f,
                        barWidth: x
                    })) && p.add(y), E = w.y, T = w.x, c.push(T), h.push(E), C.barHelpers.getPathFillColor(k, e, b, r)), u = C.renderSeries({
                        realIndex: r,
                        pathFill: y,
                        j: b,
                        i: e,
                        columnGroupIndex: l,
                        pathFrom: w.pathFrom,
                        pathTo: w.pathTo,
                        strokeWidth: v,
                        elSeries: u,
                        x: T,
                        y: E,
                        series: k,
                        barHeight: f,
                        barWidth: x,
                        elDataLabelsWrap: g,
                        elGoalsMarkers: p,
                        type: "bar",
                        visibleSeries: l
                    })
                }
                S.globals.seriesXvalues[r] = c, S.globals.seriesYvalues[r] = h, C.groupCtx.prevY.push(C.groupCtx.yArrj), C.groupCtx.prevYF.push(C.groupCtx.yArrjF), C.groupCtx.prevYVal.push(C.groupCtx.yArrjVal), C.groupCtx.prevX.push(C.groupCtx.xArrj), C.groupCtx.prevXF.push(C.groupCtx.xArrjF), C.groupCtx.prevXVal.push(C.groupCtx.xArrjVal), L.add(u)
            })(t, i);
            return L
        }
    }, {
        key: "initialPositions", value: function (e, t, i, s, a, n, r) {
            var o, l, c = this.w,
                h = (this.isHorizontal ? (s = c.globals.gridHeight / c.globals.dataPoints, o = c.config.plotOptions.bar.barHeight, o = -1 === String(o).indexOf("%") ? parseInt(o, 10) : s * parseInt(o, 10) / 100, n = c.globals.padHorizontal + (this.isReversed ? c.globals.gridWidth - this.baseLineInvertedY : this.baseLineInvertedY), t = (s - o) / 2) : (l = i = c.globals.gridWidth / c.globals.dataPoints, h = c.config.plotOptions.bar.columnWidth, c.globals.isXNumeric && 1 < c.globals.dataPoints ? l = (i = c.globals.minXDiff / this.xRatio) * parseInt(this.barOptions.columnWidth, 10) / 100 : -1 === String(h).indexOf("%") ? l = parseInt(h, 10) : l *= parseInt(h, 10) / 100, a = this.isReversed ? this.baseLineY[r] : c.globals.gridHeight - this.baseLineY[r], e = c.globals.padHorizontal + (i - l) / 2), c.globals.barGroups.length || 1);
            return {x: e, y: t, yDivision: s, xDivision: i, barHeight: o / h, barWidth: l / h, zeroH: a, zeroW: n}
        }
    }, {
        key: "drawStackedBarPaths", value: function (e) {
            for (var t = e.indexes, i = e.barHeight, s = e.strokeWidth, a = e.zeroW, n = e.y, r = e.seriesGroup, o = e.yDivision, l = e.elSeries, c = this.w, e = n + e.columnGroupIndex * i, h = t.i, d = t.j, u = t.realIndex, g = t.translationsIndex, p = 0, f = 0; f < this.groupCtx.prevXF.length; f++) p += this.groupCtx.prevXF[f][d];
            var u = 0 < (u = r.indexOf(c.config.series[u].name)) ? (x = a, this.groupCtx.prevXVal[u - 1][d] < 0 ? x = 0 <= this.series[h][d] ? this.groupCtx.prevX[u - 1][d] + p - 2 * (this.isReversed ? p : 0) : this.groupCtx.prevX[u - 1][d] : 0 <= this.groupCtx.prevXVal[u - 1][d] && (x = 0 <= this.series[h][d] ? this.groupCtx.prevX[u - 1][d] : this.groupCtx.prevX[u - 1][d] - p + 2 * (this.isReversed ? p : 0)), x) : a,
                x = null === this.series[h][d] ? u : u + this.series[h][d] / this.invertedYRatio - 2 * (this.isReversed ? this.series[h][d] / this.invertedYRatio : 0),
                s = this.barHelpers.getBarpaths({
                    barYPosition: e,
                    barHeight: i,
                    x1: u,
                    x2: x,
                    strokeWidth: s,
                    series: this.series,
                    realIndex: t.realIndex,
                    seriesGroup: r,
                    i: h,
                    j: d,
                    w: c
                });
            return this.barHelpers.barBackground({j: d, i: h, y1: e, y2: i, elSeries: l}), n += o, {
                pathTo: s.pathTo,
                pathFrom: s.pathFrom,
                goalX: this.barHelpers.getGoalValues("x", a, null, h, d, g),
                barXPosition: u,
                barYPosition: e,
                x: x,
                y: n
            }
        }
    }, {
        key: "drawStackedColumnPaths", value: function (e) {
            for (var t = e.indexes, i = e.x, s = e.xDivision, a = e.barWidth, n = e.zeroH, r = e.seriesGroup, o = e.elSeries, l = this.w, c = t.i, h = t.j, d = t.bc, u = t.realIndex, g = t.translationsIndex, e = (i = l.globals.isXNumeric ? ((l.globals.seriesX[u][h] || 0) - l.globals.minX) / this.xRatio - a / 2 * l.globals.barGroups.length : i) + e.columnGroupIndex * a, p = 0, f = 0; f < this.groupCtx.prevYF.length; f++) p += isNaN(this.groupCtx.prevYF[f][h]) ? 0 : this.groupCtx.prevYF[f][h];
            var x = c;
            if (0 < (x = r ? r.indexOf(l.globals.seriesNames[u]) : x) && !l.globals.isXNumeric || 0 < x && l.globals.isXNumeric && l.globals.seriesX[u - 1][h] === l.globals.seriesX[u][h]) {
                var m, b, v, y = Math.min(this.yRatio.length + 1, u + 1);
                if (void 0 !== this.groupCtx.prevY[x - 1] && this.groupCtx.prevY[x - 1].length) for (var w = 1; w < y; w++) if (!isNaN(null == (v = this.groupCtx.prevY[x - w]) ? void 0 : v[h])) {
                    b = this.groupCtx.prevY[x - w][h];
                    break
                }
                for (var k, A = 1; A < y; A++) {
                    if ((null == (k = this.groupCtx.prevYVal[x - A]) ? void 0 : k[h]) < 0) {
                        m = 0 <= this.series[c][h] ? b - p + 2 * (this.isReversed ? p : 0) : b;
                        break
                    }
                    if (0 <= (null == (k = this.groupCtx.prevYVal[x - A]) ? void 0 : k[h])) {
                        m = 0 <= this.series[c][h] ? b : b + p - 2 * (this.isReversed ? p : 0);
                        break
                    }
                }
                void 0 === m && (m = l.globals.gridHeight), C = null != (u = this.groupCtx.prevYF[0]) && u.every(function (e) {
                    return 0 === e
                }) && this.groupCtx.prevYF.slice(1, x).every(function (e) {
                    return e.every(function (e) {
                        return isNaN(e)
                    })
                }) ? n : m
            } else C = n;
            var u = this.series[c][h] ? C - this.series[c][h] / this.yRatio[g] + 2 * (this.isReversed ? this.series[c][h] / this.yRatio[g] : 0) : C,
                C = this.barHelpers.getColumnPaths({
                    barXPosition: e,
                    barWidth: a,
                    y1: C,
                    y2: u,
                    yRatio: this.yRatio[g],
                    strokeWidth: this.strokeWidth,
                    series: this.series,
                    seriesGroup: r,
                    realIndex: t.realIndex,
                    i: c,
                    j: h,
                    w: l
                });
            return this.barHelpers.barBackground({bc: d, j: h, i: c, x1: e, x2: a, elSeries: o}), {
                pathTo: C.pathTo,
                pathFrom: C.pathFrom,
                goalY: this.barHelpers.getGoalValues("y", null, n, c, h),
                barXPosition: e,
                x: l.globals.isXNumeric ? i : i + s,
                y: u
            }
        }
    }]), h), Qe = (i(c, _), de = t(c), e(c, [{
        key: "draw", value: function (y, e, a) {
            var w = this, k = this.w, n = new Y(this.ctx), e = k.globals.comboCharts ? e : k.config.chart.type,
                A = new S(this.ctx),
                t = (this.candlestickOptions = this.w.config.plotOptions.candlestick, this.boxOptions = this.w.config.plotOptions.boxPlot, this.isHorizontal = k.config.plotOptions.bar.horizontal, new I(this.ctx, k));
            y = t.getLogSeries(y), this.series = y, this.yRatio = t.getLogYRatios(this.yRatio), this.barHelpers.initVariables(y);
            for (var C = n.group({class: "apexcharts-".concat(e, "-series apexcharts-plot-series")}), i = 0; i < y.length; i++) (r => {
                w.isBoxPlot = "boxPlot" === k.config.chart.type || "boxPlot" === k.config.series[r].type;
                var o = void 0, l = void 0, t = [], i = [], c = k.globals.comboCharts ? a[r] : r,
                    h = w.barHelpers.getGroupIndex(c).columnGroupIndex, d = n.group({
                        class: "apexcharts-series",
                        seriesName: R.escapeString(k.globals.seriesNames[c]),
                        rel: r + 1,
                        "data:realIndex": c
                    }),
                    u = (w.ctx.series.addCollapsedClassToSeries(d, c), 0 < y[r].length && (w.visibleI = w.visibleI + 1), 0),
                    e = (1 < w.yRatio.length && (w.yaxisIndex = k.globals.seriesYAxisReverseMap[c][0], u = c), w.barHelpers.initialPositions()),
                    l = e.y, g = e.barHeight, p = e.yDivision, f = e.zeroW, o = e.x, x = e.barWidth, m = e.xDivision,
                    b = e.zeroH;
                i.push(o + x / 2);
                for (var v = n.group({
                    class: "apexcharts-datalabels",
                    "data:realIndex": c
                }), s = 0; s < k.globals.dataPoints; s++) (s => {
                    var a = w.barHelpers.getStrokeWidth(r, s, c), n = null, e = {
                        indexes: {i: r, j: s, realIndex: c, translationsIndex: u},
                        x: o,
                        y: l,
                        strokeWidth: a,
                        elSeries: d
                    }, n = w.isHorizontal ? w.drawHorizontalBoxPaths(M(M({}, e), {}, {
                        yDivision: p,
                        barHeight: g,
                        zeroW: f
                    })) : w.drawVerticalBoxPaths(M(M({}, e), {}, {xDivision: m, barWidth: x, zeroH: b}));
                    l = n.y, o = n.x, 0 < s && i.push(o + x / 2), t.push(l), n.pathTo.forEach(function (e, t) {
                        var i = !w.isBoxPlot && w.candlestickOptions.wick.useFillColor ? n.color[t] : k.globals.stroke.colors[r],
                            t = A.fillPath({seriesNumber: c, dataPointIndex: s, color: n.color[t], value: y[r][s]});
                        w.renderSeries({
                            realIndex: c,
                            pathFill: t,
                            lineFill: i,
                            j: s,
                            i: r,
                            pathFrom: n.pathFrom,
                            pathTo: e,
                            strokeWidth: a,
                            elSeries: d,
                            x: o,
                            y: l,
                            series: y,
                            columnGroupIndex: h,
                            barHeight: g,
                            barWidth: x,
                            elDataLabelsWrap: v,
                            visibleSeries: w.visibleI,
                            type: k.config.chart.type
                        })
                    })
                })(s);
                k.globals.seriesXvalues[c] = i, k.globals.seriesYvalues[c] = t, C.add(d)
            })(i);
            return C
        }
    }, {
        key: "drawVerticalBoxPaths", value: function (e) {
            var t = e.indexes, i = e.x, s = e.xDivision, a = e.barWidth, n = e.zeroH, e = e.strokeWidth, r = this.w,
                o = new Y(this.ctx), l = t.i, c = t.j, h = !0, d = r.config.plotOptions.candlestick.colors.upward,
                u = r.config.plotOptions.candlestick.colors.downward, g = "",
                p = (this.isBoxPlot && (g = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]), this.yRatio[t.translationsIndex]),
                t = t.realIndex, f = this.getOHLCValue(t, c), x = n, m = n,
                b = (f.o > f.c && (h = !1), Math.min(f.o, f.c)), v = Math.max(f.o, f.c), y = f.m,
                w = (i = r.globals.isXNumeric ? (r.globals.seriesX[t][c] - r.globals.minX) / this.xRatio - a / 2 : i) + a * this.visibleI,
                l = (null == this.series[l][c] ? v = b = n : (b = n - b / p, v = n - v / p, x = n - f.h / p, m = n - f.l / p, y = n - f.m / p), o.move(w, n), o.move(w + a / 2, b));
            return 0 < r.globals.previousPaths.length && (l = this.getPreviousPath(t, c, !0)), f = this.isBoxPlot ? [o.move(w, b) + o.line(w + a / 2, b) + o.line(w + a / 2, x) + o.line(w + a / 4, x) + o.line(w + a - a / 4, x) + o.line(w + a / 2, x) + o.line(w + a / 2, b) + o.line(w + a, b) + o.line(w + a, y) + o.line(w, y) + o.line(w, b + e / 2), o.move(w, y) + o.line(w + a, y) + o.line(w + a, v) + o.line(w + a / 2, v) + o.line(w + a / 2, m) + o.line(w + a - a / 4, m) + o.line(w + a / 4, m) + o.line(w + a / 2, m) + o.line(w + a / 2, v) + o.line(w, v) + o.line(w, y) + "z"] : [o.move(w, v) + o.line(w + a / 2, v) + o.line(w + a / 2, x) + o.line(w + a / 2, v) + o.line(w + a, v) + o.line(w + a, b) + o.line(w + a / 2, b) + o.line(w + a / 2, m) + o.line(w + a / 2, b) + o.line(w, b) + o.line(w, v - e / 2)], l += o.move(w, b), r.globals.isXNumeric || (i += s), {
                pathTo: f,
                pathFrom: l,
                x: i,
                y: v,
                barXPosition: w,
                color: this.isBoxPlot ? g : h ? [d] : [u]
            }
        }
    }, {
        key: "drawHorizontalBoxPaths", value: function (e) {
            var t = e.indexes, i = e.y, s = e.yDivision, a = e.barHeight, n = e.zeroW, e = e.strokeWidth, r = this.w,
                o = new Y(this.ctx), l = t.i, c = t.j, h = this.boxOptions.colors.lower,
                d = (this.isBoxPlot && (h = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]), this.invertedYRatio),
                t = t.realIndex, u = this.getOHLCValue(t, c), g = n, p = n, f = Math.min(u.o, u.c),
                x = Math.max(u.o, u.c), m = u.m,
                b = (i = r.globals.isXNumeric ? (r.globals.seriesX[t][c] - r.globals.minX) / this.invertedXRatio - a / 2 : i) + a * this.visibleI,
                l = (null == this.series[l][c] ? x = f = n : (f = n + f / d, x = n + x / d, g = n + u.h / d, p = n + u.l / d, m = n + u.m / d), o.move(n, b), o.move(f, b + a / 2));
            return 0 < r.globals.previousPaths.length && (l = this.getPreviousPath(t, c, !0)), u = [o.move(f, b) + o.line(f, b + a / 2) + o.line(g, b + a / 2) + o.line(g, b + a / 2 - a / 4) + o.line(g, b + a / 2 + a / 4) + o.line(g, b + a / 2) + o.line(f, b + a / 2) + o.line(f, b + a) + o.line(m, b + a) + o.line(m, b) + o.line(f + e / 2, b), o.move(m, b) + o.line(m, b + a) + o.line(x, b + a) + o.line(x, b + a / 2) + o.line(p, b + a / 2) + o.line(p, b + a - a / 4) + o.line(p, b + a / 4) + o.line(p, b + a / 2) + o.line(x, b + a / 2) + o.line(x, b) + o.line(m, b) + "z"], l += o.move(f, b), r.globals.isXNumeric || (i += s), {
                pathTo: u,
                pathFrom: l,
                x: x,
                y: i,
                barYPosition: b,
                color: h
            }
        }
    }, {
        key: "getOHLCValue", value: function (e, t) {
            var i = this.w;
            return {
                o: (this.isBoxPlot ? i.globals.seriesCandleH : i.globals.seriesCandleO)[e][t],
                h: (this.isBoxPlot ? i.globals.seriesCandleO : i.globals.seriesCandleH)[e][t],
                m: i.globals.seriesCandleM[e][t],
                l: (this.isBoxPlot ? i.globals.seriesCandleC : i.globals.seriesCandleL)[e][t],
                c: (this.isBoxPlot ? i.globals.seriesCandleL : i.globals.seriesCandleC)[e][t]
            }
        }
    }]), c), Ke = (e(dt, [{
        key: "checkColorRange", value: function () {
            var e = this.w, i = !1, e = e.config.plotOptions[e.config.chart.type];
            return 0 < e.colorScale.ranges.length && e.colorScale.ranges.map(function (e, t) {
                e.from <= 0 && (i = !0)
            }), i
        }
    }, {
        key: "getShadeColor", value: function (e, t, i, s) {
            var a = this.w, n = 1, r = a.config.plotOptions[e].shadeIntensity, t = this.determineColor(e, t, i),
                i = (a.globals.hasNegs || s ? n = a.config.plotOptions[e].reverseNegativeShade ? t.percent < 0 ? t.percent / 100 * (1.25 * r) : (1 - t.percent / 100) * (1.25 * r) : t.percent <= 0 ? 1 - (1 + t.percent / 100) * r : (1 - t.percent / 100) * r : (n = 1 - t.percent / 100, "treemap" === e && (n = (1 - t.percent / 100) * (1.25 * r))), t.color),
                s = new R;
            return {
                color: i = a.config.plotOptions[e].enableShades ? "dark" === this.w.config.theme.mode ? (r = s.shadeColor(-1 * n, t.color), R.hexToRgba(R.isColorHex(r) ? r : R.rgb2hex(r), a.config.fill.opacity)) : (e = s.shadeColor(n, t.color), R.hexToRgba(R.isColorHex(e) ? e : R.rgb2hex(e), a.config.fill.opacity)) : i,
                colorProps: t
            }
        }
    }, {
        key: "determineColor", value: function (e, t, i) {
            var s = this.w, a = s.globals.series[t][i], n = s.config.plotOptions[e], r = n.colorScale.inverse ? i : t,
                o = (n.distributed && "treemap" === s.config.chart.type && (r = i), s.globals.colors[r]), l = null,
                c = Math.min.apply(Math, C(s.globals.series[t])), h = Math.max.apply(Math, C(s.globals.series[t])),
                i = (n.distributed || "heatmap" !== e || (c = s.globals.minY, h = s.globals.maxY), void 0 !== n.colorScale.min && (c = n.colorScale.min < s.globals.minY ? n.colorScale.min : s.globals.minY, h = n.colorScale.max > s.globals.maxY ? n.colorScale.max : s.globals.maxY), Math.abs(h) + Math.abs(c)),
                d = 100 * a / (0 === i ? i - 1e-6 : i);
            return 0 < n.colorScale.ranges.length && n.colorScale.ranges.map(function (e, t) {
                a >= e.from && a <= e.to && (o = e.color, l = e.foreColor || null, c = e.from, h = e.to, e = Math.abs(h) + Math.abs(c), d = 100 * a / (0 === e ? e - 1e-6 : e))
            }), {color: o, foreColor: l, percent: d}
        }
    }, {
        key: "calculateDataLabels", value: function (e) {
            var t, i = e.text, s = e.x, a = e.y, n = e.i, r = e.j, o = e.colorProps, e = e.fontSize,
                l = this.w.config.dataLabels, c = new Y(this.ctx), h = new L(this.ctx), d = null;
            return l.enabled && (d = c.group({class: "apexcharts-data-labels"}), c = l.offsetX, t = l.offsetY, s = s + c, c = a + parseFloat(l.style.fontSize) / 3 + t, h.plotDataLabelsText({
                x: s,
                y: c,
                text: i,
                i: n,
                j: r,
                color: o.foreColor,
                parent: d,
                fontSize: e,
                dataLabelsConfig: l
            })), d
        }
    }, {
        key: "addListeners", value: function (e) {
            var t = new Y(this.ctx);
            e.node.addEventListener("mouseenter", t.pathMouseEnter.bind(this, e)), e.node.addEventListener("mouseleave", t.pathMouseLeave.bind(this, e)), e.node.addEventListener("mousedown", t.pathMouseDown.bind(this, e))
        }
    }]), dt), Je = (e(ht, [{
        key: "draw", value: function (e) {
            var t = this.w, i = new Y(this.ctx), s = i.group({class: "apexcharts-heatmap"}),
                a = (s.attr("clip-path", "url(#gridRectMask".concat(t.globals.cuid, ")")), t.globals.gridWidth / t.globals.dataPoints),
                n = t.globals.gridHeight / t.globals.series.length, r = 0, o = !1,
                l = (this.negRange = this.helpers.checkColorRange(), e.slice());
            t.config.yaxis[0].reversed && (o = !0, l.reverse());
            for (var c = o ? 0 : l.length - 1; o ? c < l.length : 0 <= c; o ? c++ : c--) {
                var h, d = i.group({
                    class: "apexcharts-series apexcharts-heatmap-series",
                    seriesName: R.escapeString(t.globals.seriesNames[c]),
                    rel: c + 1,
                    "data:realIndex": c
                });
                this.ctx.series.addCollapsedClassToSeries(d, c), t.config.chart.dropShadow.enabled && (h = t.config.chart.dropShadow, new P(this.ctx).dropShadow(d, h, c));
                for (var u = 0, g = t.config.plotOptions.heatmap.shadeIntensity, p = 0; p < l[c].length; p++) {
                    var f, x = this.helpers.getShadeColor(t.config.chart.type, c, p, this.negRange), m = x.color,
                        x = x.colorProps, b = ("image" === t.config.fill.type && (m = new S(this.ctx).fillPath({
                            seriesNumber: c,
                            dataPointIndex: p,
                            opacity: t.globals.hasNegs ? x.percent < 0 ? 1 - (1 + x.percent / 100) : g + x.percent / 100 : x.percent / 100,
                            patternID: R.randomId(),
                            width: t.config.fill.image.width || a,
                            height: t.config.fill.image.height || n
                        })), this.rectRadius), b = i.drawRect(u, r, a, n, b), b = (b.attr({
                            cx: u,
                            cy: r
                        }), b.node.classList.add("apexcharts-heatmap-rect"), d.add(b), b.attr({
                            fill: m,
                            i: c,
                            index: c,
                            j: p,
                            val: e[c][p],
                            "stroke-width": this.strokeWidth,
                            stroke: t.config.plotOptions.heatmap.useFillColorAsStroke ? m : t.globals.stroke.colors[0],
                            color: m
                        }), this.helpers.addListeners(b), t.config.chart.animations.enabled && !t.globals.dataChanged && (f = 1, t.globals.resized || (f = t.config.chart.animations.speed), this.animateHeatMap(b, u, r, a, n, f)), t.globals.dataChanged && (f = 1, this.dynamicAnim.enabled) && t.globals.shouldAnimate && (f = this.dynamicAnim.speed, v = (v = t.globals.previousPaths[c] && t.globals.previousPaths[c][p] && t.globals.previousPaths[c][p].color) || "rgba(255, 255, 255, 0)", this.animateHeatColor(b, R.isColorHex(v) ? v : R.rgb2hex(v), R.isColorHex(m) ? m : R.rgb2hex(m), f)), (0, t.config.dataLabels.formatter)(t.globals.series[c][p], {
                            value: t.globals.series[c][p],
                            seriesIndex: c,
                            dataPointIndex: p,
                            w: t
                        })), v = this.helpers.calculateDataLabels({
                            text: b,
                            x: u + a / 2,
                            y: r + n / 2,
                            i: c,
                            j: p,
                            colorProps: x,
                            series: l
                        });
                    null !== v && d.add(v), u += a
                }
                r += n, s.add(d)
            }
            var y = t.globals.yAxisScale[0].result.slice();
            return t.config.yaxis[0].reversed ? y.unshift("") : y.push(""), t.globals.yAxisScale[0].result = y, s
        }
    }, {
        key: "animateHeatMap", value: function (e, t, i, s, a, n) {
            var r = new A(this.ctx);
            r.animateRect(e, {x: t + s / 2, y: i + a / 2, width: 0, height: 0}, {
                x: t,
                y: i,
                width: s,
                height: a
            }, n, function () {
                r.animationCompleted(e)
            })
        }
    }, {
        key: "animateHeatColor", value: function (e, t, i, s) {
            e.attr({fill: t}).animate(s).attr({fill: i})
        }
    }]), ht), et = (e(ct, [{
        key: "drawYAxisTexts", value: function (e, t, i, s) {
            var a = this.w, n = a.config.yaxis[0], a = a.globals.yLabelFormatters[0];
            return new Y(this.ctx).drawText({
                x: e + n.labels.offsetX,
                y: t + n.labels.offsetY,
                text: a(s, i),
                textAnchor: "middle",
                fontSize: n.labels.style.fontSize,
                fontFamily: n.labels.style.fontFamily,
                foreColor: Array.isArray(n.labels.style.colors) ? n.labels.style.colors[i] : n.labels.style.colors
            })
        }
    }]), ct), tt = (e(lt, [{
        key: "draw", value: function (e) {
            var t = this, i = this.w, s = new Y(this.ctx), a = s.group({class: "apexcharts-pie"});
            if (!i.globals.noData) {
                for (var n = 0, r = 0; r < e.length; r++) n += R.negToZero(e[r]);
                var o = [], l = s.group();
                0 === n && (n = 1e-5), e.forEach(function (e) {
                    t.maxY = Math.max(t.maxY, e)
                }), i.config.yaxis[0].max && (this.maxY = i.config.yaxis[0].max), "back" === i.config.grid.position && "polarArea" === this.chartType && this.drawPolarElements(a);
                for (var c = 0; c < e.length; c++) {
                    var h = this.fullAngle * R.negToZero(e[c]) / n;
                    o.push(h), "polarArea" === this.chartType ? (o[c] = this.fullAngle / e.length, this.sliceSizes.push(i.globals.radialSize * e[c] / this.maxY)) : this.sliceSizes.push(i.globals.radialSize)
                }
                if (i.globals.dataChanged) {
                    for (var d, u = 0, g = 0; g < i.globals.previousPaths.length; g++) u += R.negToZero(i.globals.previousPaths[g]);
                    for (var p = 0; p < i.globals.previousPaths.length; p++) d = this.fullAngle * R.negToZero(i.globals.previousPaths[p]) / u, this.prevSectorAngleArr.push(d)
                }
                this.donutSize < 0 && (this.donutSize = 0), "donut" === this.chartType && ((s = s.drawCircle(this.donutSize)).attr({
                    cx: this.centerX,
                    cy: this.centerY,
                    fill: i.config.plotOptions.pie.donut.background || "transparent"
                }), l.add(s));
                var f = this.drawArcs(o, e);
                this.sliceLabels.forEach(function (e) {
                    f.add(e)
                }), l.attr({transform: "translate(".concat(this.translateX, ", ").concat(this.translateY, ") scale(").concat(i.config.plotOptions.pie.customScale, ")")}), l.add(f), a.add(l), this.donutDataLabels.show && (s = this.renderInnerDataLabels(this.dataLabelsGroup, this.donutDataLabels, {
                    hollowSize: this.donutSize,
                    centerX: this.centerX,
                    centerY: this.centerY,
                    opacity: this.donutDataLabels.show
                }), a.add(s)), "front" === i.config.grid.position && "polarArea" === this.chartType && this.drawPolarElements(a)
            }
            return a
        }
    }, {
        key: "drawArcs", value: function (e, t) {
            var i = this.w, s = new P(this.ctx), a = new Y(this.ctx), n = new S(this.ctx),
                r = a.group({class: "apexcharts-slices"}),
                o = (this.initialAngle, this.initialAngle, this.initialAngle), l = this.initialAngle;
            this.strokeWidth = i.config.stroke.show ? i.config.stroke.width : 0;
            for (var c = 0; c < e.length; c++) {
                var h, d, u = a.group({
                        class: "apexcharts-series apexcharts-pie-series",
                        seriesName: R.escapeString(i.globals.seriesNames[c]),
                        rel: c + 1,
                        "data:realIndex": c
                    }),
                    g = (r.add(u), d = l, o = (h = o) + e[c], l = d + this.prevSectorAngleArr[c], o < h ? this.fullAngle + o - h : o - h),
                    p = n.fillPath({seriesNumber: c, size: this.sliceSizes[c], value: t[c]}),
                    f = this.getChangedPath(d, l), f = a.drawPath({
                        d: f,
                        stroke: Array.isArray(this.lineColorArr) ? this.lineColorArr[c] : this.lineColorArr,
                        strokeWidth: 0,
                        fill: p,
                        fillOpacity: i.config.fill.opacity,
                        classes: "apexcharts-pie-area apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(c)
                    }), p = (f.attr({
                        index: 0,
                        j: c
                    }), s.setSelectionFilter(f, 0, c), i.config.chart.dropShadow.enabled && (p = i.config.chart.dropShadow, s.dropShadow(f, p, c)), this.addListeners(f, this.donutDataLabels), Y.setAttrs(f.node, {
                        "data:angle": g,
                        "data:startAngle": h,
                        "data:strokeWidth": this.strokeWidth,
                        "data:value": t[c]
                    }), {x: 0, y: 0}),
                    u = ("pie" === this.chartType || "polarArea" === this.chartType ? p = R.polarToCartesian(this.centerX, this.centerY, i.globals.radialSize / 1.25 + i.config.plotOptions.pie.dataLabels.offset, (h + g / 2) % this.fullAngle) : "donut" === this.chartType && (p = R.polarToCartesian(this.centerX, this.centerY, (i.globals.radialSize + this.donutSize) / 2 + i.config.plotOptions.pie.dataLabels.offset, (h + g / 2) % this.fullAngle)), u.add(f), 0);
                !this.initialAnim || i.globals.resized || i.globals.dataChanged ? this.animBeginArr.push(0) : (0 == (u = g / this.fullAngle * i.config.chart.animations.speed) && (u = 1), this.animDur = u + this.animDur, this.animBeginArr.push(this.animDur)), this.dynamicAnim && i.globals.dataChanged ? this.animatePaths(f, {
                    size: this.sliceSizes[c],
                    endAngle: o,
                    startAngle: h,
                    prevStartAngle: d,
                    prevEndAngle: l,
                    animateStartingPos: !0,
                    i: c,
                    animBeginArr: this.animBeginArr,
                    shouldSetPrevPaths: !0,
                    dur: i.config.chart.animations.dynamicAnimation.speed
                }) : this.animatePaths(f, {
                    size: this.sliceSizes[c],
                    endAngle: o,
                    startAngle: h,
                    i: c,
                    totalItems: e.length - 1,
                    animBeginArr: this.animBeginArr,
                    dur: u
                }), i.config.plotOptions.pie.expandOnClick && "polarArea" !== this.chartType && f.node.addEventListener("mouseup", this.pieClicked.bind(this, c)), void 0 !== i.globals.selectedDataPoints[0] && -1 < i.globals.selectedDataPoints[0].indexOf(c) && this.pieClicked(c), i.config.dataLabels.enabled && (d = p.x, h = p.y, u = 100 * g / this.fullAngle + "%", 0 != g) && i.config.plotOptions.pie.dataLabels.minAngleToShowLabel < e[c] && (void 0 !== (f = i.config.dataLabels.formatter) && (u = f(i.globals.seriesPercent[c][0], {
                    seriesIndex: c,
                    w: i
                })), p = i.globals.dataLabels.style.colors[c], g = a.group({class: "apexcharts-datalabels"}), f = a.drawText({
                    x: d,
                    y: h,
                    text: u,
                    textAnchor: "middle",
                    fontSize: i.config.dataLabels.style.fontSize,
                    fontFamily: i.config.dataLabels.style.fontFamily,
                    fontWeight: i.config.dataLabels.style.fontWeight,
                    foreColor: p
                }), g.add(f), i.config.dataLabels.dropShadow.enabled && (d = i.config.dataLabels.dropShadow, s.dropShadow(f, d)), f.node.classList.add("apexcharts-pie-label"), i.config.chart.animations.animate && !1 === i.globals.resized && (f.node.classList.add("apexcharts-pie-label-delay"), f.node.style.animationDelay = i.config.chart.animations.speed / 940 + "s"), this.sliceLabels.push(g))
            }
            return r
        }
    }, {
        key: "addListeners", value: function (e, t) {
            var i = new Y(this.ctx);
            e.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this, e)), e.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this, e)), e.node.addEventListener("mouseleave", this.revertDataLabelsInner.bind(this, e.node, t)), e.node.addEventListener("mousedown", i.pathMouseDown.bind(this, e)), this.donutDataLabels.total.showAlways || (e.node.addEventListener("mouseenter", this.printDataLabelsInner.bind(this, e.node, t)), e.node.addEventListener("mousedown", this.printDataLabelsInner.bind(this, e.node, t)))
        }
    }, {
        key: "animatePaths", value: function (e, t) {
            var i = this.w,
                s = t.endAngle < t.startAngle ? this.fullAngle + t.endAngle - t.startAngle : t.endAngle - t.startAngle,
                a = s, n = t.startAngle, r = t.startAngle;
            void 0 !== t.prevStartAngle && void 0 !== t.prevEndAngle && (n = t.prevEndAngle, a = t.prevEndAngle < t.prevStartAngle ? this.fullAngle + t.prevEndAngle - t.prevStartAngle : t.prevEndAngle - t.prevStartAngle), t.i === i.config.series.length - 1 && (s + r > this.fullAngle ? t.endAngle = t.endAngle - (s + r) : s + r < this.fullAngle && (t.endAngle = t.endAngle + (this.fullAngle - (s + r)))), s === this.fullAngle && (s = this.fullAngle - .01), this.animateArc(e, n, r, s, a, t)
        }
    }, {
        key: "animateArc", value: function (t, i, s, a, n, r) {
            var o, l = this, e = this.w, c = new A(this.ctx), h = r.size,
                d = ((isNaN(i) || isNaN(n)) && (i = s, n = a, r.dur = 0), a), u = s,
                g = i < s ? this.fullAngle + i - s : i - s;
            e.globals.dataChanged && r.shouldSetPrevPaths && r.prevEndAngle && (o = l.getPiePath({
                me: l,
                startAngle: r.prevStartAngle,
                angle: r.prevEndAngle < r.prevStartAngle ? this.fullAngle + r.prevEndAngle - r.prevStartAngle : r.prevEndAngle - r.prevStartAngle,
                size: h
            }), t.attr({d: o})), 0 !== r.dur ? t.animate(r.dur, e.globals.easing, r.animBeginArr[r.i]).afterAll(function () {
                "pie" !== l.chartType && "donut" !== l.chartType && "polarArea" !== l.chartType || this.animate(e.config.chart.animations.dynamicAnimation.speed).attr({"stroke-width": l.strokeWidth}), r.i === e.config.series.length - 1 && c.animationCompleted(t)
            }).during(function (e) {
                d = g + (a - g) * e, r.animateStartingPos && (d = n + (a - n) * e, u = i - n + (s - (i - n)) * e), o = l.getPiePath({
                    me: l,
                    startAngle: u,
                    angle: d,
                    size: h
                }), t.node.setAttribute("data:pathOrig", o), t.attr({d: o})
            }) : (o = l.getPiePath({
                me: l,
                startAngle: u,
                angle: a,
                size: h
            }), r.isTrack || (e.globals.animationEnded = !0), t.node.setAttribute("data:pathOrig", o), t.attr({
                d: o,
                "stroke-width": l.strokeWidth
            }))
        }
    }, {
        key: "pieClicked", value: function (e) {
            var t, i = this.w, s = this.sliceSizes[e] + (i.config.plotOptions.pie.expandOnClick ? 4 : 0),
                a = i.globals.dom.Paper.select(".apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(e)).members[0];
            "true" !== a.attr("data:pieClicked") ? (t = i.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area"), Array.prototype.forEach.call(t, function (e) {
                e.setAttribute("data:pieClicked", "false");
                var t = e.getAttribute("data:pathOrig");
                t && e.setAttribute("d", t)
            }), i.globals.capturedDataPointIndex = e, a.attr("data:pieClicked", "true"), t = parseInt(a.attr("data:startAngle"), 10), i = parseInt(a.attr("data:angle"), 10), e = this.getPiePath({
                me: this,
                startAngle: t,
                angle: i,
                size: s
            }), 360 !== i && a.plot(e)) : (a.attr({"data:pieClicked": "false"}), this.revertDataLabelsInner(a.node, this.donutDataLabels), t = a.attr("data:pathOrig"), a.attr({d: t}))
        }
    }, {
        key: "getChangedPath", value: function (e, t) {
            var i = "";
            return i = this.dynamicAnim && this.w.globals.dataChanged ? this.getPiePath({
                me: this,
                startAngle: e,
                angle: t - e,
                size: this.size
            }) : i
        }
    }, {
        key: "getPiePath", value: function (e) {
            var t = e.me, i = e.startAngle, s = e.angle, e = e.size, a = new Y(this.ctx), n = i,
                r = Math.PI * (n - 90) / 180, i = s + i,
                o = (Math.ceil(i) >= this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle && (i = this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle - .01), Math.ceil(i) > this.fullAngle && (i -= this.fullAngle), Math.PI * (i - 90) / 180),
                l = t.centerX + e * Math.cos(r), r = t.centerY + e * Math.sin(r), c = t.centerX + e * Math.cos(o),
                o = t.centerY + e * Math.sin(o), i = R.polarToCartesian(t.centerX, t.centerY, t.donutSize, i),
                n = R.polarToCartesian(t.centerX, t.centerY, t.donutSize, n), s = 180 < s ? 1 : 0,
                e = ["M", l, r, "A", e, e, 0, s, 1, c, o],
                c = ("donut" === t.chartType ? [].concat(e, ["L", i.x, i.y, "A", t.donutSize, t.donutSize, 0, s, 0, n.x, n.y, "L", l, r, "z"]) : "pie" === t.chartType || "polarArea" === t.chartType ? [].concat(e, ["L", t.centerX, t.centerY, "L", l, r]) : [].concat(e)).join(" ");
            return a.roundPathCorners(c, 2 * this.strokeWidth)
        }
    }, {
        key: "drawPolarElements", value: function (e) {
            var t = this.w, i = new ke(this.ctx), s = new Y(this.ctx), a = new et(this.ctx), n = s.group(),
                r = s.group(), i = i.niceScale(0, Math.ceil(this.maxY), 0), o = i.result.reverse(), l = i.result.length;
            this.maxY = i.niceMax;
            for (var c = t.globals.radialSize, h = c / (l - 1), d = 0; d < l - 1; d++) {
                var u, g = s.drawCircle(c);
                g.attr({
                    cx: this.centerX,
                    cy: this.centerY,
                    fill: "none",
                    "stroke-width": t.config.plotOptions.polarArea.rings.strokeWidth,
                    stroke: t.config.plotOptions.polarArea.rings.strokeColor
                }), t.config.yaxis[0].show && (u = a.drawYAxisTexts(this.centerX, this.centerY - c + parseInt(t.config.yaxis[0].labels.style.fontSize, 10) / 2, d, o[d]), r.add(u)), n.add(g), c -= h
            }
            this.drawSpokes(e), e.add(n), e.add(r)
        }
    }, {
        key: "renderInnerDataLabels", value: function (e, t, i) {
            var s = this.w, a = new Y(this.ctx), n = t.total.show;
            e.node.innerHTML = "", e.node.style.opacity = i.opacity;
            var r = i.centerX, i = i.centerY, o = void 0 === t.name.color ? s.globals.colors[0] : t.name.color,
                l = t.name.fontSize, c = t.name.fontFamily, h = t.name.fontWeight,
                d = void 0 === t.value.color ? s.config.chart.foreColor : t.value.color, u = t.value.formatter, g = "",
                p = "";
            return n ? (o = t.total.color, l = t.total.fontSize, c = t.total.fontFamily, h = t.total.fontWeight, p = t.total.label, g = t.total.formatter(s)) : 1 === s.globals.series.length && (g = u(s.globals.series[0], s), p = s.globals.seriesNames[0]), p = p && t.name.formatter(p, t.total.show, s), t.name.show && ((n = a.drawText({
                x: r,
                y: i + parseFloat(t.name.offsetY),
                text: p,
                textAnchor: "middle",
                foreColor: o,
                fontSize: l,
                fontWeight: h,
                fontFamily: c
            })).node.classList.add("apexcharts-datalabel-label"), e.add(n)), t.value.show && (u = t.name.show ? parseFloat(t.value.offsetY) + 16 : t.value.offsetY, (s = a.drawText({
                x: r,
                y: i + u,
                text: g,
                textAnchor: "middle",
                foreColor: d,
                fontWeight: t.value.fontWeight,
                fontSize: t.value.fontSize,
                fontFamily: t.value.fontFamily
            })).node.classList.add("apexcharts-datalabel-value"), e.add(s)), e
        }
    }, {
        key: "printInnerLabels", value: function (e, t, i, s) {
            var a, n = this.w,
                r = (s ? a = void 0 === e.name.color ? n.globals.colors[parseInt(s.parentNode.getAttribute("rel"), 10) - 1] : e.name.color : 1 < n.globals.series.length && e.total.show && (a = e.total.color), n.globals.dom.baseEl.querySelector(".apexcharts-datalabel-label")),
                o = n.globals.dom.baseEl.querySelector(".apexcharts-datalabel-value"),
                s = (i = (0, e.value.formatter)(i, n), s || "function" != typeof e.total.formatter || (i = e.total.formatter(n)), t === e.total.label);
            t = e.name.formatter(t, s, n), null !== r && (r.textContent = t), null !== o && (o.textContent = i), null !== r && (r.style.fill = a)
        }
    }, {
        key: "printDataLabelsInner", value: function (e, t) {
            var i = this.w, s = e.getAttribute("data:value"),
                a = i.globals.seriesNames[parseInt(e.parentNode.getAttribute("rel"), 10) - 1],
                t = (1 < i.globals.series.length && this.printInnerLabels(t, a, s, e), i.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group"));
            null !== t && (t.style.opacity = 1)
        }
    }, {
        key: "drawSpokes", value: function (i) {
            var s = this, e = this.w, a = new Y(this.ctx), n = e.config.plotOptions.polarArea.spokes;
            if (0 !== n.strokeWidth) {
                for (var t = [], r = 360 / e.globals.series.length, o = 0; o < e.globals.series.length; o++) t.push(R.polarToCartesian(this.centerX, this.centerY, e.globals.radialSize, e.config.plotOptions.pie.startAngle + r * o));
                t.forEach(function (e, t) {
                    e = a.drawLine(e.x, e.y, s.centerX, s.centerY, Array.isArray(n.connectorColors) ? n.connectorColors[t] : n.connectorColors);
                    i.add(e)
                })
            }
        }
    }, {
        key: "revertDataLabelsInner", value: function () {
            var e, t = this.w;
            this.donutDataLabels.show && (e = t.globals.dom.Paper.select(".apexcharts-datalabels-group").members[0], e = this.renderInnerDataLabels(e, this.donutDataLabels, {
                hollowSize: this.donutSize,
                centerX: this.centerX,
                centerY: this.centerY,
                opacity: this.donutDataLabels.show
            }), t.globals.dom.Paper.select(".apexcharts-radialbar, .apexcharts-pie").members[0].add(e))
        }
    }]), lt), it = (e(ot, [{
        key: "draw", value: function (e) {
            var d, u, g = this, p = this.w, f = new S(this.ctx), x = [], m = new L(this.ctx),
                t = (e.length && (this.dataPointsLen = e[p.globals.maxValsInArrayIndex].length), this.disAngle = 2 * Math.PI / this.dataPointsLen, p.globals.gridWidth / 2),
                i = p.globals.gridHeight / 2, t = t + p.config.plotOptions.radar.offsetX,
                i = i + p.config.plotOptions.radar.offsetY, s = this.graphics.group({
                    class: "apexcharts-radar-series apexcharts-plot-series",
                    transform: "translate(".concat(t || 0, ", ").concat(i || 0, ")")
                }), b = null;
            return this.yaxisLabels = this.graphics.group({class: "apexcharts-yaxis"}), e.forEach(function (e, a) {
                var t = e.length === p.globals.dataPoints, n = g.graphics.group().attr({
                        class: "apexcharts-series",
                        "data:longestSeries": t,
                        seriesName: R.escapeString(p.globals.seriesNames[a]),
                        rel: a + 1,
                        "data:realIndex": a
                    }),
                    i = (g.dataRadiusOfPercent[a] = [], g.dataRadius[a] = [], g.angleArr[a] = [], e.forEach(function (e, t) {
                        var i = Math.abs(g.maxValue - g.minValue);
                        e -= g.minValue, g.isLog && (e = g.coreUtils.getLogVal(g.logBase, e, 0)), g.dataRadiusOfPercent[a][t] = e / i, g.dataRadius[a][t] = g.dataRadiusOfPercent[a][t] * g.size, g.angleArr[a][t] = t * g.disAngle
                    }), d = g.getDataPointsPos(g.dataRadius[a], g.angleArr[a]), g.createPaths(d, {x: 0, y: 0})),
                    s = (b = g.graphics.group({class: "apexcharts-series-markers-wrap apexcharts-element-hidden"}), u = g.graphics.group({
                        class: "apexcharts-datalabels",
                        "data:realIndex": a
                    }), p.globals.delayedElements.push({el: b.node, index: a}), {
                        i: a,
                        realIndex: a,
                        animationDelay: a,
                        initialSpeed: p.config.chart.animations.speed,
                        dataChangeSpeed: p.config.chart.animations.dynamicAnimation.speed,
                        className: "apexcharts-radar",
                        shouldClipToGrid: !1,
                        bindEventsOnPaths: !1,
                        stroke: p.globals.stroke.colors[a],
                        strokeLineCap: p.config.stroke.lineCap
                    }), r = null;
                0 < p.globals.previousPaths.length && (r = g.getPreviousPath(a));
                for (var o = 0; o < i.linePathsTo.length; o++) {
                    var l, c, h = g.graphics.renderPaths(M(M({}, s), {}, {
                        pathFrom: null === r ? i.linePathsFrom[o] : r,
                        pathTo: i.linePathsTo[o],
                        strokeWidth: Array.isArray(g.strokeWidth) ? g.strokeWidth[a] : g.strokeWidth,
                        fill: "none",
                        drawShadow: !1
                    })), h = (n.add(h), f.fillPath({seriesNumber: a})), h = g.graphics.renderPaths(M(M({}, s), {}, {
                        pathFrom: null === r ? i.areaPathsFrom[o] : r,
                        pathTo: i.areaPathsTo[o],
                        strokeWidth: 0,
                        fill: h,
                        drawShadow: !1
                    }));
                    p.config.chart.dropShadow.enabled && (l = new P(g.ctx), c = p.config.chart.dropShadow, l.dropShadow(h, Object.assign({}, c, {noUserSpaceOnUse: !0}), a)), n.add(h)
                }
                e.forEach(function (e, t) {
                    var i = new k(g.ctx).getMarkerConfig({
                            cssClass: "apexcharts-marker",
                            seriesIndex: a,
                            dataPointIndex: t
                        }), s = g.graphics.drawMarker(d[t].x, d[t].y, i),
                        i = (s.attr("rel", t), s.attr("j", t), s.attr("index", a), s.node.setAttribute("default-marker-size", i.pSize), g.graphics.group({class: "apexcharts-series-markers"})),
                        s = (i && i.add(s), b.add(i), n.add(b), p.config.dataLabels);
                    s.enabled && (i = s.formatter(p.globals.series[a][t], {
                        seriesIndex: a,
                        dataPointIndex: t,
                        w: p
                    }), m.plotDataLabelsText({
                        x: d[t].x,
                        y: d[t].y,
                        text: i,
                        textAnchor: "middle",
                        i: a,
                        j: a,
                        parent: u,
                        offsetCorrection: !1,
                        dataLabelsConfig: M({}, s)
                    })), n.add(u)
                }), x.push(n)
            }), this.drawPolygons({parent: s}), p.config.xaxis.labels.show && (t = this.drawXAxisTexts(), s.add(t)), x.forEach(function (e) {
                s.add(e)
            }), s.add(this.yaxisLabels), s
        }
    }, {
        key: "drawPolygons", value: function (e) {
            for (var n = this, a = this.w, r = e.parent, i = new et(this.ctx), s = a.globals.yAxisScale[0].result.reverse(), t = s.length, o = [], l = this.size / (t - 1), c = 0; c < t; c++) o[c] = l * c;
            o.reverse();
            var h = [], d = [];
            o.forEach(function (e, s) {
                var e = R.getPolygonPos(e, n.dataPointsLen), a = "";
                e.forEach(function (e, t) {
                    var i;
                    0 === s && (i = n.graphics.drawLine(e.x, e.y, 0, 0, Array.isArray(n.polygons.connectorColors) ? n.polygons.connectorColors[t] : n.polygons.connectorColors), d.push(i)), 0 === t && n.yaxisLabelsTextsPos.push({
                        x: e.x,
                        y: e.y
                    }), a += e.x + "," + e.y + " "
                }), h.push(a)
            }), h.forEach(function (e, t) {
                var i = n.polygons.strokeColors, s = n.polygons.strokeWidth,
                    e = n.graphics.drawPolygon(e, Array.isArray(i) ? i[t] : i, Array.isArray(s) ? s[t] : s, a.globals.radarPolygons.fill.colors[t]);
                r.add(e)
            }), d.forEach(function (e) {
                r.add(e)
            }), a.config.yaxis[0].show && this.yaxisLabelsTextsPos.forEach(function (e, t) {
                e = i.drawYAxisTexts(e.x, e.y, t, s[t]);
                n.yaxisLabels.add(e)
            })
        }
    }, {
        key: "drawXAxisTexts", value: function () {
            var n = this, r = this.w, o = r.config.xaxis.labels, l = this.graphics.group({class: "apexcharts-xaxis"}),
                c = R.getPolygonPos(this.size, this.dataPointsLen);
            return r.globals.labels.forEach(function (e, i) {
                var t, s = r.config.xaxis.labels.formatter, a = new L(n.ctx);
                c[i] && (t = n.getTextPos(c[i], n.size), s = s(e, {
                    seriesIndex: -1,
                    dataPointIndex: i,
                    w: r
                }), a.plotDataLabelsText({
                    x: t.newX,
                    y: t.newY,
                    text: s,
                    textAnchor: t.textAnchor,
                    i: i,
                    j: i,
                    parent: l,
                    className: "apexcharts-xaxis-label",
                    color: Array.isArray(o.style.colors) && o.style.colors[i] ? o.style.colors[i] : "#a8a8a8",
                    dataLabelsConfig: M({textAnchor: t.textAnchor, dropShadow: {enabled: !1}}, o),
                    offsetCorrection: !1
                }).on("click", function (e) {
                    var t;
                    "function" == typeof r.config.chart.events.xAxisLabelClick && (t = Object.assign({}, r, {labelIndex: i}), r.config.chart.events.xAxisLabelClick(e, n.ctx, t))
                }))
            }), l
        }
    }, {
        key: "createPaths", value: function (i, e) {
            var s, a, n = this, t = [], r = [], o = [], l = [];
            return i.length && (r = [this.graphics.move(e.x, e.y)], l = [this.graphics.move(e.x, e.y)], s = this.graphics.move(i[0].x, i[0].y), a = this.graphics.move(i[0].x, i[0].y), i.forEach(function (e, t) {
                s += n.graphics.line(e.x, e.y), a += n.graphics.line(e.x, e.y), t === i.length - 1 && (s += "Z", a += "Z")
            }), t.push(s), o.push(a)), {linePathsFrom: r, linePathsTo: t, areaPathsFrom: l, areaPathsTo: o}
        }
    }, {
        key: "getTextPos", value: function (e, t) {
            var i = "middle", s = e.x, a = e.y;
            return 10 <= Math.abs(e.x) ? 0 < e.x ? (i = "start", s += 10) : e.x < 0 && (i = "end", s -= 10) : i = "middle", Math.abs(e.y) >= t - 10 && (e.y < 0 ? a -= 10 : 0 < e.y && (a += 10)), {
                textAnchor: i,
                newX: s,
                newY: a
            }
        }
    }, {
        key: "getPreviousPath", value: function (e) {
            for (var t = this.w, i = null, s = 0; s < t.globals.previousPaths.length; s++) {
                var a = t.globals.previousPaths[s];
                0 < a.paths.length && parseInt(a.realIndex, 10) === parseInt(e, 10) && void 0 !== t.globals.previousPaths[s].paths[0] && (i = t.globals.previousPaths[s].paths[0].d)
            }
            return i
        }
    }, {
        key: "getDataPointsPos", value: function (e, t) {
            var i = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : this.dataPointsLen;
            e = e || [], t = t || [];
            for (var s = [], a = 0; a < i; a++) {
                var n = {};
                n.x = e[a] * Math.sin(t[a]), n.y = -e[a] * Math.cos(t[a]), s.push(n)
            }
            return s
        }
    }]), ot), st = (i(l, tt), he = t(l), e(l, [{
        key: "draw", value: function (e) {
            var t, i, s, a, n, r = this.w, o = new Y(this.ctx), l = o.group({class: "apexcharts-radialbar"});
            return r.globals.noData || (o = o.group(), a = this.defaultSize / 2, s = r.globals.gridWidth / 2, t = this.defaultSize / 2.05, r.config.chart.sparkline.enabled || (t = t - r.config.stroke.width - r.config.chart.dropShadow.blur), n = r.globals.fill.colors, r.config.plotOptions.radialBar.track.show && (i = this.drawTracks({
                size: t,
                centerX: s,
                centerY: a,
                colorArr: n,
                series: e
            }), o.add(i)), i = this.drawArcs({
                size: t,
                centerX: s,
                centerY: a,
                colorArr: n,
                series: e
            }), a = ((s = 360) - (s = r.config.plotOptions.radialBar.startAngle < 0 ? this.totalAngle : s)) / 360, r.globals.radialSize = t - t * a, this.radialDataLabels.value.show && (n = Math.max(this.radialDataLabels.value.offsetY, this.radialDataLabels.name.offsetY), r.globals.radialSize += n * a), o.add(i.g), "front" === r.config.plotOptions.radialBar.hollow.position && (i.g.add(i.elHollow), i.dataLabels) && i.g.add(i.dataLabels), l.add(o)), l
        }
    }, {
        key: "drawTracks", value: function (e) {
            var t = this.w, i = new Y(this.ctx), s = i.group({class: "apexcharts-tracks"}), a = new P(this.ctx),
                n = new S(this.ctx), r = this.getStrokeWidth(e);
            e.size = e.size - r / 2;
            for (var o = 0; o < e.series.length; o++) {
                var l = i.group({class: "apexcharts-radialbar-track apexcharts-track"}),
                    c = (s.add(l), l.attr({rel: o + 1}), e.size = e.size - r - this.margin, t.config.plotOptions.radialBar.track),
                    h = n.fillPath({
                        seriesNumber: 0,
                        size: e.size,
                        fillColors: Array.isArray(c.background) ? c.background[o] : c.background,
                        solid: !0
                    }), d = this.trackStartAngle, u = this.trackEndAngle,
                    h = (360 <= Math.abs(u) + Math.abs(d) && (u = 360 - Math.abs(this.startAngle) - .1), i.drawPath({
                        d: "",
                        stroke: h,
                        strokeWidth: r * parseInt(c.strokeWidth, 10) / 100,
                        fill: "none",
                        strokeOpacity: c.opacity,
                        classes: "apexcharts-radialbar-area"
                    }));
                c.dropShadow.enabled && (c = c.dropShadow, a.dropShadow(h, c)), l.add(h), h.attr("id", "apexcharts-radialbarTrack-" + o), this.animatePaths(h, {
                    centerX: e.centerX,
                    centerY: e.centerY,
                    endAngle: u,
                    startAngle: d,
                    size: e.size,
                    i: o,
                    totalItems: 2,
                    animBeginArr: 0,
                    dur: 0,
                    isTrack: !0,
                    easing: t.globals.easing
                })
            }
            return s
        }
    }, {
        key: "drawArcs", value: function (e) {
            for (var t, i = this.w, s = new Y(this.ctx), a = new S(this.ctx), n = new P(this.ctx), r = s.group(), o = this.getStrokeWidth(e), l = (e.size = e.size - o / 2, i.config.plotOptions.radialBar.hollow.background), c = e.size - o * e.series.length - this.margin * e.series.length - o * parseInt(i.config.plotOptions.radialBar.track.strokeWidth, 10) / 100 / 2, h = c - i.config.plotOptions.radialBar.hollow.margin, h = (void 0 !== i.config.plotOptions.radialBar.hollow.image && (l = this.drawHollowImage(e, r, c, l)), this.drawHollow({
                size: h,
                centerX: e.centerX,
                centerY: e.centerY,
                fill: l || "transparent"
            })), l = (i.config.plotOptions.radialBar.hollow.dropShadow.enabled && (l = i.config.plotOptions.radialBar.hollow.dropShadow, n.dropShadow(h, l)), 1), d = (!this.radialDataLabels.total.show && 1 < i.globals.series.length && (l = 0), null), u = (this.radialDataLabels.show && (t = i.globals.dom.Paper.select(".apexcharts-datalabels-group").members[0], d = this.renderInnerDataLabels(t, this.radialDataLabels, {
                hollowSize: c,
                centerX: e.centerX,
                centerY: e.centerY,
                opacity: l
            })), "back" === i.config.plotOptions.radialBar.hollow.position && (r.add(h), d) && r.add(d), !1), g = (u = i.config.plotOptions.radialBar.inverseOrder ? !0 : u) ? e.series.length - 1 : 0; u ? 0 <= g : g < e.series.length; u ? g-- : g++) {
                var p, f, x = s.group({
                        class: "apexcharts-series apexcharts-radial-series",
                        seriesName: R.escapeString(i.globals.seriesNames[g])
                    }), m = (r.add(x), x.attr({
                        rel: g + 1,
                        "data:realIndex": g
                    }), this.ctx.series.addCollapsedClassToSeries(x, g), e.size = e.size - o - this.margin, a.fillPath({
                        seriesNumber: g,
                        size: e.size,
                        value: e.series[g]
                    })), b = this.startAngle, v = void 0, y = R.negToZero(100 < e.series[g] ? 100 : e.series[g]) / 100,
                    y = Math.round(this.totalAngle * y) + this.startAngle, w = void 0,
                    k = (i.globals.dataChanged && (v = this.startAngle, w = Math.round(this.totalAngle * R.negToZero(i.globals.previousPaths[g]) / 100) + v), 360 <= Math.abs(y) + Math.abs(b) && (y -= .01), 360 <= Math.abs(w) + Math.abs(v) && (w -= .01), y - b),
                    A = Array.isArray(i.config.stroke.dashArray) ? i.config.stroke.dashArray[g] : i.config.stroke.dashArray,
                    m = s.drawPath({
                        d: "",
                        stroke: m,
                        strokeWidth: o,
                        fill: "none",
                        fillOpacity: i.config.fill.opacity,
                        classes: "apexcharts-radialbar-area apexcharts-radialbar-slice-" + g,
                        strokeDashArray: A
                    }), C = (Y.setAttrs(m.node, {
                        "data:angle": k,
                        "data:value": e.series[g]
                    }), i.config.chart.dropShadow.enabled && (A = i.config.chart.dropShadow, n.dropShadow(m, A, g)), n.setSelectionFilter(m, 0, g), this.addListeners(m, this.radialDataLabels), x.add(m), m.attr({
                        index: 0,
                        j: g
                    }), this.barLabels.enabled && (k = R.polarToCartesian(e.centerX, e.centerY, e.size, b), A = this.barLabels.formatter(i.globals.seriesNames[g], {
                        seriesIndex: g,
                        w: i
                    }), p = ["apexcharts-radialbar-label"], this.barLabels.onClick || p.push("apexcharts-no-click"), C = (C = this.barLabels.useSeriesColors ? i.globals.colors[g] : i.config.chart.foreColor) || i.config.chart.foreColor, f = k.x + this.barLabels.offsetX, k = k.y + this.barLabels.offsetY, (A = s.drawText({
                        x: f,
                        y: k,
                        text: A,
                        textAnchor: "end",
                        dominantBaseline: "middle",
                        fontFamily: this.barLabels.fontFamily,
                        fontWeight: this.barLabels.fontWeight,
                        fontSize: this.barLabels.fontSize,
                        foreColor: C,
                        cssClass: p.join(" ")
                    })).on("click", this.onBarLabelClick), A.attr({rel: g + 1}), 0 !== b && A.attr({
                        "transform-origin": "".concat(f, " ").concat(k),
                        transform: "rotate(".concat(b, " 0 0)")
                    }), x.add(A)), 0);
                !this.initialAnim || i.globals.resized || i.globals.dataChanged || (C = i.config.chart.animations.speed), i.globals.dataChanged && (C = i.config.chart.animations.dynamicAnimation.speed), this.animDur = C / (1.2 * e.series.length) + this.animDur, this.animBeginArr.push(this.animDur), this.animatePaths(m, {
                    centerX: e.centerX,
                    centerY: e.centerY,
                    endAngle: y,
                    startAngle: b,
                    prevEndAngle: w,
                    prevStartAngle: v,
                    size: e.size,
                    i: g,
                    totalItems: 2,
                    animBeginArr: this.animBeginArr,
                    dur: C,
                    shouldSetPrevPaths: !0,
                    easing: i.globals.easing
                })
            }
            return {g: r, elHollow: h, dataLabels: d}
        }
    }, {
        key: "drawHollow", value: function (e) {
            var t = new Y(this.ctx).drawCircle(2 * e.size);
            return t.attr({
                class: "apexcharts-radialbar-hollow",
                cx: e.centerX,
                cy: e.centerY,
                r: e.size,
                fill: e.fill
            }), t
        }
    }, {
        key: "drawHollowImage", value: function (t, e, i, s) {
            var a, n, r = this.w, o = new S(this.ctx), l = R.randomId(),
                c = r.config.plotOptions.radialBar.hollow.image;
            return r.config.plotOptions.radialBar.hollow.imageClipped ? (o.clippedImgArea({
                width: i,
                height: i,
                image: c,
                patternID: "pattern".concat(r.globals.cuid).concat(l)
            }), s = "url(#pattern".concat(r.globals.cuid).concat(l, ")")) : (a = r.config.plotOptions.radialBar.hollow.imageWidth, n = r.config.plotOptions.radialBar.hollow.imageHeight, void 0 === a && void 0 === n ? (o = r.globals.dom.Paper.image(c).loaded(function (e) {
                this.move(t.centerX - e.width / 2 + r.config.plotOptions.radialBar.hollow.imageOffsetX, t.centerY - e.height / 2 + r.config.plotOptions.radialBar.hollow.imageOffsetY)
            }), e.add(o)) : (i = r.globals.dom.Paper.image(c).loaded(function (e) {
                this.move(t.centerX - a / 2 + r.config.plotOptions.radialBar.hollow.imageOffsetX, t.centerY - n / 2 + r.config.plotOptions.radialBar.hollow.imageOffsetY), this.size(a, n)
            }), e.add(i))), s
        }
    }, {
        key: "getStrokeWidth", value: function (e) {
            var t = this.w;
            return e.size * (100 - parseInt(t.config.plotOptions.radialBar.hollow.size, 10)) / 100 / (e.series.length + 1) - this.margin
        }
    }, {
        key: "onBarLabelClick", value: function (e) {
            var e = parseInt(e.target.getAttribute("rel"), 10) - 1, t = this.barLabels.onClick, i = this.w;
            t && t(i.globals.seriesNames[e], {w: i, seriesIndex: e})
        }
    }]), l), at = (i(r, _), ce = t(r), e(r, [{
        key: "draw", value: function (e, t) {
            var i = this.w, s = new Y(this.ctx);
            this.rangeBarOptions = this.w.config.plotOptions.rangeBar, this.series = e, this.seriesRangeStart = i.globals.seriesRangeStart, this.seriesRangeEnd = i.globals.seriesRangeEnd, this.barHelpers.initVariables(e);
            for (var a = s.group({class: "apexcharts-rangebar-series apexcharts-plot-series"}), n = 0; n < e.length; n++) {
                var r = void 0, o = void 0, l = i.globals.comboCharts ? t[n] : n,
                    c = this.barHelpers.getGroupIndex(l).columnGroupIndex, h = s.group({
                        class: "apexcharts-series",
                        seriesName: R.escapeString(i.globals.seriesNames[l]),
                        rel: n + 1,
                        "data:realIndex": l
                    }),
                    d = (this.ctx.series.addCollapsedClassToSeries(h, l), 0 < e[n].length && (this.visibleI = this.visibleI + 1), 0),
                    u = 0, g = 0,
                    p = (1 < this.yRatio.length && (this.yaxisIndex = i.globals.seriesYAxisReverseMap[l][0], g = l), this.barHelpers.initialPositions()),
                    o = p.y, f = p.zeroW, r = p.x;
                u = p.barWidth, d = p.barHeight;
                for (var x = p.xDivision, m = p.yDivision, b = p.zeroH, v = s.group({
                    class: "apexcharts-datalabels",
                    "data:realIndex": l
                }), y = s.group({class: "apexcharts-rangebar-goals-markers"}), w = 0; w < i.globals.dataPoints; w++) {
                    var k, A = this.barHelpers.getStrokeWidth(n, w, l), C = this.seriesRangeStart[n][w],
                        S = this.seriesRangeEnd[n][w], L = null, T = null, E = null,
                        P = {x: r, y: o, strokeWidth: A, elSeries: h}, _ = this.seriesLen;
                    if (i.config.plotOptions.bar.rangeBarGroupRows && (_ = 1), void 0 === i.config.series[n].data[w]) break;
                    this.isHorizontal ? (E = o + d * this.visibleI, i.config.series[n].data[w].x && (d = (k = this.detectOverlappingBars({
                        i: n,
                        j: w,
                        barYPosition: E,
                        srty: (m - d * _) / 2,
                        barHeight: d,
                        yDivision: m,
                        initPositions: p
                    })).barHeight, E = k.barYPosition), u = (L = this.drawRangeBarPaths(M({
                        indexes: {
                            i: n,
                            j: w,
                            realIndex: l
                        }, barHeight: d, barYPosition: E, zeroW: f, yDivision: m, y1: C, y2: S
                    }, P))).barWidth) : (T = (r = i.globals.isXNumeric ? (i.globals.seriesX[n][w] - i.globals.minX) / this.xRatio - u / 2 : r) + u * this.visibleI, i.config.series[n].data[w].x && (u = (k = this.detectOverlappingBars({
                        i: n,
                        j: w,
                        barXPosition: T,
                        srtx: (x - u * _) / 2,
                        barWidth: u,
                        xDivision: x,
                        initPositions: p
                    })).barWidth, T = k.barXPosition), d = (L = this.drawRangeColumnPaths(M({
                        indexes: {
                            i: n,
                            j: w,
                            realIndex: l,
                            translationsIndex: g
                        }, barWidth: u, barXPosition: T, zeroH: b, xDivision: x
                    }, P))).barHeight);
                    _ = this.barHelpers.drawGoalLine({
                        barXPosition: L.barXPosition,
                        barYPosition: E,
                        goalX: L.goalX,
                        goalY: L.goalY,
                        barHeight: d,
                        barWidth: u
                    }), P = (_ && y.add(_), o = L.y, r = L.x, this.barHelpers.getPathFillColor(e, n, w, l)), _ = i.globals.stroke.colors[l];
                    this.renderSeries({
                        realIndex: l,
                        pathFill: P,
                        lineFill: _,
                        j: w,
                        i: n,
                        x: r,
                        y: o,
                        y1: C,
                        y2: S,
                        pathFrom: L.pathFrom,
                        pathTo: L.pathTo,
                        strokeWidth: A,
                        elSeries: h,
                        series: e,
                        barHeight: d,
                        barWidth: u,
                        barXPosition: T,
                        barYPosition: E,
                        columnGroupIndex: c,
                        elDataLabelsWrap: v,
                        elGoalsMarkers: y,
                        visibleSeries: this.visibleI,
                        type: "rangebar"
                    })
                }
                a.add(h)
            }
            return a
        }
    }, {
        key: "detectOverlappingBars", value: function (e) {
            var t = e.i, i = e.j, s = e.barYPosition, a = e.barXPosition, n = e.srty, r = e.srtx, o = e.barHeight,
                l = e.barWidth, c = e.yDivision, h = e.xDivision, e = e.initPositions, d = this.w, u = [],
                g = d.config.series[t].data[i].rangeName, i = d.config.series[t].data[i].x,
                p = Array.isArray(i) ? i.join(" ") : i, i = d.globals.labels.map(function (e) {
                    return Array.isArray(e) ? e.join(" ") : e
                }).indexOf(p), f = d.globals.seriesRange[t].findIndex(function (e) {
                    return e.x === p && 0 < e.overlaps.length
                });
            return this.isHorizontal ? (s = d.config.plotOptions.bar.rangeBarGroupRows ? n + c * i : n + o * this.visibleI + c * i, -1 < f && !d.config.plotOptions.bar.rangeBarOverlap && -1 < (u = d.globals.seriesRange[t][f].overlaps).indexOf(g) && (s = (o = e.barHeight / u.length) * this.visibleI + c * (100 - parseInt(this.barOptions.barHeight, 10)) / 100 / 2 + o * (this.visibleI + u.indexOf(g)) + c * i)) : (-1 < i && !d.globals.timescaleLabels.length && (a = d.config.plotOptions.bar.rangeBarGroupRows ? r + h * i : r + l * this.visibleI + h * i), -1 < f && !d.config.plotOptions.bar.rangeBarOverlap && -1 < (u = d.globals.seriesRange[t][f].overlaps).indexOf(g) && (a = (l = e.barWidth / u.length) * this.visibleI + h * (100 - parseInt(this.barOptions.barWidth, 10)) / 100 / 2 + l * (this.visibleI + u.indexOf(g)) + h * i)), {
                barYPosition: s,
                barXPosition: a,
                barHeight: o,
                barWidth: l
            }
        }
    }, {
        key: "drawRangeColumnPaths", value: function (e) {
            var t = e.indexes, i = e.x, s = e.xDivision, a = e.barWidth, n = e.barXPosition, e = e.zeroH, r = this.w,
                o = t.i, l = t.j, c = t.realIndex, t = t.translationsIndex, h = this.yRatio[t],
                d = this.getRangeValue(c, l), u = Math.min(d.start, d.end), g = Math.max(d.start, d.end),
                h = (null == this.series[o][l] ? u = e : (u = e - u / h, g = e - g / h), Math.abs(g - u)),
                p = this.barHelpers.getColumnPaths({
                    barXPosition: n,
                    barWidth: a,
                    y1: u,
                    y2: g,
                    strokeWidth: this.strokeWidth,
                    series: this.seriesRangeEnd,
                    realIndex: c,
                    i: c,
                    j: l,
                    w: r
                });
            return r.globals.isXNumeric ? (i = (r = this.getBarXForNumericXAxis({
                x: i,
                j: l,
                realIndex: c,
                barWidth: a
            })).x, n = r.barXPosition) : i += s, {
                pathTo: p.pathTo,
                pathFrom: p.pathFrom,
                barHeight: h,
                x: i,
                y: d.start < 0 && d.end < 0 ? u : g,
                goalY: this.barHelpers.getGoalValues("y", null, e, o, l, t),
                barXPosition: n
            }
        }
    }, {
        key: "preventBarOverflow", value: function (e) {
            var t = this.w;
            return e = (e = e < 0 ? 0 : e) > t.globals.gridWidth ? t.globals.gridWidth : e
        }
    }, {
        key: "drawRangeBarPaths", value: function (e) {
            var t = e.indexes, i = e.y, s = e.y2, a = e.yDivision, n = e.barHeight, r = e.barYPosition, o = e.zeroW,
                l = this.w, c = t.realIndex, t = t.j, e = this.preventBarOverflow(o + e.y1 / this.invertedYRatio),
                s = this.preventBarOverflow(o + s / this.invertedYRatio), h = this.getRangeValue(c, t),
                d = Math.abs(s - e), r = this.barHelpers.getBarpaths({
                    barYPosition: r,
                    barHeight: n,
                    x1: e,
                    x2: s,
                    strokeWidth: this.strokeWidth,
                    series: this.seriesRangeEnd,
                    i: c,
                    realIndex: c,
                    j: t,
                    w: l
                });
            return l.globals.isXNumeric || (i += a), {
                pathTo: r.pathTo,
                pathFrom: r.pathFrom,
                barWidth: d,
                x: h.start < 0 && h.end < 0 ? e : s,
                goalX: this.barHelpers.getGoalValues("x", o, null, c, t),
                y: i
            }
        }
    }, {
        key: "getRangeValue", value: function (e, t) {
            var i = this.w;
            return {start: i.globals.seriesRangeStart[e][t], end: i.globals.seriesRangeEnd[e][t]}
        }
    }]), r), nt = (e(rt, [{
        key: "sameValueSeriesFix", value: function (e, t) {
            var i = this.w;
            return "gradient" !== i.config.fill.type && "gradient" !== i.config.fill.type[e] || !new I(this.lineCtx.ctx, i).seriesHaveSameValues(e) || ((i = t[e].slice())[i.length - 1] = i[i.length - 1] + 1e-6, t[e] = i), t
        }
    }, {
        key: "calculatePoints", value: function (e) {
            var t, i = e.series, s = e.x, a = e.y, n = e.i, r = e.j, o = e.prevY, l = this.w, c = [], h = [];
            return 0 === r && (t = this.lineCtx.categoryAxisCorrection + l.config.markers.offsetX, l.globals.isXNumeric && (t = (l.globals.seriesX[e.realIndex][0] - l.globals.minX) / this.lineCtx.xRatio + l.config.markers.offsetX), c.push(t), h.push(R.isNumber(i[n][0]) ? o + l.config.markers.offsetY : null)), c.push(s + l.config.markers.offsetX), h.push(R.isNumber(i[n][r + 1]) ? a + l.config.markers.offsetY : null), {
                x: c,
                y: h
            }
        }
    }, {
        key: "checkPreviousPaths", value: function (e) {
            for (var t = e.pathFromLine, i = e.pathFromArea, s = e.realIndex, a = this.w, n = 0; n < a.globals.previousPaths.length; n++) {
                var r = a.globals.previousPaths[n];
                ("line" === r.type || "area" === r.type) && 0 < r.paths.length && parseInt(r.realIndex, 10) === parseInt(s, 10) && ("line" === r.type ? (this.lineCtx.appendPathFrom = !1, t = a.globals.previousPaths[n].paths[0].d) : "area" === r.type && (this.lineCtx.appendPathFrom = !1, i = a.globals.previousPaths[n].paths[0].d, a.config.stroke.show) && a.globals.previousPaths[n].paths[1] && (t = a.globals.previousPaths[n].paths[1].d))
            }
            return {pathFromLine: t, pathFromArea: i}
        }
    }, {
        key: "determineFirstPrevY", value: function (e) {
            var t = e.i, i = e.realIndex, s = e.series, a = e.prevY, n = e.lineYPosition, e = e.translationsIndex,
                r = this.w,
                i = r.config.chart.stacked && !r.globals.comboCharts || r.config.chart.stacked && r.globals.comboCharts && (!this.w.config.chart.stackOnlyBar || "bar" === (null == (r = this.w.config.series[i]) ? void 0 : r.type) || "column" === (null == (r = this.w.config.series[i]) ? void 0 : r.type));
            if (void 0 !== (null == (r = s[t]) ? void 0 : r[0])) a = (n = i && 0 < t ? this.lineCtx.prevSeriesY[t - 1][0] : this.lineCtx.zeroY) - s[t][0] / this.lineCtx.yRatio[e] + 2 * (this.lineCtx.isReversed ? s[t][0] / this.lineCtx.yRatio[e] : 0); else if (i && 0 < t && void 0 === s[t][0]) for (var o = t - 1; 0 <= o; o--) if (null != s[o][0]) {
                a = n = this.lineCtx.prevSeriesY[o][0];
                break
            }
            return {prevY: a, lineYPosition: n}
        }
    }]), rt);

    function rt(e) {
        s(this, rt), this.w = e.w, this.lineCtx = e
    }

    function r() {
        return s(this, r), ce.apply(this, arguments)
    }

    function l(e) {
        s(this, l), (t = he.call(this, e)).ctx = e, t.w = e.w, t.animBeginArr = [0], t.animDur = 0;
        var t, e = t.w;
        return t.startAngle = e.config.plotOptions.radialBar.startAngle, t.endAngle = e.config.plotOptions.radialBar.endAngle, t.totalAngle = Math.abs(e.config.plotOptions.radialBar.endAngle - e.config.plotOptions.radialBar.startAngle), t.trackStartAngle = e.config.plotOptions.radialBar.track.startAngle, t.trackEndAngle = e.config.plotOptions.radialBar.track.endAngle, t.barLabels = t.w.config.plotOptions.radialBar.barLabels, t.donutDataLabels = t.w.config.plotOptions.radialBar.dataLabels, t.radialDataLabels = t.donutDataLabels, t.trackStartAngle || (t.trackStartAngle = t.startAngle), t.trackEndAngle || (t.trackEndAngle = t.endAngle), 360 === t.endAngle && (t.endAngle = 359.99), t.margin = parseInt(e.config.plotOptions.radialBar.track.margin, 10), t.onBarLabelClick = t.onBarLabelClick.bind(z(t)), t
    }

    function ot(e) {
        s(this, ot), this.ctx = e, this.w = e.w, this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animDur = 0;
        e = this.w;
        this.graphics = new Y(this.ctx), this.lineColorArr = (void 0 !== e.globals.stroke.colors ? e.globals.stroke : e.globals).colors, this.defaultSize = e.globals.svgHeight < e.globals.svgWidth ? e.globals.gridHeight + 1.5 * e.globals.goldenPadding : e.globals.gridWidth, this.isLog = e.config.yaxis[0].logarithmic, this.logBase = e.config.yaxis[0].logBase, this.coreUtils = new I(this.ctx), this.maxValue = this.isLog ? this.coreUtils.getLogVal(this.logBase, e.globals.maxY, 0) : e.globals.maxY, this.minValue = this.isLog ? this.coreUtils.getLogVal(this.logBase, this.w.globals.minY, 0) : e.globals.minY, this.polygons = e.config.plotOptions.radar.polygons, this.strokeWidth = e.config.stroke.show ? e.config.stroke.width : 0, this.size = this.defaultSize / 2.1 - this.strokeWidth - e.config.chart.dropShadow.blur, e.config.xaxis.labels.show && (this.size = this.size - e.globals.xAxisLabelsWidth / 1.75), void 0 !== e.config.plotOptions.radar.size && (this.size = e.config.plotOptions.radar.size), this.dataRadiusOfPercent = [], this.dataRadius = [], this.angleArr = [], this.yaxisLabelsTextsPos = []
    }

    function lt(e) {
        s(this, lt), this.ctx = e, this.w = e.w;
        var e = this.w,
            t = (this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animBeginArr = [0], this.animDur = 0, this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels, this.lineColorArr = (void 0 !== e.globals.stroke.colors ? e.globals.stroke : e.globals).colors, this.defaultSize = Math.min(e.globals.gridWidth, e.globals.gridHeight), this.centerY = this.defaultSize / 2, this.centerX = e.globals.gridWidth / 2, "radialBar" === e.config.chart.type ? this.fullAngle = 360 : this.fullAngle = Math.abs(e.config.plotOptions.pie.endAngle - e.config.plotOptions.pie.startAngle), this.initialAngle = e.config.plotOptions.pie.startAngle % this.fullAngle, e.globals.radialSize = this.defaultSize / 2.05 - e.config.stroke.width - (e.config.chart.sparkline.enabled ? 0 : e.config.chart.dropShadow.blur), this.donutSize = e.globals.radialSize * parseInt(e.config.plotOptions.pie.donut.size, 10) / 100, e.config.plotOptions.pie.customScale),
            i = e.globals.gridWidth / 2, e = e.globals.gridHeight / 2;
        this.translateX = i - i * t, this.translateY = e - e * t, this.dataLabelsGroup = new Y(this.ctx).group({
            class: "apexcharts-datalabels-group",
            transform: "translate(".concat(this.translateX, ", ").concat(this.translateY, ") scale(").concat(t, ")")
        }), this.maxY = 0, this.sliceLabels = [], this.sliceSizes = [], this.prevSectorAngleArr = []
    }

    function ct(e) {
        s(this, ct), this.ctx = e, this.w = e.w
    }

    function ht(e, t) {
        s(this, ht), this.ctx = e, this.w = e.w, this.xRatio = t.xRatio, this.yRatio = t.yRatio, this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.helpers = new Ke(e), this.rectRadius = this.w.config.plotOptions.heatmap.radius, this.strokeWidth = this.w.config.stroke.show ? this.w.config.stroke.width : 0
    }

    function dt(e) {
        s(this, dt), this.ctx = e, this.w = e.w
    }

    function c() {
        return s(this, c), de.apply(this, arguments)
    }

    function h() {
        return s(this, h), ue.apply(this, arguments)
    }

    function ut(e, t) {
        s(this, ut), this.ctx = e, this.w = e.w;
        var e = this.w,
            e = (this.barOptions = e.config.plotOptions.bar, this.isHorizontal = this.barOptions.horizontal, this.strokeWidth = e.config.stroke.width, this.isNullValue = !1, this.isRangeBar = e.globals.seriesRange.length && this.isHorizontal, this.isVerticalGroupedRangeBar = !e.globals.isBarHorizontal && e.globals.seriesRange.length && e.config.plotOptions.bar.rangeBarGroupRows, this.isFunnel = this.barOptions.isFunnel, this.xyRatios = t, null !== this.xyRatios && (this.xRatio = t.xRatio, this.yRatio = t.yRatio, this.invertedXRatio = t.invertedXRatio, this.invertedYRatio = t.invertedYRatio, this.baseLineY = t.baseLineY, this.baseLineInvertedY = t.baseLineInvertedY), this.yaxisIndex = 0, this.translationsIndex = 0, this.seriesLen = 0, this.pathArr = [], new T(this.ctx)),
            i = (this.lastActiveBarSerieIndex = e.getActiveConfigSeriesIndex("desc", ["bar", "column"]), this.columnGroupIndices = [], e.getBarSeriesIndices()),
            t = new I(this.ctx);
        this.stackedSeriesTotals = t.getStackedSeriesTotals(this.w.config.series.map(function (e, t) {
            return -1 === i.indexOf(t) ? t : -1
        }).filter(function (e) {
            return -1 !== e
        })), this.barHelpers = new Ze(this)
    }

    function gt(e) {
        s(this, gt), this.w = e.w, this.barCtx = e
    }

    function pt(e) {
        s(this, pt), this.w = e.w, this.barCtx = e, this.totalFormatter = this.w.config.plotOptions.bar.dataLabels.total.formatter, this.totalFormatter || (this.totalFormatter = this.w.config.dataLabels.formatter)
    }

    function ft(e) {
        s(this, ft), this.ctx = e, this.w = e.w;
        e = this.w;
        this.tConfig = e.config.tooltip, this.tooltipUtil = new Ye(this), this.tooltipLabels = new We(this), this.tooltipPosition = new Be(this), this.marker = new je(this), this.intersect = new Ge(this), this.axesTooltip = new Ve(this), this.showOnIntersect = this.tConfig.intersect, this.showTooltipTitle = this.tConfig.x.show, this.fixedTooltip = this.tConfig.fixed.enabled, this.xaxisTooltip = null, this.yaxisTTEls = null, this.isBarShared = !e.globals.isBarHorizontal && this.tConfig.shared, this.lastHoverTime = Date.now()
    }

    function xt(e) {
        s(this, xt), this.w = e.w, this.ttCtx = e
    }

    function mt(e) {
        s(this, mt), this.w = e.w;
        var t = this.w;
        this.ttCtx = e, this.isVerticalGroupedRangeBar = !t.globals.isBarHorizontal && "rangeBar" === t.config.chart.type && t.config.plotOptions.bar.rangeBarGroupRows
    }

    function bt(e) {
        s(this, bt), this.w = e.w, this.ttCtx = e, this.ctx = e.ctx, this.tooltipPosition = new Be(e)
    }

    function vt(e) {
        s(this, vt), this.ttCtx = e, this.ctx = e.ctx, this.w = e.w
    }

    function yt(e) {
        s(this, yt), this.w = e.w, this.ctx = e.ctx, this.ttCtx = e, this.tooltipUtil = new Ye(e)
    }

    function wt(e) {
        s(this, wt), this.w = e.w, this.ttCtx = e, this.ctx = e.ctx
    }

    function x(e) {
        var t;
        return s(this, x), (t = ge.call(this, e)).ctx = e, t.w = e.w, t.dragged = !1, t.graphics = new Y(t.ctx), t.eventList = ["mousedown", "mouseleave", "mousemove", "touchstart", "touchmove", "mouseup", "touchend", "wheel"], t.clientX = 0, t.clientY = 0, t.startX = 0, t.endX = 0, t.dragX = 0, t.startY = 0, t.endY = 0, t.dragY = 0, t.moveDirection = "none", t.debounceTimer = null, t.debounceDelay = 100, t.wheelDelay = 400, t
    }

    function kt(e) {
        s(this, kt), this.ctx = e, this.w = e.w;
        e = this.w;
        this.ev = this.w.config.chart.events, this.selectedClass = "apexcharts-selected", this.localeValues = this.w.globals.locale.toolbar, this.minX = e.globals.minX, this.maxX = e.globals.maxX
    }

    function At(e) {
        s(this, At), this.ctx = e, this.w = e.w, this.onLegendClick = this.onLegendClick.bind(this), this.onLegendHovered = this.onLegendHovered.bind(this), this.isBarsDistributed = "bar" === this.w.config.chart.type && this.w.config.plotOptions.bar.distributed && 1 === this.w.config.series.length, this.legendHelpers = new Ne(this)
    }

    function Ct(e) {
        s(this, Ct), this.w = e.w, this.lgCtx = e
    }

    function St(e) {
        s(this, St), this.ctx = e, this.w = e.w, this.lgRect = {}, this.yAxisWidth = 0, this.yAxisWidthLeft = 0, this.yAxisWidthRight = 0, this.xAxisHeight = 0, this.isSparkline = this.w.config.chart.sparkline.enabled, this.dimHelpers = new Ie(this), this.dimYAxis = new De(this), this.dimXAxis = new Oe(this), this.dimGrid = new ze(this), this.lgWidthForSideLegends = 0, this.gridPad = this.w.config.grid.padding, this.xPadRight = 0, this.xPadLeft = 0
    }

    function Lt(e) {
        s(this, Lt), this.w = e.w, this.dCtx = e
    }

    function Tt(e) {
        s(this, Tt), this.w = e.w, this.dCtx = e
    }

    function Et(e) {
        s(this, Et), this.w = e.w, this.dCtx = e
    }

    function Pt(e) {
        s(this, Pt), this.w = e.w, this.dCtx = e
    }

    function _t(e) {
        s(this, _t), this.ctx = e, this.w = e.w
    }

    function Mt(e) {
        s(this, Mt), this.ctx = e, this.colors = [], this.w = e.w;
        e = this.w;
        this.isColorFn = !1, this.isHeatmapDistributed = "treemap" === e.config.chart.type && e.config.plotOptions.treemap.distributed || "heatmap" === e.config.chart.type && e.config.plotOptions.heatmap.distributed, this.isBarDistributed = e.config.plotOptions.bar.distributed && ("bar" === e.config.chart.type || "rangeBar" === e.config.chart.type)
    }

    function It(e) {
        s(this, It), this.ctx = e, this.w = e.w
    }

    function Ot(e) {
        s(this, Ot), this.ctx = e, this.w = e.w
    }

    function Dt(e) {
        s(this, Dt), this.ctx = e, this.w = e.w
    }

    function zt(e) {
        s(this, zt), this.ctx = e, this.w = e.w
    }

    function Xt(e) {
        s(this, Xt), this.ctx = e, this.w = e.w, this.documentEvent = R.bind(this.documentEvent, this)
    }

    function Nt(e, t) {
        s(this, Nt), this.ctx = e, this.elgrid = t, this.w = e.w;
        t = this.w;
        this.xaxisFontSize = t.config.xaxis.labels.style.fontSize, this.axisFontFamily = t.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = t.config.xaxis.labels.style.colors, this.isCategoryBarHorizontal = "bar" === t.config.chart.type && t.config.plotOptions.bar.horizontal, this.xAxisoffX = 0, "bottom" === t.config.xaxis.position && (this.xAxisoffX = t.globals.gridHeight), this.drawnLabels = [], this.axesUtils = new w(e)
    }

    function Ft(e) {
        s(this, Ft), this.ctx = e, this.w = e.w, this.scales = new ke(e)
    }

    function Ht(e) {
        s(this, Ht), this.ctx = e, this.w = e.w
    }

    function Rt(e) {
        s(this, Rt), this.ctx = e, this.w = e.w;
        var t = this.w;
        this.xaxisLabels = t.globals.labels.slice(), this.axesUtils = new w(e), this.isRangeBar = t.globals.seriesRange.length && t.globals.isBarHorizontal, 0 < t.globals.timescaleLabels.length && (this.xaxisLabels = t.globals.timescaleLabels.slice())
    }

    function Yt(e, t) {
        s(this, Yt), this.ctx = e, this.elgrid = t, this.w = e.w;
        t = this.w;
        this.axesUtils = new w(e), this.xaxisLabels = t.globals.labels.slice(), 0 < t.globals.timescaleLabels.length && !t.globals.isBarHorizontal && (this.xaxisLabels = t.globals.timescaleLabels.slice()), t.config.xaxis.overwriteCategories && (this.xaxisLabels = t.config.xaxis.overwriteCategories), this.drawnLabels = [], this.drawnLabelsRects = [], "top" === t.config.xaxis.position ? this.offY = 0 : this.offY = t.globals.gridHeight, this.offY = this.offY + t.config.xaxis.axisBorder.offsetY, this.isCategoryBarHorizontal = "bar" === t.config.chart.type && t.config.plotOptions.bar.horizontal, this.xaxisFontSize = t.config.xaxis.labels.style.fontSize, this.xaxisFontFamily = t.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = t.config.xaxis.labels.style.colors, this.xaxisBorderWidth = t.config.xaxis.axisBorder.width, this.isCategoryBarHorizontal && (this.xaxisBorderWidth = t.config.yaxis[0].axisBorder.width.toString()), -1 < this.xaxisBorderWidth.indexOf("%") ? this.xaxisBorderWidth = t.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10) / 100 : this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth, 10), this.xaxisBorderHeight = t.config.xaxis.axisBorder.height, this.yaxis = t.config.yaxis[0]
    }

    function Wt(e) {
        s(this, Wt), this.ctx = e, this.w = e.w
    }

    function Bt(e) {
        s(this, Bt), this.ctx = e, this.w = e.w, this.twoDSeries = [], this.threeDSeries = [], this.twoDSeriesX = [], this.seriesGoals = [], this.coreUtils = new I(this.ctx)
    }

    function jt(e) {
        s(this, jt), this.ctx = e, this.w = e.w, this.legendInactiveClass = "legend-mouseover-inactive"
    }

    function Gt(e) {
        s(this, Gt), this.ctx = e, this.w = e.w
    }

    function Vt(e) {
        s(this, Vt), this.ctx = e, this.w = e.w, this.initialAnim = this.w.config.chart.animations.enabled
    }

    function qt(e, t) {
        s(this, qt), this.ctx = e, this.w = e.w
    }

    function Ut(e) {
        s(this, Ut), this.ctx = e, this.w = e.w, this.opts = null, this.seriesIndex = 0, this.patternIDs = []
    }

    function Zt(e) {
        s(this, Zt), this.opts = e
    }

    function $t() {
        s(this, $t)
    }

    function Qt(e) {
        s(this, Qt), this.opts = e
    }

    function Kt(e) {
        s(this, Kt), this.opts = e
    }

    function Jt(e) {
        s(this, Jt), this.ctx = e, this.w = e.w, this.graphics = new Y(this.ctx), this.w.globals.isBarHorizontal && (this.invertAxis = !0), this.helpers = new a(this), this.xAxisAnnotations = new V(this), this.yAxisAnnotations = new q(this), this.pointsAnnotations = new U(this), this.w.globals.isBarHorizontal && this.w.config.yaxis[0].reversed && (this.inversedReversedAxis = !0), this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints
    }

    function ei() {
        s(this, ei), this.yAxis = {
            show: !0,
            showAlways: !1,
            showForNullSeries: !0,
            seriesName: void 0,
            opposite: !1,
            reversed: !1,
            logarithmic: !1,
            logBase: 10,
            tickAmount: void 0,
            stepSize: void 0,
            forceNiceScale: !1,
            max: void 0,
            min: void 0,
            floating: !1,
            decimalsInFloat: void 0,
            labels: {
                show: !0,
                minWidth: 0,
                maxWidth: 160,
                offsetX: 0,
                offsetY: 0,
                align: void 0,
                rotate: 0,
                padding: 20,
                style: {colors: [], fontSize: "11px", fontWeight: 400, fontFamily: void 0, cssClass: ""},
                formatter: void 0
            },
            axisBorder: {show: !1, color: "#e0e0e0", width: 1, offsetX: 0, offsetY: 0},
            axisTicks: {show: !1, color: "#e0e0e0", width: 6, offsetX: 0, offsetY: 0},
            title: {
                text: void 0,
                rotate: -90,
                offsetY: 0,
                offsetX: 0,
                style: {color: void 0, fontSize: "11px", fontWeight: 900, fontFamily: void 0, cssClass: ""}
            },
            tooltip: {enabled: !1, offsetX: 0},
            crosshairs: {show: !0, position: "front", stroke: {color: "#b6b6b6", width: 1, dashArray: 0}}
        }, this.pointAnnotation = {
            id: void 0,
            x: 0,
            y: null,
            yAxisIndex: 0,
            seriesIndex: void 0,
            mouseEnter: void 0,
            mouseLeave: void 0,
            click: void 0,
            marker: {
                size: 4,
                fillColor: "#fff",
                strokeWidth: 2,
                strokeColor: "#333",
                shape: "circle",
                offsetX: 0,
                offsetY: 0,
                cssClass: ""
            },
            label: {
                borderColor: "#c2c2c2",
                borderWidth: 1,
                borderRadius: 2,
                text: void 0,
                textAnchor: "middle",
                offsetX: 0,
                offsetY: 0,
                mouseEnter: void 0,
                mouseLeave: void 0,
                click: void 0,
                style: {
                    background: "#fff",
                    color: void 0,
                    fontSize: "11px",
                    fontFamily: void 0,
                    fontWeight: 400,
                    cssClass: "",
                    padding: {left: 5, right: 5, top: 2, bottom: 2}
                }
            },
            customSVG: {SVG: void 0, cssClass: void 0, offsetX: 0, offsetY: 0},
            image: {path: void 0, width: 20, height: 20, offsetX: 0, offsetY: 0}
        }, this.yAxisAnnotation = {
            id: void 0,
            y: 0,
            y2: null,
            strokeDashArray: 1,
            fillColor: "#c2c2c2",
            borderColor: "#c2c2c2",
            borderWidth: 1,
            opacity: .3,
            offsetX: 0,
            offsetY: 0,
            width: "100%",
            yAxisIndex: 0,
            label: {
                borderColor: "#c2c2c2",
                borderWidth: 1,
                borderRadius: 2,
                text: void 0,
                textAnchor: "end",
                position: "right",
                offsetX: 0,
                offsetY: -3,
                mouseEnter: void 0,
                mouseLeave: void 0,
                click: void 0,
                style: {
                    background: "#fff",
                    color: void 0,
                    fontSize: "11px",
                    fontFamily: void 0,
                    fontWeight: 400,
                    cssClass: "",
                    padding: {left: 5, right: 5, top: 2, bottom: 2}
                }
            }
        }, this.xAxisAnnotation = {
            id: void 0,
            x: 0,
            x2: null,
            strokeDashArray: 1,
            fillColor: "#c2c2c2",
            borderColor: "#c2c2c2",
            borderWidth: 1,
            opacity: .3,
            offsetX: 0,
            offsetY: 0,
            label: {
                borderColor: "#c2c2c2",
                borderWidth: 1,
                borderRadius: 2,
                text: void 0,
                textAnchor: "middle",
                orientation: "vertical",
                position: "top",
                offsetX: 0,
                offsetY: 0,
                mouseEnter: void 0,
                mouseLeave: void 0,
                click: void 0,
                style: {
                    background: "#fff",
                    color: void 0,
                    fontSize: "11px",
                    fontFamily: void 0,
                    fontWeight: 400,
                    cssClass: "",
                    padding: {left: 5, right: 5, top: 2, bottom: 2}
                }
            }
        }, this.text = {
            x: 0,
            y: 0,
            text: "",
            textAnchor: "start",
            foreColor: void 0,
            fontSize: "13px",
            fontFamily: void 0,
            fontWeight: 400,
            appendTo: ".apexcharts-annotations",
            backgroundColor: "transparent",
            borderColor: "#c2c2c2",
            borderRadius: 0,
            borderWidth: 0,
            paddingLeft: 4,
            paddingRight: 4,
            paddingTop: 2,
            paddingBottom: 2
        }
    }

    function ti(e, t) {
        return (t[1] - e[1]) / (t[0] - e[0])
    }

    e(si, [{
        key: "draw", value: function (e, t, i, s) {
            var a = this.w, n = new Y(this.ctx), r = a.globals.comboCharts ? t : a.config.chart.type,
                o = n.group({class: "apexcharts-".concat(r, "-series apexcharts-plot-series")}), t = new I(this.ctx, a);
            this.yRatio = this.xyRatios.yRatio, this.zRatio = this.xyRatios.zRatio, this.xRatio = this.xyRatios.xRatio, this.baseLineY = this.xyRatios.baseLineY, e = t.getLogSeries(e), this.yRatio = t.getLogYRatios(this.yRatio), this.prevSeriesY = [];
            for (var l = [], c = 0; c < e.length; c++) {
                e = this.lineHelpers.sameValueSeriesFix(c, e);
                var h = a.globals.comboCharts ? i[c] : c, d = 1 < this.yRatio.length ? h : 0,
                    u = (this._initSerieVariables(e, c, h), []), g = [], p = [],
                    f = a.globals.padHorizontal + this.categoryAxisCorrection;
                this.ctx.series.addCollapsedClassToSeries(this.elSeries, h), a.globals.isXNumeric && 0 < a.globals.seriesX.length && (f = (a.globals.seriesX[h][0] - a.globals.minX) / this.xRatio), p.push(f);
                var x, m = f, b = void 0, v = m, y = this.zeroY, w = this.zeroY,
                    y = this.lineHelpers.determineFirstPrevY({
                        i: c,
                        realIndex: h,
                        series: e,
                        prevY: y,
                        lineYPosition: 0,
                        translationsIndex: d
                    }).prevY,
                    y = ("monotoneCubic" === a.config.stroke.curve && null === e[c][0] ? u.push(null) : u.push(y), x = y, "rangeArea" === r && (b = w = this.lineHelpers.determineFirstPrevY({
                        i: c,
                        realIndex: h,
                        series: s,
                        prevY: w,
                        lineYPosition: 0,
                        translationsIndex: d
                    }).prevY, g.push(null !== u[0] ? w : null)), this._calculatePathsFrom({
                        type: r,
                        series: e,
                        i: c,
                        realIndex: h,
                        translationsIndex: d,
                        prevX: v,
                        prevY: y,
                        prevY2: w
                    })), k = [u[0]], A = [g[0]], d = {
                        type: r,
                        series: e,
                        realIndex: h,
                        translationsIndex: d,
                        i: c,
                        x: f,
                        y: 1,
                        pX: m,
                        pY: x,
                        pathsFrom: y,
                        linePaths: [],
                        areaPaths: [],
                        seriesIndex: i,
                        lineYPosition: 0,
                        xArrj: p,
                        yArrj: u,
                        y2Arrj: g,
                        seriesRangeEnd: s
                    }, C = this._iterateOverDataPoints(M(M({}, d), {}, {
                        iterations: "rangeArea" === r ? e[c].length - 1 : void 0,
                        isRangeStart: !0
                    }));
                if ("rangeArea" === r) {
                    for (var m = this._calculatePathsFrom({
                        series: s,
                        i: c,
                        realIndex: h,
                        prevX: v,
                        prevY: w
                    }), S = this._iterateOverDataPoints(M(M({}, d), {}, {
                        series: s,
                        xArrj: [f],
                        yArrj: k,
                        y2Arrj: A,
                        pY: b,
                        areaPaths: C.areaPaths,
                        pathsFrom: m,
                        iterations: s[c].length - 1,
                        isRangeStart: !1
                    })), L = C.linePaths.length / 2, T = 0; T < L; T++) C.linePaths[T] = S.linePaths[T + L] + C.linePaths[T];
                    C.linePaths.splice(L), C.pathFromLine = S.pathFromLine + C.pathFromLine
                } else C.pathFromArea += "z";
                this._handlePaths({
                    type: r,
                    realIndex: h,
                    i: c,
                    paths: C
                }), this.elSeries.add(this.elPointsMain), this.elSeries.add(this.elDataLabelsWrap), l.push(this.elSeries)
            }
            if (void 0 !== (null == (n = a.config.series[0]) ? void 0 : n.zIndex) && l.sort(function (e, t) {
                return Number(e.node.getAttribute("zIndex")) - Number(t.node.getAttribute("zIndex"))
            }), a.config.chart.stacked) for (var E = l.length - 1; 0 <= E; E--) o.add(l[E]); else for (var P = 0; P < l.length; P++) o.add(l[P]);
            return o
        }
    }, {
        key: "_initSerieVariables", value: function (e, t, i) {
            var s = this.w, a = new Y(this.ctx),
                n = (this.xDivision = s.globals.gridWidth / (s.globals.dataPoints - ("on" === s.config.xaxis.tickPlacement ? 1 : 0)), this.strokeWidth = Array.isArray(s.config.stroke.width) ? s.config.stroke.width[i] : s.config.stroke.width, 0),
                n = (1 < this.yRatio.length && (this.yaxisIndex = s.globals.seriesYAxisReverseMap[i], n = i), this.isReversed = s.config.yaxis[this.yaxisIndex] && s.config.yaxis[this.yaxisIndex].reversed, this.zeroY = s.globals.gridHeight - this.baseLineY[n] - (this.isReversed ? s.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[n] : 0), this.areaBottomY = this.zeroY, (this.zeroY > s.globals.gridHeight || "end" === s.config.plotOptions.area.fillTo) && (this.areaBottomY = s.globals.gridHeight), this.categoryAxisCorrection = this.xDivision / 2, this.elSeries = a.group({
                    class: "apexcharts-series",
                    zIndex: void 0 !== s.config.series[i].zIndex ? s.config.series[i].zIndex : i,
                    seriesName: R.escapeString(s.globals.seriesNames[i])
                }), this.elPointsMain = a.group({
                    class: "apexcharts-series-markers-wrap",
                    "data:realIndex": i
                }), this.elDataLabelsWrap = a.group({
                    class: "apexcharts-datalabels",
                    "data:realIndex": i
                }), e[t].length === s.globals.dataPoints);
            this.elSeries.attr({"data:longestSeries": n, rel: t + 1, "data:realIndex": i}), this.appendPathFrom = !0
        }
    }, {
        key: "_calculatePathsFrom", value: function (e) {
            var t, i, s = e.type, a = e.series, n = e.i, r = e.realIndex, o = e.translationsIndex, l = e.prevX,
                c = e.prevY, e = e.prevY2, h = this.w, d = new Y(this.ctx);
            if (null === a[n][0]) {
                for (var u = 0; u < a[n].length; u++) if (null !== a[n][u]) {
                    l = this.xDivision * u, c = this.zeroY - a[n][u] / this.yRatio[o], t = d.move(l, c), i = d.move(l, this.areaBottomY);
                    break
                }
            } else t = d.move(l, c), "rangeArea" === s && (t = d.move(l, e) + d.line(l, c)), i = d.move(l, this.areaBottomY) + d.line(l, c);
            return s = d.move(0, this.zeroY) + d.line(0, this.zeroY), e = d.move(0, this.zeroY) + d.line(0, this.zeroY), 0 < h.globals.previousPaths.length && (s = (h = this.lineHelpers.checkPreviousPaths({
                pathFromLine: s,
                pathFromArea: e,
                realIndex: r
            })).pathFromLine, e = h.pathFromArea), {
                prevX: l,
                prevY: c,
                linePath: t,
                areaPath: i,
                pathFromLine: s,
                pathFromArea: e
            }
        }
    }, {
        key: "_handlePaths", value: function (e) {
            var t, i = e.type, s = e.realIndex, a = e.i, n = e.paths, r = this.w, o = new Y(this.ctx),
                l = new S(this.ctx),
                c = (this.prevSeriesY.push(n.yArrj), r.globals.seriesXvalues[s] = n.xArrj, r.globals.seriesYvalues[s] = n.yArrj, r.config.forecastDataPoints),
                h = (0 < c.count && "rangeArea" !== i && (e = r.globals.seriesXvalues[s][r.globals.seriesXvalues[s].length - c.count - 1], t = o.drawRect(e, 0, r.globals.gridWidth, r.globals.gridHeight, 0), r.globals.dom.elForecastMask.appendChild(t.node), t = o.drawRect(0, 0, e, r.globals.gridHeight, 0), r.globals.dom.elNonForecastMask.appendChild(t.node)), this.pointsChart || r.globals.delayedElements.push({
                    el: this.elPointsMain.node,
                    index: s
                }), {
                    i: a,
                    realIndex: s,
                    animationDelay: a,
                    initialSpeed: r.config.chart.animations.speed,
                    dataChangeSpeed: r.config.chart.animations.dynamicAnimation.speed,
                    className: "apexcharts-".concat(i)
                });
            if ("area" === i) for (var d = l.fillPath({seriesNumber: s}), u = 0; u < n.areaPaths.length; u++) {
                var g = o.renderPaths(M(M({}, h), {}, {
                    pathFrom: n.pathFromArea,
                    pathTo: n.areaPaths[u],
                    stroke: "none",
                    strokeWidth: 0,
                    strokeLineCap: null,
                    fill: d
                }));
                this.elSeries.add(g)
            }
            if (r.config.stroke.show && !this.pointsChart) {
                var p = null;
                "line" === i ? p = l.fillPath({
                    seriesNumber: s,
                    i: a
                }) : "solid" === r.config.stroke.fill.type ? p = r.globals.stroke.colors[s] : (e = r.config.fill, r.config.fill = r.config.stroke.fill, p = l.fillPath({
                    seriesNumber: s,
                    i: a
                }), r.config.fill = e);
                for (var f = 0; f < n.linePaths.length; f++) {
                    var x = p, x = ("rangeArea" === i && (x = l.fillPath({seriesNumber: s})), M(M({}, h), {}, {
                        pathFrom: n.pathFromLine,
                        pathTo: n.linePaths[f],
                        stroke: p,
                        strokeWidth: this.strokeWidth,
                        strokeLineCap: r.config.stroke.lineCap,
                        fill: "rangeArea" === i ? x : "none"
                    })), m = o.renderPaths(x);
                    this.elSeries.add(m), m.attr("fill-rule", "evenodd"), 0 < c.count && "rangeArea" !== i && ((x = o.renderPaths(x)).node.setAttribute("stroke-dasharray", c.dashArray), c.strokeWidth && x.node.setAttribute("stroke-width", c.strokeWidth), this.elSeries.add(x), x.attr("clip-path", "url(#forecastMask".concat(r.globals.cuid, ")")), m.attr("clip-path", "url(#nonForecastMask".concat(r.globals.cuid, ")")))
                }
            }
        }
    }, {
        key: "_iterateOverDataPoints", value: function (e) {
            function t(e, t) {
                return t - e / S[o] + 2 * (i.isReversed ? e / S[o] : 0)
            }

            var i = this, s = e.type, a = e.series, n = e.iterations, r = e.realIndex, o = e.translationsIndex, l = e.i,
                c = e.x, h = e.y, d = e.pX, u = e.pY, g = e.pathsFrom, p = e.linePaths, f = e.areaPaths,
                x = e.seriesIndex, m = e.lineYPosition, b = e.xArrj, v = e.yArrj, y = e.y2Arrj, w = e.isRangeStart,
                k = e.seriesRangeEnd, A = this.w, C = new Y(this.ctx), S = this.yRatio, L = g.prevY, T = g.linePath,
                E = g.areaPath, P = g.pathFromLine, _ = g.pathFromArea,
                X = R.isNumber(A.globals.minYArr[r]) ? A.globals.minYArr[r] : A.globals.minY,
                n = n || (1 < A.globals.dataPoints ? A.globals.dataPoints - 1 : A.globals.dataPoints), M = h,
                N = A.config.chart.stacked && !A.globals.comboCharts || A.config.chart.stacked && A.globals.comboCharts && (!this.w.config.chart.stackOnlyBar || "bar" === (null == (e = this.w.config.series[r]) ? void 0 : e.type) || "column" === (null == (g = this.w.config.series[r]) ? void 0 : g.type)),
                I = A.config.stroke.curve;
            Array.isArray(I) && (I = Array.isArray(x) ? I[x[l]] : I[l]);
            for (var F = 0, O = 0; O < n; O++) {
                var D = null == a[l][O + 1],
                    z = (A.globals.isXNumeric ? (z = A.globals.seriesX[r][O + 1], c = ((z = void 0 === A.globals.seriesX[r][O + 1] ? A.globals.seriesX[r][n - 1] : z) - A.globals.minX) / this.xRatio) : c += this.xDivision, m = N && 0 < l && A.globals.collapsedSeries.length < A.config.series.length - 1 ? this.prevSeriesY[(() => {
                        for (var e = l - 1; 0 < e; e--) {
                            if (!(-1 < A.globals.collapsedSeriesIndices.indexOf((null == x ? void 0 : x[e]) || e))) return e;
                            e--
                        }
                        return 0
                    })()][O + 1] : this.zeroY, D ? h = t(X, m) : (h = t(a[l][O + 1], m), "rangeArea" === s && (M = t(k[l][O + 1], m))), b.push(c), !D || "smooth" !== A.config.stroke.curve && "monotoneCubic" !== A.config.stroke.curve ? (v.push(h), y.push(M)) : (v.push(null), y.push(null)), this.lineHelpers.calculatePoints({
                        series: a,
                        x: c,
                        y: h,
                        realIndex: r,
                        i: l,
                        j: O,
                        prevY: L
                    })), D = this._createPaths({
                        type: s,
                        series: a,
                        i: l,
                        realIndex: r,
                        j: O,
                        x: c,
                        y: h,
                        y2: M,
                        xArrj: b,
                        yArrj: v,
                        y2Arrj: y,
                        pX: d,
                        pY: u,
                        pathState: F,
                        segmentStartX: H,
                        linePath: T,
                        areaPath: E,
                        linePaths: p,
                        areaPaths: f,
                        curve: I,
                        isRangeStart: w
                    }), f = D.areaPaths, p = D.linePaths, d = D.pX, u = D.pY, F = D.pathState, H = D.segmentStartX,
                    E = D.areaPath, T = D.linePath;
                !this.appendPathFrom || "monotoneCubic" === I && "rangeArea" === s || (P += C.line(c, this.zeroY), _ += C.line(c, this.zeroY)), this.handleNullDataPoints(a, z, l, O, r), this._handleMarkersAndLabels({
                    type: s,
                    pointsPos: z,
                    i: l,
                    j: O,
                    realIndex: r,
                    isRangeStart: w
                })
            }
            return {
                yArrj: v,
                xArrj: b,
                pathFromArea: _,
                areaPaths: f,
                pathFromLine: P,
                linePaths: p,
                linePath: T,
                areaPath: E
            }
        }
    }, {
        key: "_handleMarkersAndLabels", value: function (e) {
            var t = e.type, i = e.pointsPos, s = e.isRangeStart, a = e.i, n = e.j, e = e.realIndex, r = this.w,
                o = new L(this.ctx), a = (this.pointsChart ? this.scatter.draw(this.elSeries, n, {
                    realIndex: e,
                    pointsPos: i,
                    zRatio: this.zRatio,
                    elParent: this.elPointsMain
                }) : (1 < r.globals.series[a].length && this.elPointsMain.node.classList.add("apexcharts-element-hidden"), null !== (r = this.markers.plotChartMarkers(i, e, n + 1)) && this.elPointsMain.add(r)), o.drawDataLabel({
                    type: t,
                    isRangeStart: s,
                    pos: i,
                    i: e,
                    j: n + 1
                }));
            null !== a && this.elDataLabelsWrap.add(a)
        }
    }, {
        key: "_createPaths", value: function (e) {
            var t = e.type, i = e.series, s = e.i, a = e.j, n = e.x, r = e.y, o = e.xArrj, X = e.yArrj, l = e.y2,
                c = e.y2Arrj, h = e.pX, d = e.pY, u = e.pathState, g = e.segmentStartX, p = e.linePath, f = e.areaPath,
                x = e.linePaths, m = e.areaPaths, b = e.curve, v = e.isRangeStart;
            this.w;
            var y, w = new Y(this.ctx), k = this.areaBottomY, A = "rangeArea" === t, C = "rangeArea" === t && v;
            switch (b) {
                case"monotoneCubic":
                    var S = v ? X : c;
                    switch (u) {
                        case 0:
                            if (null === S[a + 1]) break;
                            u = 1;
                        case 1:
                            if (!(A ? o.length === i[s].length : a === i[s].length - 2)) break;
                        case 2:
                            var L = v ? o : o.slice().reverse(), T = v ? S : S.slice().reverse(),
                                E = (y = T, L.map(function (e, t) {
                                    return [e, y[t]]
                                }).filter(function (e) {
                                    return null !== e[1]
                                })), L = 1 < E.length ? (e => {
                                    var t = le(e), i = e[1], s = e[0], a = [], n = t[1], r = t[0];
                                    a.push(s, [s[0] + r[0], s[1] + r[1], i[0] - n[0], i[1] - n[1], i[0], i[1]]);
                                    for (var o = 2, l = t.length; o < l; o++) {
                                        var c = e[o], h = t[o];
                                        a.push([c[0] - h[0], c[1] - h[1], c[0], c[1]])
                                    }
                                    return a
                                })(E) : E, P = [], _ = (A && (C ? m = E : P = m.reverse()), 0), M = 0;
                            ((e, t) => {
                                i = [], s = 0, e.forEach(function (e) {
                                    null !== e ? s++ : 0 < s && (i.push(s), s = 0)
                                }), 0 < s && i.push(s);
                                for (var i, s, a = i, n = [], r = 0, o = 0; r < a.length; o += a[r++]) n[r] = ((e, t, i) => (e = e.slice(t, i), t && (1 < i - t && e[1].length < 6 && (i = e[0].length, e[1] = [2 * e[0][i - 2] - e[0][i - 4], 2 * e[0][i - 1] - e[0][i - 3]].concat(e[1])), e[0] = e[0].slice(-2)), e))(t, o, o + a[r]);
                                return n
                            })(T, L).forEach(function (e) {
                                _++;
                                var t = (e => {
                                    for (var t = "", i = 0; i < e.length; i++) {
                                        var s = e[i], a = s.length;
                                        4 < a ? t = (t = (t += "C".concat(s[0], ", ").concat(s[1])) + ", ".concat(s[2], ", ").concat(s[3])) + ", ".concat(s[4], ", ").concat(s[5]) : 2 < a && (t = (t += "S".concat(s[0], ", ").concat(s[1])) + ", ".concat(s[2], ", ").concat(s[3]))
                                    }
                                    return t
                                })(e), i = M, e = (M += e.length) - 1;
                                C ? p = w.move(E[i][0], E[i][1]) + t : A ? p = w.move(P[i][0], P[i][1]) + w.line(E[i][0], E[i][1]) + t + w.line(P[e][0], P[e][1]) : (p = w.move(E[i][0], E[i][1]) + t, f = p + w.line(E[e][0], k) + w.line(E[i][0], k) + "z", m.push(f)), x.push(p)
                            }), A && 1 < _ && !C && (T = x.slice(_).reverse(), x.splice(_), T.forEach(function (e) {
                                return x.push(e)
                            })), u = 0
                    }
                    break;
                case"smooth":
                    var I = .35 * (n - h);
                    if (null === i[s][a]) u = 0; else switch (u) {
                        case 0:
                            if (g = h, p = C ? w.move(h, c[a]) + w.line(h, d) : w.move(h, d), f = w.move(h, d), u = 1, a < i[s].length - 2) {
                                var O = w.curve(h + I, d, n - I, r, n, r);
                                p += O, f += O;
                                break
                            }
                        case 1:
                            null === i[s][a + 1] ? (p += C ? w.line(h, l) : w.move(h, d), f += w.line(h, k) + w.line(g, k) + "z", x.push(p), m.push(f), u = -1) : (O = w.curve(h + I, d, n - I, r, n, r), p += O, f += O, a >= i[s].length - 2 && (C && (p += w.curve(n, r, n, r, n, l) + w.move(n, l)), f += w.curve(n, r, n, r, n, k) + w.line(g, k) + "z", x.push(p), m.push(f), u = -1))
                    }
                    h = n, d = r;
                    break;
                default:
                    var D = function (e, t, i) {
                        var s = [];
                        switch (e) {
                            case"stepline":
                                s = w.line(t, null, "H") + w.line(null, i, "V");
                                break;
                            case"linestep":
                                s = w.line(null, i, "V") + w.line(t, null, "H");
                                break;
                            case"straight":
                                s = w.line(t, i)
                        }
                        return s
                    };
                    if (null === i[s][a]) u = 0; else switch (u) {
                        case 0:
                            if (g = h, p = C ? w.move(h, c[a]) + w.line(h, d) : w.move(h, d), f = w.move(h, d), u = 1, a < i[s].length - 2) {
                                var z = D(b, n, r);
                                p += z, f += z;
                                break
                            }
                        case 1:
                            null === i[s][a + 1] ? (p += C ? w.line(h, l) : w.move(h, d), f += w.line(h, k) + w.line(g, k) + "z", x.push(p), m.push(f), u = -1) : (z = D(b, n, r), p += z, f += z, a >= i[s].length - 2 && (C && (p += w.line(n, l)), f += w.line(n, k) + w.line(g, k) + "z", x.push(p), m.push(f), u = -1))
                    }
                    h = n, d = r
            }
            return {linePaths: x, areaPaths: m, pX: h, pY: d, pathState: u, segmentStartX: g, linePath: p, areaPath: f}
        }
    }, {
        key: "handleNullDataPoints", value: function (e, t, i, s, a) {
            var n = this.w;
            (null === e[i][s] && n.config.markers.showNullDataPoints || 1 === e[i].length) && (e = this.strokeWidth - n.config.markers.strokeWidth / 2, null !== (i = this.markers.plotChartMarkers(t, a, s + 1, e = 0 < e ? e : 0, !0))) && this.elPointsMain.add(i)
        }
    }]);
    var ii = si;

    function si(e, t, i) {
        s(this, si), this.ctx = e, this.w = e.w, this.xyRatios = t, this.pointsChart = !("bubble" !== this.w.config.chart.type && "scatter" !== this.w.config.chart.type) || i, this.scatter = new be(this.ctx), this.noNegatives = this.w.globals.minX === Number.MAX_VALUE, this.lineHelpers = new nt(this), this.markers = new k(this.ctx), this.prevSeriesY = [], this.categoryAxisCorrection = 0, this.yaxisIndex = 0
    }

    function ai(e, t, i, s) {
        this.xoffset = e, this.yoffset = t, this.height = s, this.width = i, this.shortestEdge = function () {
            return Math.min(this.height, this.width)
        }, this.getCoordinates = function (e) {
            var t, i = [], s = this.xoffset, a = this.yoffset, n = m(e) / this.height, r = m(e) / this.width;
            if (this.width >= this.height) for (t = 0; t < e.length; t++) i.push([s, a, s + n, a + e[t] / n]), a += e[t] / n; else for (t = 0; t < e.length; t++) i.push([s, a, s + e[t] / r, a + r]), s += e[t] / r;
            return i
        }, this.cutArea = function (e) {
            var t, i;
            return this.width >= this.height ? (t = e / this.height, i = this.width - t, new ai(this.xoffset + t, this.yoffset, i, this.height)) : (t = e / this.width, i = this.height - t, new ai(this.xoffset, this.yoffset + t, this.width, i))
        }
    }

    function ni(e, a, n, t, i) {
        t = void 0 === t ? 0 : t, i = void 0 === i ? 0 : i;
        for (var s, r = function e(t, i, s, a) {
            var n, r;
            if (0 !== t.length) return r = s.shortestEdge(), ((e, t, i) => {
                var s;
                return 0 === e.length || ((s = e.slice()).push(t), t = ri(e, i), (e = ri(s, i)) <= t)
            })(i, n = t[0], r) ? (i.push(n), e(t.slice(1), i, s, a)) : (r = s.cutArea(m(i), a), a.push(s.getCoordinates(i)), e(t, [], r, a)), a;
            a.push(s.getCoordinates(i))
        }((e => {
            for (var t = [], i = a * n / m(e), s = 0; s < e.length; s++) t[s] = e[s] * i;
            return t
        })(e), [], new ai(t, i, a, n), []), o = [], l = 0; l < r.length; l++) for (s = 0; s < r[l].length; s++) o.push(r[l][s]);
        return o
    }

    function ri(e, t) {
        var i = Math.min.apply(Math, e), s = Math.max.apply(Math, e), e = m(e);
        return Math.max(Math.pow(t, 2) * s / Math.pow(e, 2), Math.pow(e, 2) / (Math.pow(t, 2) * i))
    }

    function oi(e) {
        return e && e.constructor === Array
    }

    function m(e) {
        for (var t = 0, i = 0; i < e.length; i++) t += e[i];
        return t
    }

    window.TreemapSquared = {}, window.TreemapSquared.generate = function e(t, i, s, a, n) {
        a = void 0 === a ? 0 : a, n = void 0 === n ? 0 : n;
        var r, o, l = [], c = [];
        if (oi(t[0])) {
            for (o = 0; o < t.length; o++) l[o] = function e(t) {
                var i, s = 0;
                if (oi(t[0])) for (i = 0; i < t.length; i++) s += e(t[i]); else s = m(t);
                return s
            }(t[o]);
            for (r = ni(l, i, s, a, n), o = 0; o < t.length; o++) c.push(e(t[o], r[o][2] - r[o][0], r[o][3] - r[o][1], r[o][0], r[o][1]))
        } else c = ni(t, i, s, a, n);
        return c
    };
    e(fi, [{
        key: "draw", value: function (g) {
            var t, p = this, f = this.w, x = new Y(this.ctx), m = new S(this.ctx),
                i = x.group({class: "apexcharts-treemap"});
            return f.globals.noData || (t = [], g.forEach(function (e) {
                e = e.map(function (e) {
                    return Math.abs(e)
                });
                t.push(e)
            }), this.negRange = this.helpers.checkColorRange(), f.config.series.forEach(function (e, t) {
                e.data.forEach(function (e) {
                    Array.isArray(p.labels[t]) || (p.labels[t] = []), p.labels[t].push(e.x)
                })
            }), window.TreemapSquared.generate(t, f.globals.gridWidth, f.globals.gridHeight).forEach(function (e, d) {
                var u = x.group({
                        class: "apexcharts-series apexcharts-treemap-series",
                        seriesName: R.escapeString(f.globals.seriesNames[d]),
                        rel: d + 1,
                        "data:realIndex": d
                    }),
                    t = (f.config.chart.dropShadow.enabled && (t = f.config.chart.dropShadow, new P(p.ctx).dropShadow(i, t, d)), x.group({class: "apexcharts-data-labels"}));
                e.forEach(function (e, t) {
                    var i = e[0], s = e[1], a = e[2], n = e[3],
                        r = x.drawRect(i, s, a - i, n - s, f.config.plotOptions.treemap.borderRadius, "#fff", 1, p.strokeWidth, f.config.plotOptions.treemap.useFillColorAsStroke ? l : f.globals.stroke.colors[d]),
                        o = (r.attr({
                            cx: i,
                            cy: s,
                            index: d,
                            i: d,
                            j: t,
                            width: a - i,
                            height: n - s
                        }), p.helpers.getShadeColor(f.config.chart.type, d, t, p.negRange)), l = o.color,
                        l = (void 0 !== f.config.series[d].data[t] && f.config.series[d].data[t].fillColor && (l = f.config.series[d].data[t].fillColor), m.fillPath({
                            color: l,
                            seriesNumber: d,
                            dataPointIndex: t
                        })),
                        l = (r.node.classList.add("apexcharts-treemap-rect"), r.attr({fill: l}), p.helpers.addListeners(r), {
                            x: i + (a - i) / 2,
                            y: s + (n - s) / 2,
                            width: 0,
                            height: 0
                        }), c = {x: i, y: s, width: a - i, height: n - s},
                        l = (f.config.chart.animations.enabled && !f.globals.dataChanged && (h = 1, f.globals.resized || (h = f.config.chart.animations.speed), p.animateTreemap(r, l, c, h)), f.globals.dataChanged && (h = 1, p.dynamicAnim.enabled) && f.globals.shouldAnimate && (h = p.dynamicAnim.speed, f.globals.previousPaths[d] && f.globals.previousPaths[d][t] && f.globals.previousPaths[d][t].rect && (l = f.globals.previousPaths[d][t].rect), p.animateTreemap(r, l, c, h)), p.getFontSize(e)),
                        c = f.config.dataLabels.formatter(p.labels[d][t], {
                            value: f.globals.series[d][t],
                            seriesIndex: d,
                            dataPointIndex: t,
                            w: f
                        }),
                        h = ("truncate" === f.config.plotOptions.treemap.dataLabels.format && (l = parseInt(f.config.dataLabels.style.fontSize, 10), c = p.truncateLabels(c, l, i, s, a, n)), null);
                    f.globals.series[d][t] && (h = p.helpers.calculateDataLabels({
                        text: c,
                        x: (i + a) / 2,
                        y: (s + n) / 2 + p.strokeWidth / 2 + l / 3,
                        i: d,
                        j: t,
                        colorProps: o,
                        fontSize: l,
                        series: g
                    })), f.config.dataLabels.enabled && h && p.rotateToFitLabel(h, l, c, i, s, a, n), u.add(r), null !== h && u.add(h)
                }), u.add(t), i.add(u)
            })), i
        }
    }, {
        key: "getFontSize", value: function (e) {
            var t = this.w, i = function e(t) {
                var i, s = 0;
                if (Array.isArray(t[0])) for (i = 0; i < t.length; i++) s += e(t[i]); else for (i = 0; i < t.length; i++) s += t[i].length;
                return s
            }(this.labels) / function e(t) {
                var i, s = 0;
                if (Array.isArray(t[0])) for (i = 0; i < t.length; i++) s += e(t[i]); else for (i = 0; i < t.length; i++) s += 1;
                return s
            }(this.labels), s = e[2] - e[0], s = Math.pow(s * (e[3] - e[1]), .5);
            return Math.min(s / i, parseInt(t.config.dataLabels.style.fontSize, 10))
        }
    }, {
        key: "rotateToFitLabel", value: function (e, t, i, s, a, n, r) {
            var o = new Y(this.ctx), i = o.getTextRects(i, t);
            i.width + this.w.config.stroke.width + 5 > n - s && i.width <= r - a && (t = o.rotateAroundCenter(e.node), e.node.setAttribute("transform", "rotate(-90 ".concat(t.x, " ").concat(t.y, ") translate(").concat(i.height / 3, ")")))
        }
    }, {
        key: "truncateLabels", value: function (e, t, i, s, a, n) {
            var r = new Y(this.ctx),
                n = r.getTextRects(e, t).width + this.w.config.stroke.width + 5 > a - i && a - i < n - s ? n - s : a - i,
                s = r.getTextBasedOnMaxWidth({text: e, maxWidth: n, fontSize: t});
            return e.length !== s.length && n / t < 5 ? "" : s
        }
    }, {
        key: "animateTreemap", value: function (e, t, i, s) {
            var a = new A(this.ctx);
            a.animateRect(e, {x: t.x, y: t.y, width: t.width, height: t.height}, {
                x: i.x,
                y: i.y,
                width: i.width,
                height: i.height
            }, s, function () {
                a.animationCompleted(e)
            })
        }
    }]);
    var b, E, li = fi, ci = (e(pi, [{
        key: "calculateTimeScaleTicks", value: function (e, t) {
            var r = this, o = this.w;
            if (o.globals.allSeriesCollapsed) return o.globals.labels = [], o.globals.timescaleLabels = [], [];
            var i = new y(this.ctx), s = (t - e) / 864e5,
                i = (this.determineInterval(s), o.globals.disableZoomIn = !1, o.globals.disableZoomOut = !1, s < 10 / 86400 ? o.globals.disableZoomIn = !0 : 5e4 < s && (o.globals.disableZoomOut = !0), i.getTimeUnitsfromTimestamp(e, t, this.utc)),
                e = o.globals.gridWidth / s, t = e / 24, a = t / 60, n = a / 60, l = Math.floor(24 * s),
                c = Math.floor(1440 * s), h = Math.floor(86400 * s), d = Math.floor(s), u = Math.floor(s / 30),
                s = Math.floor(s / 365), i = {
                    minMillisecond: i.minMillisecond,
                    minSecond: i.minSecond,
                    minMinute: i.minMinute,
                    minHour: i.minHour,
                    minDate: i.minDate,
                    minMonth: i.minMonth,
                    minYear: i.minYear
                }, g = {
                    firstVal: i,
                    currentMillisecond: i.minMillisecond,
                    currentSecond: i.minSecond,
                    currentMinute: i.minMinute,
                    currentHour: i.minHour,
                    currentMonthDate: i.minDate,
                    currentDate: i.minDate,
                    currentMonth: i.minMonth,
                    currentYear: i.minYear,
                    daysWidthOnXAxis: e,
                    hoursWidthOnXAxis: t,
                    minutesWidthOnXAxis: a,
                    secondsWidthOnXAxis: n,
                    numberOfSeconds: h,
                    numberOfMinutes: c,
                    numberOfHours: l,
                    numberOfDays: d,
                    numberOfMonths: u,
                    numberOfYears: s
                };
            switch (this.tickInterval) {
                case"years":
                    this.generateYearScale(g);
                    break;
                case"months":
                case"half_year":
                    this.generateMonthScale(g);
                    break;
                case"months_days":
                case"months_fortnight":
                case"days":
                case"week_days":
                    this.generateDayScale(g);
                    break;
                case"hours":
                    this.generateHourScale(g);
                    break;
                case"minutes_fives":
                case"minutes":
                    this.generateMinuteScale(g);
                    break;
                case"seconds_tens":
                case"seconds_fives":
                case"seconds":
                    this.generateSecondScale(g)
            }
            var p = this.timeScaleArray.map(function (e) {
                var t = {
                    position: e.position,
                    unit: e.unit,
                    year: e.year,
                    day: e.day || 1,
                    hour: e.hour || 0,
                    month: e.month + 1
                };
                return "month" === e.unit ? M(M({}, t), {}, {
                    day: 1,
                    value: e.value + 1
                }) : "day" === e.unit || "hour" === e.unit ? M(M({}, t), {}, {value: e.value}) : "minute" === e.unit ? M(M({}, t), {}, {
                    value: e.value,
                    minute: e.value
                }) : "second" === e.unit ? M(M({}, t), {}, {value: e.value, minute: e.minute, second: e.second}) : e
            });
            return p.filter(function (e) {
                var t = 1, i = Math.ceil(o.globals.gridWidth / 120), s = e.value,
                    a = (void 0 !== o.config.xaxis.tickAmount && (i = o.config.xaxis.tickAmount), p.length > i && (t = Math.floor(p.length / i)), !1),
                    n = !1;
                switch (r.tickInterval) {
                    case"years":
                        "year" === e.unit && (a = !0);
                        break;
                    case"half_year":
                        t = 7, "year" === e.unit && (a = !0);
                        break;
                    case"months":
                        t = 1, "year" === e.unit && (a = !0);
                        break;
                    case"months_fortnight":
                        t = 15, "year" !== e.unit && "month" !== e.unit || (a = !0), 30 === s && (n = !0);
                        break;
                    case"months_days":
                        t = 10, "month" === e.unit && (a = !0), 30 === s && (n = !0);
                        break;
                    case"week_days":
                        t = 8, "month" === e.unit && (a = !0);
                        break;
                    case"days":
                        t = 1, "month" === e.unit && (a = !0);
                        break;
                    case"hours":
                        "day" === e.unit && (a = !0);
                        break;
                    case"minutes_fives":
                    case"seconds_fives":
                        s % 5 != 0 && (n = !0);
                        break;
                    case"seconds_tens":
                        s % 10 != 0 && (n = !0)
                }
                if ("hours" === r.tickInterval || "minutes_fives" === r.tickInterval || "seconds_tens" === r.tickInterval || "seconds_fives" === r.tickInterval) {
                    if (!n) return !0
                } else if ((s % t == 0 || a) && !n) return !0
            })
        }
    }, {
        key: "recalcDimensionsBasedOnFormat", value: function (e, t) {
            var i = this.w, e = this.formatDates(e), e = this.removeOverlappingTS(e);
            i.globals.timescaleLabels = e.slice(), new Xe(this.ctx).plotCoords()
        }
    }, {
        key: "determineInterval", value: function (e) {
            var t = 24 * e, i = 60 * t;
            switch (!0) {
                case 5 < e / 365:
                    this.tickInterval = "years";
                    break;
                case 800 < e:
                    this.tickInterval = "half_year";
                    break;
                case 180 < e:
                    this.tickInterval = "months";
                    break;
                case 90 < e:
                    this.tickInterval = "months_fortnight";
                    break;
                case 60 < e:
                    this.tickInterval = "months_days";
                    break;
                case 30 < e:
                    this.tickInterval = "week_days";
                    break;
                case 2 < e:
                    this.tickInterval = "days";
                    break;
                case 2.4 < t:
                    this.tickInterval = "hours";
                    break;
                case 15 < i:
                    this.tickInterval = "minutes_fives";
                    break;
                case 5 < i:
                    this.tickInterval = "minutes";
                    break;
                case 1 < i:
                    this.tickInterval = "seconds_tens";
                    break;
                case 20 < 60 * i:
                    this.tickInterval = "seconds_fives";
                    break;
                default:
                    this.tickInterval = "seconds"
            }
        }
    }, {
        key: "generateYearScale", value: function (e) {
            var t, i = e.firstVal, s = e.currentMonth, a = e.currentYear, n = e.daysWidthOnXAxis, r = e.numberOfYears,
                e = i.minYear, o = 0, l = new y(this.ctx);
            1 < i.minDate || 0 < i.minMonth ? (t = l.determineRemainingDaysOfYear(i.minYear, i.minMonth, i.minDate), o = (l.determineDaysOfYear(i.minYear) - t + 1) * n, e = i.minYear + 1, this.timeScaleArray.push({
                position: o,
                value: e,
                unit: "year",
                year: e,
                month: R.monthMod(s + 1)
            })) : 1 === i.minDate && 0 === i.minMonth && this.timeScaleArray.push({
                position: o,
                value: e,
                unit: "year",
                year: a,
                month: R.monthMod(s + 1)
            });
            for (var c = e, h = o, d = 0; d < r; d++) h = l.determineDaysOfYear(++c - 1) * n + h, this.timeScaleArray.push({
                position: h,
                value: c,
                unit: "year",
                year: c,
                month: 1
            })
        }
    }, {
        key: "generateMonthScale", value: function (e) {
            var t, i = e.firstVal, s = e.currentMonthDate, a = e.currentMonth, n = e.currentYear,
                r = e.daysWidthOnXAxis, o = e.numberOfMonths, e = a, l = 0, c = new y(this.ctx), h = "month", d = 0;
            1 < i.minDate ? (l = (c.determineDaysOfMonths(a + 1, i.minYear) - s + 1) * r, e = R.monthMod(a + 1), i = n + d, s = R.monthMod(e), 0 === (t = e) && (h = "year", t = i, i += d += s = 1), this.timeScaleArray.push({
                position: l,
                value: t,
                unit: h,
                year: i,
                month: s
            })) : this.timeScaleArray.push({position: l, value: e, unit: h, year: n, month: R.monthMod(a)});
            for (var u = e + 1, g = l, p = 0; p < o; p++, 0) {
                0 === (u = R.monthMod(u)) ? (h = "year", d += 1) : h = "month";
                var f = this._getYear(n, u, d), g = c.determineDaysOfMonths(u, f) * r + g;
                this.timeScaleArray.push({
                    position: g,
                    value: 0 === u ? f : u,
                    unit: h,
                    year: f,
                    month: 0 === u ? 1 : u
                }), u++
            }
        }
    }, {
        key: "generateDayScale", value: function (e) {
            function t(e, t, i) {
                return e > o.determineDaysOfMonths(t + 1, i) && (l = "month", d = t += c = 1), t
            }

            var i = e.firstVal, s = e.currentMonth, a = e.currentYear, n = e.hoursWidthOnXAxis, r = e.numberOfDays,
                o = new y(this.ctx), l = "day", e = i.minDate + 1, c = e, h = (24 - i.minHour) * n, d = e,
                u = t(c, s, a);
            0 === i.minHour && 1 === i.minDate ? (h = 0, d = R.monthMod(i.minMonth), l = "month", c = i.minDate) : 1 !== i.minDate && 0 === i.minHour && 0 === i.minMinute && (h = 0, e = i.minDate, u = t(c = d = e, s, a)), this.timeScaleArray.push({
                position: h,
                value: d,
                unit: l,
                year: this._getYear(a, u, 0),
                month: R.monthMod(u),
                day: c
            });
            for (var g = h, p = 0; p < r; p++) {
                var l = "day", u = t(c += 1, u, this._getYear(a, u, 0)), f = this._getYear(a, u, 0), g = 24 * n + g,
                    x = 1 === c ? R.monthMod(u) : c;
                this.timeScaleArray.push({position: g, value: x, unit: l, year: f, month: R.monthMod(u), day: x})
            }
        }
    }, {
        key: "generateHourScale", value: function (e) {
            function t(e, t) {
                return e > c.determineDaysOfMonths(t + 1, r) && (t += p = 1), {month: t, date: p}
            }

            function i(e, t) {
                return e > c.determineDaysOfMonths(t + 1, r) ? t + 1 : t
            }

            var s = e.firstVal, a = e.currentDate, n = e.currentMonth, r = e.currentYear, o = e.minutesWidthOnXAxis,
                l = e.numberOfHours, c = new y(this.ctx), h = "hour", e = 60 - (s.minMinute + s.minSecond / 60),
                d = e * o, u = s.minHour + 1, g = u, p = (60 == e && (d = 0, g = u = s.minHour), a),
                f = (24 <= g && (g = 0, p += 1, h = "day"), t(p, n).month), f = i(p, f);
            this.timeScaleArray.push({
                position: d,
                value: u,
                unit: h,
                day: p,
                hour: g,
                year: r,
                month: R.monthMod(f)
            }), g++;
            for (var x = d, m = 0; m < l; m++) {
                h = "hour", 24 <= g && (g = 0, h = "day", f = t(p += 1, f).month, f = i(p, f));
                var b = this._getYear(r, f, 0), x = 60 * o + x, v = 0 === g ? p : g;
                this.timeScaleArray.push({
                    position: x,
                    value: v,
                    unit: h,
                    hour: g,
                    day: p,
                    year: b,
                    month: R.monthMod(f)
                }), g++
            }
        }
    }, {
        key: "generateMinuteScale", value: function (e) {
            for (var t = e.currentMillisecond, i = e.minutesWidthOnXAxis, s = e.numberOfMinutes, a = e.currentMinute + 1, n = e.currentDate, r = e.currentMonth, o = e.currentYear, l = e.currentHour, c = (60 - e.currentSecond - t / 1e3) * e.secondsWidthOnXAxis, h = 0; h < s; h++) 60 <= a && (a = 0, 24 === (l += 1)) && (l = 0), this.timeScaleArray.push({
                position: c,
                value: a,
                unit: "minute",
                hour: l,
                minute: a,
                day: n,
                year: this._getYear(o, r, 0),
                month: R.monthMod(r)
            }), c += i, a++
        }
    }, {
        key: "generateSecondScale", value: function (e) {
            for (var t = e.currentMillisecond, i = e.secondsWidthOnXAxis, s = e.numberOfSeconds, a = e.currentSecond + 1, n = e.currentMinute, r = e.currentDate, o = e.currentMonth, l = e.currentYear, c = e.currentHour, h = (1e3 - t) / 1e3 * i, d = 0; d < s; d++) 60 <= a && (a = 0, 60 <= ++n) && (n = 0, 24 == ++c) && (c = 0), this.timeScaleArray.push({
                position: h,
                value: a,
                unit: "second",
                hour: c,
                minute: n,
                second: a,
                day: r,
                year: this._getYear(l, o, 0),
                month: R.monthMod(o)
            }), h += i, a++
        }
    }, {
        key: "createRawDateString", value: function (e, t) {
            var i = e.year;
            return 0 === e.month && (e.month = 1), i += "-" + ("0" + e.month.toString()).slice(-2), "day" === e.unit ? i += "day" === e.unit ? "-" + ("0" + t).slice(-2) : "-01" : i += "-" + ("0" + (e.day || "1")).slice(-2), i = (i = (i += "hour" === e.unit ? "hour" === e.unit ? "T" + ("0" + t).slice(-2) : "T00" : "T" + ("0" + (e.hour || "0")).slice(-2)) + ("minute" === e.unit ? ":" + ("0" + t).slice(-2) : ":" + (e.minute ? ("0" + e.minute).slice(-2) : "00"))) + ("second" === e.unit ? ":" + ("0" + t).slice(-2) : ":00"), this.utc && (i += ".000Z"), i
        }
    }, {
        key: "formatDates", value: function (e) {
            var o = this, l = this.w;
            return e.map(function (e) {
                var t, i, s = e.value.toString(), a = new y(o.ctx), n = o.createRawDateString(e, s),
                    r = a.getDate(a.parseDate(n));
                return o.utc || (r = a.getDate(a.parseDateWithTimezone(n))), s = void 0 === l.config.xaxis.labels.format ? (t = "dd MMM", i = l.config.xaxis.labels.datetimeFormatter, "year" === e.unit && (t = i.year), "month" === e.unit && (t = i.month), "day" === e.unit && (t = i.day), "hour" === e.unit && (t = i.hour), "minute" === e.unit && (t = i.minute), "second" === e.unit && (t = i.second), a.formatDate(r, t)) : a.formatDate(r, l.config.xaxis.labels.format), {
                    dateString: n,
                    position: e.position,
                    value: s,
                    unit: e.unit,
                    year: e.year,
                    month: e.month
                }
            })
        }
    }, {
        key: "removeOverlappingTS", value: function (a) {
            var n, r = this, o = new Y(this.ctx), l = !1, c = (0 < a.length && a[0].value && a.every(function (e) {
                return e.value.length === a[0].value.length
            }) && (l = !0, n = o.getTextRects(a[0].value).width), 0), e = a.map(function (e, t) {
                var i, s;
                return 0 < t && r.w.config.xaxis.labels.hideOverlappingLabels ? (i = l ? n : o.getTextRects(a[c].value).width, s = a[c].position, e.position > s + i + 10 ? (c = t, e) : null) : e
            });
            return e.filter(function (e) {
                return null !== e
            })
        }
    }, {
        key: "_getYear", value: function (e, t, i) {
            return e + Math.floor(t / 12) + i
        }
    }]), pi), hi = (e(gi, [{
        key: "setupElements", value: function () {
            var e = this.w.globals, t = this.w.config, i = t.chart.type;
            e.axisCharts = -1 < ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble", "radar", "heatmap", "treemap"].indexOf(i), e.xyCharts = -1 < ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble"].indexOf(i), e.isBarHorizontal = ("bar" === t.chart.type || "rangeBar" === t.chart.type || "boxPlot" === t.chart.type) && t.plotOptions.bar.horizontal, e.chartClass = ".apexcharts" + e.chartID, e.dom.baseEl = this.el, e.dom.elWrap = document.createElement("div"), Y.setAttrs(e.dom.elWrap, {
                id: e.chartClass.substring(1),
                class: "apexcharts-canvas " + e.chartClass.substring(1)
            }), this.el.appendChild(e.dom.elWrap), e.dom.Paper = new window.SVG.Doc(e.dom.elWrap), e.dom.Paper.attr({
                class: "apexcharts-svg",
                "xmlns:data": "ApexChartsNS",
                transform: "translate(".concat(t.chart.offsetX, ", ").concat(t.chart.offsetY, ")")
            }), e.dom.Paper.node.style.background = "dark" !== t.theme.mode || t.chart.background ? "light" !== t.theme.mode || t.chart.background ? t.chart.background : "#fff" : "#424242", this.setSVGDimensions(), e.dom.elLegendForeign = document.createElementNS(e.SVGNS, "foreignObject"), Y.setAttrs(e.dom.elLegendForeign, {
                x: 0,
                y: 0,
                width: e.svgWidth,
                height: e.svgHeight
            }), e.dom.elLegendWrap = document.createElement("div"), e.dom.elLegendWrap.classList.add("apexcharts-legend"), e.dom.elLegendWrap.setAttribute("xmlns", "http://www.w3.org/1999/xhtml"), e.dom.elLegendForeign.appendChild(e.dom.elLegendWrap), e.dom.Paper.node.appendChild(e.dom.elLegendForeign), e.dom.elGraphical = e.dom.Paper.group().attr({class: "apexcharts-inner apexcharts-graphical"}), e.dom.elDefs = e.dom.Paper.defs(), e.dom.Paper.add(e.dom.elGraphical), e.dom.elGraphical.add(e.dom.elDefs)
        }
    }, {
        key: "plotChartType", value: function (s, e) {
            var a = this.w, t = a.config, n = a.globals, r = {series: [], i: []}, o = {series: [], i: []},
                l = {series: [], i: []}, c = {series: [], i: []}, h = {series: [], i: []}, d = {series: [], i: []},
                u = {series: [], i: []}, g = {series: [], i: []}, p = {series: [], seriesRangeEnd: [], i: []},
                f = void 0 !== t.chart.type ? t.chart.type : "line", x = null, m = 0,
                i = (n.series.forEach(function (e, t) {
                    var i = s[t].type || f;
                    switch (i) {
                        case"column":
                        case"bar":
                            h.series.push(e), h.i.push(t), a.globals.columnSeries = h;
                            break;
                        case"area":
                            o.series.push(e), o.i.push(t);
                            break;
                        case"line":
                            r.series.push(e), r.i.push(t);
                            break;
                        case"scatter":
                            l.series.push(e), l.i.push(t);
                            break;
                        case"bubble":
                            c.series.push(e), c.i.push(t);
                            break;
                        case"candlestick":
                            d.series.push(e), d.i.push(t);
                            break;
                        case"boxPlot":
                            u.series.push(e), u.i.push(t);
                            break;
                        case"rangeBar":
                            g.series.push(e), g.i.push(t);
                            break;
                        case"rangeArea":
                            p.series.push(n.seriesRangeStart[t]), p.seriesRangeEnd.push(n.seriesRangeEnd[t]), p.i.push(t);
                            break;
                        case"heatmap":
                        case"treemap":
                        case"pie":
                        case"donut":
                        case"polarArea":
                        case"radialBar":
                        case"radar":
                            x = i;
                            break;
                        default:
                            console.warn("You have specified an unrecognized series type (", i, ").")
                    }
                    f !== i && "scatter" !== i && m++
                }), 0 < m && (null !== x && console.warn("Chart or series type ", x, " can not appear with other chart or series types."), 0 < h.series.length) && t.plotOptions.bar.horizontal && (m -= h.length, h = {
                    series: [],
                    i: []
                }, a.globals.columnSeries = {
                    series: [],
                    i: []
                }, console.warn("Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`")), n.comboCharts || (n.comboCharts = 0 < m), new ii(this.ctx, e)),
                b = new Qe(this.ctx, e), v = (this.ctx.pie = new tt(this.ctx), new st(this.ctx)),
                y = (this.ctx.rangeBar = new at(this.ctx, e), new it(this.ctx)), w = [];
            if (n.comboCharts) {
                var k, A = new I(this.ctx);
                0 < o.series.length && w.push.apply(w, C(A.drawSeriesByGroup(o, n.areaGroups, "area", i))), 0 < h.series.length && (a.config.chart.stacked ? (k = new $e(this.ctx, e), w.push(k.draw(h.series, h.i))) : (this.ctx.bar = new _(this.ctx, e), w.push(this.ctx.bar.draw(h.series, h.i)))), 0 < p.series.length && w.push(i.draw(p.series, "rangeArea", p.i, p.seriesRangeEnd)), 0 < r.series.length && w.push.apply(w, C(A.drawSeriesByGroup(r, n.lineGroups, "line", i))), 0 < d.series.length && w.push(b.draw(d.series, "candlestick", d.i)), 0 < u.series.length && w.push(b.draw(u.series, "boxPlot", u.i)), 0 < g.series.length && w.push(this.ctx.rangeBar.draw(g.series, g.i)), 0 < l.series.length && (k = new ii(this.ctx, e, !0), w.push(k.draw(l.series, "scatter", l.i))), 0 < c.series.length && (A = new ii(this.ctx, e, !0), w.push(A.draw(c.series, "bubble", c.i)))
            } else switch (t.chart.type) {
                case"line":
                    w = i.draw(n.series, "line");
                    break;
                case"area":
                    w = i.draw(n.series, "area");
                    break;
                case"bar":
                    w = (t.chart.stacked ? new $e(this.ctx, e) : (this.ctx.bar = new _(this.ctx, e), this.ctx.bar)).draw(n.series);
                    break;
                case"candlestick":
                    w = new Qe(this.ctx, e).draw(n.series, "candlestick");
                    break;
                case"boxPlot":
                    w = new Qe(this.ctx, e).draw(n.series, t.chart.type);
                    break;
                case"rangeBar":
                    w = this.ctx.rangeBar.draw(n.series);
                    break;
                case"rangeArea":
                    w = i.draw(n.seriesRangeStart, "rangeArea", void 0, n.seriesRangeEnd);
                    break;
                case"heatmap":
                    w = new Je(this.ctx, e).draw(n.series);
                    break;
                case"treemap":
                    w = new li(this.ctx, e).draw(n.series);
                    break;
                case"pie":
                case"donut":
                case"polarArea":
                    w = this.ctx.pie.draw(n.series);
                    break;
                case"radialBar":
                    w = v.draw(n.series);
                    break;
                case"radar":
                    w = y.draw(n.series);
                    break;
                default:
                    w = i.draw(n.series)
            }
            return w
        }
    }, {
        key: "setSVGDimensions", value: function () {
            var e = this.w.globals, t = this.w.config,
                i = (t.chart.width || (t.chart.width = "100%"), t.chart.height || (t.chart.height = "auto"), e.svgWidth = t.chart.width, e.svgHeight = t.chart.height, R.getDimensions(this.el)),
                s = t.chart.width.toString().split(/[0-9]+/g).pop(),
                i = ("%" === s ? R.isNumber(i[0]) && (0 === i[0].width && (i = R.getDimensions(this.el.parentNode)), e.svgWidth = i[0] * parseInt(t.chart.width, 10) / 100) : "px" !== s && "" !== s || (e.svgWidth = parseInt(t.chart.width, 10)), String(t.chart.height).toString().split(/[0-9]+/g).pop());
            "auto" !== e.svgHeight && "" !== e.svgHeight ? "%" === i ? (s = R.getDimensions(this.el.parentNode), e.svgHeight = s[1] * parseInt(t.chart.height, 10) / 100) : e.svgHeight = parseInt(t.chart.height, 10) : e.axisCharts ? e.svgHeight = e.svgWidth / 1.61 : e.svgHeight = e.svgWidth / 1.2, e.svgWidth < 0 && (e.svgWidth = 0), e.svgHeight < 0 && (e.svgHeight = 0), Y.setAttrs(e.dom.Paper.node, {
                width: e.svgWidth,
                height: e.svgHeight
            }), "%" !== i && (s = !t.chart.sparkline.enabled && e.axisCharts ? t.chart.parentHeightOffset : 0, e.dom.Paper.node.parentNode.parentNode.style.minHeight = e.svgHeight + s + "px"), e.dom.elWrap.style.width = e.svgWidth + "px", e.dom.elWrap.style.height = e.svgHeight + "px"
        }
    }, {
        key: "shiftGraphPosition", value: function () {
            var e = this.w.globals, t = e.translateY;
            Y.setAttrs(e.dom.elGraphical.node, {transform: "translate(" + e.translateX + ", " + t + ")"})
        }
    }, {
        key: "resizeNonAxisCharts", value: function () {
            var e = this.w, t = e.globals, i = 0, s = e.config.chart.sparkline.enabled ? 1 : 15,
                a = (s += e.config.grid.padding.bottom, "top" !== e.config.legend.position && "bottom" !== e.config.legend.position || !e.config.legend.show || e.config.legend.floating || (i = new Fe(this.ctx).legendHelpers.getLegendDimensions().clwh + 10), e.globals.dom.baseEl.querySelector(".apexcharts-radialbar, .apexcharts-pie")),
                n = 2.05 * e.globals.radialSize,
                a = (a && !e.config.chart.sparkline.enabled && 0 !== e.config.plotOptions.radialBar.startAngle && (n = (a = R.getBoundingClientRect(a)).bottom, n = Math.max(2.05 * e.globals.radialSize, a.bottom - a.top)), n + t.translateY + i + s);
            t.dom.elLegendForeign && t.dom.elLegendForeign.setAttribute("height", a), e.config.chart.height && 0 < String(e.config.chart.height).indexOf("%") || (t.dom.elWrap.style.height = a + "px", Y.setAttrs(t.dom.Paper.node, {height: a}), t.dom.Paper.node.parentNode.parentNode.style.minHeight = a + "px")
        }
    }, {
        key: "coreCalculations", value: function () {
            new Ae(this.ctx).init()
        }
    }, {
        key: "resetGlobals", value: function () {
            function e() {
                return t.w.config.series.map(function (e) {
                    return []
                })
            }

            var t = this, i = new xe, s = this.w.globals;
            i.initGlobalVars(s), s.seriesXvalues = e(), s.seriesYvalues = e()
        }
    }, {
        key: "isMultipleY", value: function () {
            if (this.w.config.yaxis.constructor === Array && 1 < this.w.config.yaxis.length) return this.w.globals.isMultipleYAxis = !0
        }
    }, {
        key: "xySettings", value: function () {
            var e, t = null, i = this.w;
            return i.globals.axisCharts && ("back" === i.config.xaxis.crosshairs.position && new Ee(this.ctx).drawXCrosshairs(), "back" === i.config.yaxis[0].crosshairs.position && new Ee(this.ctx).drawYCrosshairs(), "datetime" === i.config.xaxis.type && void 0 === i.config.xaxis.labels.formatter && (this.ctx.timeScale = new ci(this.ctx), e = [], isFinite(i.globals.minX) && isFinite(i.globals.maxX) && !i.globals.isBarHorizontal ? e = this.ctx.timeScale.calculateTimeScaleTicks(i.globals.minX, i.globals.maxX) : i.globals.isBarHorizontal && (e = this.ctx.timeScale.calculateTimeScaleTicks(i.globals.minY, i.globals.maxY)), this.ctx.timeScale.recalcDimensionsBasedOnFormat(e)), t = new I(this.ctx).getCalculatedRatios()), t
        }
    }, {
        key: "updateSourceChart", value: function (e) {
            this.ctx.w.globals.selection = void 0, this.ctx.updateHelpers._updateOptions({
                chart: {
                    selection: {
                        xaxis: {
                            min: e.w.globals.minX,
                            max: e.w.globals.maxX
                        }
                    }
                }
            }, !1, !1)
        }
    }, {
        key: "setupBrushHandler", value: function () {
            var i, s = this, e = this.w;
            e.config.chart.brush.enabled && "function" != typeof e.config.chart.events.selection && ((i = Array.isArray(e.config.chart.brush.targets) ? e.config.chart.brush.targets : [e.config.chart.brush.target]).forEach(function (e) {
                var t = ApexCharts.getChartByID(e);
                t.w.globals.brushSource = s.ctx, "function" != typeof t.w.config.chart.events.zoomed && (t.w.config.chart.events.zoomed = function () {
                    s.updateSourceChart(t)
                }), "function" != typeof t.w.config.chart.events.scrolled && (t.w.config.chart.events.scrolled = function () {
                    s.updateSourceChart(t)
                })
            }), e.config.chart.events.selection = function (e, t) {
                i.forEach(function (e) {
                    ApexCharts.getChartByID(e).ctx.updateHelpers._updateOptions({
                        xaxis: {
                            min: t.xaxis.min,
                            max: t.xaxis.max
                        }
                    }, !1, !1, !1, !1)
                })
            })
        }
    }]), gi), di = (e(ui, [{
        key: "_updateOptions", value: function (c) {
            var h = this, d = 1 < arguments.length && void 0 !== arguments[1] && arguments[1],
                u = !(2 < arguments.length && void 0 !== arguments[2]) || arguments[2],
                e = !(3 < arguments.length && void 0 !== arguments[3]) || arguments[3],
                g = 4 < arguments.length && void 0 !== arguments[4] && arguments[4];
            return new Promise(function (o) {
                var l = [h.ctx];
                e && (l = h.ctx.getSyncedCharts()), h.ctx.w.globals.isExecCalled && (l = [h.ctx], h.ctx.w.globals.isExecCalled = !1), l.forEach(function (e, t) {
                    var i = e.w;
                    if (i.globals.shouldAnimate = u, d || (i.globals.resized = !0, i.globals.dataChanged = !0, u && e.series.getPreviousPaths()), c && "object" === v(c) && (e.config = new p(c), c = I.extendArrayProps(e.config, c, i), e.w.globals.chartID !== h.ctx.w.globals.chartID && delete c.series, i.config = R.extend(i.config, c), g) && (i.globals.lastXAxis = c.xaxis ? R.clone(c.xaxis) : [], i.globals.lastYAxis = c.yaxis ? R.clone(c.yaxis) : [], i.globals.initialConfig = R.extend({}, i.config), i.globals.initialSeries = R.clone(i.config.series), c.series)) {
                        for (var s = 0; s < i.globals.collapsedSeriesIndices.length; s++) {
                            var a = i.config.series[i.globals.collapsedSeriesIndices[s]];
                            i.globals.collapsedSeries[s].data = i.globals.axisCharts ? a.data.slice() : a
                        }
                        for (var n = 0; n < i.globals.ancillaryCollapsedSeriesIndices.length; n++) {
                            var r = i.config.series[i.globals.ancillaryCollapsedSeriesIndices[n]];
                            i.globals.ancillaryCollapsedSeries[n].data = i.globals.axisCharts ? r.data.slice() : r
                        }
                        e.series.emptyCollapsedSeries(i.config.series)
                    }
                    return e.update(c).then(function () {
                        t === l.length - 1 && o(e)
                    })
                })
            })
        }
    }, {
        key: "_updateSeries", value: function (s, a) {
            var n = this, r = 2 < arguments.length && void 0 !== arguments[2] && arguments[2];
            return new Promise(function (e) {
                var t, i = n.w;
                return i.globals.shouldAnimate = a, i.globals.dataChanged = !0, a && n.ctx.series.getPreviousPaths(), i.globals.axisCharts ? (0 === (t = s.map(function (e, t) {
                    return n._extendSeries(e, t)
                })).length && (t = [{data: []}]), i.config.series = t) : i.config.series = s.slice(), r && (i.globals.initialConfig.series = R.clone(i.config.series), i.globals.initialSeries = R.clone(i.config.series)), n.ctx.update().then(function () {
                    e(n.ctx)
                })
            })
        }
    }, {
        key: "_extendSeries", value: function (e, t) {
            var i = this.w, s = i.config.series[t];
            return M(M({}, i.config.series[t]), {}, {
                name: e.name || (null == s ? void 0 : s.name),
                color: e.color || (null == s ? void 0 : s.color),
                type: e.type || (null == s ? void 0 : s.type),
                group: e.group || (null == s ? void 0 : s.group),
                hidden: void 0 !== e.hidden ? e.hidden : null == s ? void 0 : s.hidden,
                data: e.data || (null == s ? void 0 : s.data),
                zIndex: void 0 !== e.zIndex ? e.zIndex : t
            })
        }
    }, {
        key: "toggleDataPointSelection", value: function (e, t) {
            var i = this.w, s = null, a = ".apexcharts-series[data\\:realIndex='".concat(e, "']");
            return i.globals.axisCharts ? s = i.globals.dom.Paper.select("".concat(a, " path[j='").concat(t, "'], ").concat(a, " circle[j='").concat(t, "'], ").concat(a, " rect[j='").concat(t, "']")).members[0] : void 0 === t && (s = i.globals.dom.Paper.select("".concat(a, " path[j='").concat(e, "']")).members[0], "pie" !== i.config.chart.type && "polarArea" !== i.config.chart.type && "donut" !== i.config.chart.type || this.ctx.pie.pieClicked(e)), s ? (new Y(this.ctx).pathMouseDown(s, null), s.node || null) : (console.warn("toggleDataPointSelection: Element not found"), null)
        }
    }, {
        key: "forceXAxisUpdate", value: function (t) {
            var e, i = this.w;
            return ["min", "max"].forEach(function (e) {
                void 0 !== t.xaxis[e] && (i.config.xaxis[e] = t.xaxis[e], i.globals.lastXAxis[e] = t.xaxis[e])
            }), t.xaxis.categories && t.xaxis.categories.length && (i.config.xaxis.categories = t.xaxis.categories), i.config.xaxis.convertedCatToNumeric && (e = new o(t), t = e.convertCatToNumericXaxis(t, this.ctx)), t
        }
    }, {
        key: "forceYAxisUpdate", value: function (i) {
            return i.chart && i.chart.stacked && "100%" === i.chart.stackType && (Array.isArray(i.yaxis) ? i.yaxis.forEach(function (e, t) {
                i.yaxis[t].min = 0, i.yaxis[t].max = 100
            }) : (i.yaxis.min = 0, i.yaxis.max = 100)), i
        }
    }, {
        key: "revertDefaultAxisMinMax", value: function (e) {
            var s = this, a = this.w, t = a.globals.lastXAxis, n = a.globals.lastYAxis;
            e && e.xaxis && (t = e.xaxis), e && e.yaxis && (n = e.yaxis), a.config.xaxis.min = t.min, a.config.xaxis.max = t.max;
            a.config.yaxis.map(function (e, t) {
                var i;
                a.globals.zoomed || void 0 !== n[t] ? void 0 !== n[i = t] && (a.config.yaxis[i].min = n[i].min, a.config.yaxis[i].max = n[i].max) : void 0 !== s.ctx.opts.yaxis[t] && (e.min = s.ctx.opts.yaxis[t].min, e.max = s.ctx.opts.yaxis[t].max)
            })
        }
    }]), ui);

    function ui(e) {
        s(this, ui), this.ctx = e, this.w = e.w
    }

    function gi(e, t) {
        s(this, gi), this.ctx = t, this.w = t.w, this.el = e
    }

    function pi(e) {
        s(this, pi), this.ctx = e, this.w = e.w, this.timeScaleArray = [], this.utc = this.w.config.xaxis.labels.datetimeUTC
    }

    function fi(e, t) {
        s(this, fi), this.ctx = e, this.w = e.w, this.strokeWidth = this.w.config.stroke.width, this.helpers = new Ke(e), this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.labels = []
    }

    function O(e) {
        (this.el = e).remember("_selectHandler", this), this.pointSelection = {isSelected: !1}, this.rectSelection = {isSelected: !1}, this.pointsList = {
            lt: [0, 0],
            rt: ["width", 0],
            rb: ["width", "height"],
            lb: [0, "height"],
            t: ["width", 0],
            r: ["width", "height"],
            b: ["width", "height"],
            l: [0, "height"]
        }, this.pointCoord = function (e, t, i) {
            t = "string" != typeof e ? e : t[e];
            return i ? t / 2 : t
        }, this.pointCoords = function (e, t) {
            var i = this.pointsList[e];
            return {
                x: this.pointCoord(i[0], t, "t" === e || "b" === e),
                y: this.pointCoord(i[1], t, "r" === e || "l" === e)
            }
        }
    }

    function xi(e) {
        switch (e[0]) {
            case"z":
            case"Z":
                e[0] = "L", e[1] = this.start[0], e[2] = this.start[1];
                break;
            case"H":
                e[0] = "L", e[2] = this.pos[1];
                break;
            case"V":
                e[0] = "L", e[2] = e[1], e[1] = this.pos[0];
                break;
            case"T":
                e[0] = "Q", e[3] = e[1], e[4] = e[2], e[1] = this.reflection[1], e[2] = this.reflection[0];
                break;
            case"S":
                e[0] = "C", e[6] = e[4], e[5] = e[3], e[4] = e[2], e[3] = e[1], e[2] = this.reflection[1], e[1] = this.reflection[0]
        }
        return e
    }

    function mi(e) {
        var t = e.length;
        return this.pos = [e[t - 2], e[t - 1]], -1 != "SCQT".indexOf(e[0]) && (this.reflection = [2 * this.pos[0] - e[t - 4], 2 * this.pos[1] - e[t - 3]]), e
    }

    function bi(e) {
        var t = [e];
        switch (e[0]) {
            case"M":
                return this.pos = this.start = [e[1], e[2]], t;
            case"L":
                e[5] = e[3] = e[1], e[6] = e[4] = e[2], e[1] = this.pos[0], e[2] = this.pos[1];
                break;
            case"Q":
                e[6] = e[4], e[5] = e[3], e[4] = +e[4] / 3 + 2 * e[2] / 3, e[3] = +e[3] / 3 + 2 * e[1] / 3, e[2] = +this.pos[1] / 3 + 2 * e[2] / 3, e[1] = +this.pos[0] / 3 + 2 * e[1] / 3;
                break;
            case"A":
                e = (t = ((e, t) => {
                    var i, s, a, n, r, o, l, c, h, d, u, g, p, f, x, m, b, v, y, w = Math.abs(t[1]), k = Math.abs(t[2]),
                        A = t[3] % 360, C = t[4], S = t[5], L = t[6], t = t[7], e = new SVG.Point(e),
                        t = new SVG.Point(L, t), T = [];
                    if (0 === w || 0 === k || e.x === t.x && e.y === t.y) return [["C", e.x, e.y, t.x, t.y, t.x, t.y]];
                    for (1 < (r = (r = new SVG.Point((e.x - t.x) / 2, (e.y - t.y) / 2).transform((new SVG.Matrix).rotate(A))).x * r.x / (w * w) + r.y * r.y / (k * k)) && (w *= r = Math.sqrt(r), k *= r), i = (new SVG.Matrix).rotate(A).scale(1 / w, 1 / k).rotate(-A), e = e.transform(i), a = (r = [(t = t.transform(i)).x - e.x, t.y - e.y])[0] * r[0] + r[1] * r[1], n = Math.sqrt(a), r[0] /= n, r[1] /= n, n = a < 4 ? Math.sqrt(1 - a / 4) : 0, C === S && (n *= -1), s = new SVG.Point((t.x + e.x) / 2 + n * -r[1], (t.y + e.y) / 2 + n * r[0]), a = new SVG.Point(e.x - s.x, e.y - s.y), C = new SVG.Point(t.x - s.x, t.y - s.y), n = Math.acos(a.x / Math.sqrt(a.x * a.x + a.y * a.y)), a.y < 0 && (n *= -1), r = Math.acos(C.x / Math.sqrt(C.x * C.x + C.y * C.y)), C.y < 0 && (r *= -1), S && r < n && (r += 2 * Math.PI), !S && n < r && (r -= 2 * Math.PI), h = [], o = (r - (d = n)) / (l = Math.ceil(2 * Math.abs(n - r) / Math.PI)), c = 4 * Math.tan(o / 4) / 3, f = 0; f <= l; f++) g = Math.cos(d), u = Math.sin(d), p = new SVG.Point(s.x + g, s.y + u), h[f] = [new SVG.Point(p.x + c * u, p.y - c * g), p, new SVG.Point(p.x - c * u, p.y + c * g)], d += o;
                    for (h[0][0] = h[0][1].clone(), h[h.length - 1][2] = h[h.length - 1][1].clone(), i = (new SVG.Matrix).rotate(A).scale(w, k).rotate(-A), f = 0, x = h.length; f < x; f++) h[f][0] = h[f][0].transform(i), h[f][1] = h[f][1].transform(i), h[f][2] = h[f][2].transform(i);
                    for (f = 1, x = h.length; f < x; f++) m = (p = h[f - 1][2]).x, b = p.y, v = (p = h[f][0]).x, y = p.y, L = (p = h[f][1]).x, T.push(["C", m, b, v, y, L, p.y]);
                    return T
                })(this.pos, e))[0]
        }
        return e[0] = "C", this.pos = [e[5], e[6]], this.reflection = [2 * e[5] - e[3], 2 * e[6] - e[4]], t
    }

    function vi(e, t) {
        if (!1 !== t) for (var i = t, s = e.length; i < s; ++i) if ("M" == e[i][0]) return i;
        return !1
    }

    b = void 0 !== window ? window : void 0, E = function (a, n) {
        var c = (void 0 !== this ? this : a).SVG = function (e) {
            if (c.supported) return e = new c.Doc(e), c.parser.draw || c.prepare(), e
        };
        if (c.ns = "http://www.w3.org/2000/svg", c.xmlns = "http://www.w3.org/2000/xmlns/", c.xlink = "http://www.w3.org/1999/xlink", c.svgjs = "http://svgjs.dev", c.supported = !0, !c.supported) return !1;
        c.did = 1e3, c.eid = function (e) {
            return "Svgjs" + o(e) + c.did++
        }, c.create = function (e) {
            var t = n.createElementNS(this.ns, e);
            return t.setAttribute("id", this.eid(e)), t
        }, c.extend = function () {
            for (var e, t = (e = [].slice.call(arguments)).pop(), i = e.length - 1; 0 <= i; i--) if (e[i]) for (var s in t) e[i].prototype[s] = t[s];
            c.Set && c.Set.inherit && c.Set.inherit()
        }, c.invent = function (e) {
            var t = "function" == typeof e.create ? e.create : function () {
                this.constructor.call(this, c.create(e.create))
            };
            return e.inherit && (t.prototype = new e.inherit), e.extend && c.extend(t, e.extend), e.construct && c.extend(e.parent || c.Container, e.construct), t
        }, c.adopt = function (e) {
            return e ? e.instance || ((t = "svg" == e.nodeName ? new (e.parentNode instanceof a.SVGElement ? c.Nested : c.Doc) : "linearGradient" == e.nodeName ? new c.Gradient("linear") : "radialGradient" == e.nodeName ? new c.Gradient("radial") : c[o(e.nodeName)] ? new c[o(e.nodeName)] : new c.Element(e)).type = e.nodeName, ((t.node = e).instance = t) instanceof c.Doc && t.namespace().defs(), t.setData(JSON.parse(e.getAttribute("svgjs:data")) || {}), t) : null;
            var t
        }, c.prepare = function () {
            var e = n.getElementsByTagName("body")[0],
                t = (e ? new c.Doc(e) : c.adopt(n.documentElement).nested()).size(2, 0);
            c.parser = {
                body: e || n.documentElement,
                draw: t.style("opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden").node,
                poly: t.polyline().node,
                path: t.path().node,
                native: c.create("svg")
            }
        }, c.parser = {native: c.create("svg")}, n.addEventListener("DOMContentLoaded", function () {
            c.parser.draw || c.prepare()
        }, !1), c.regex = {
            numberAndUnit: /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i,
            hex: /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,
            rgb: /rgb\((\d+),(\d+),(\d+)\)/,
            reference: /#([a-z0-9\-_]+)/i,
            transforms: /\)\s*,?\s*/,
            whitespace: /\s/g,
            isHex: /^#[a-f0-9]{3,6}$/i,
            isRgb: /^rgb\(/,
            isCss: /[^:]+:[^;]+;?/,
            isBlank: /^(\s+)?$/,
            isNumber: /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
            isPercent: /^-?[\d\.]+%$/,
            isImage: /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i,
            delimiter: /[\s,]+/,
            hyphen: /([^e])\-/gi,
            pathLetters: /[MLHVCSQTAZ]/gi,
            isPathLetter: /[MLHVCSQTAZ]/i,
            numbersWithDots: /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi,
            dots: /\./g
        }, c.utils = {
            map: function (e, t) {
                for (var i = e.length, s = [], a = 0; a < i; a++) s.push(t(e[a]));
                return s
            }, filter: function (e, t) {
                for (var i = e.length, s = [], a = 0; a < i; a++) t(e[a]) && s.push(e[a]);
                return s
            }, filterSVGElements: function (e) {
                return this.filter(e, function (e) {
                    return e instanceof a.SVGElement
                })
            }
        }, c.defaults = {
            attrs: {
                "fill-opacity": 1,
                "stroke-opacity": 1,
                "stroke-width": 0,
                "stroke-linejoin": "miter",
                "stroke-linecap": "butt",
                fill: "#000000",
                stroke: "#000000",
                opacity: 1,
                x: 0,
                y: 0,
                cx: 0,
                cy: 0,
                width: 0,
                height: 0,
                r: 0,
                rx: 0,
                ry: 0,
                offset: 0,
                "stop-opacity": 1,
                "stop-color": "#000000",
                "font-size": 16,
                "font-family": "Helvetica, Arial, sans-serif",
                "text-anchor": "start"
            }
        }, c.Color = function (e) {
            var t, i;
            this.r = 0, this.g = 0, this.b = 0, e && ("string" == typeof e ? c.regex.isRgb.test(e) ? (t = c.regex.rgb.exec(e.replace(c.regex.whitespace, "")), this.r = parseInt(t[1]), this.g = parseInt(t[2]), this.b = parseInt(t[3])) : c.regex.isHex.test(e) && (t = c.regex.hex.exec(4 == (i = e).length ? ["#", i.substring(1, 2), i.substring(1, 2), i.substring(2, 3), i.substring(2, 3), i.substring(3, 4), i.substring(3, 4)].join("") : i), this.r = parseInt(t[1], 16), this.g = parseInt(t[2], 16), this.b = parseInt(t[3], 16)) : "object" === v(e) && (this.r = e.r, this.g = e.g, this.b = e.b))
        }, c.extend(c.Color, {
            toString: function () {
                return this.toHex()
            }, toHex: function () {
                return "#" + d(this.r) + d(this.g) + d(this.b)
            }, toRgb: function () {
                return "rgb(" + [this.r, this.g, this.b].join() + ")"
            }, brightness: function () {
                return this.r / 255 * .3 + this.g / 255 * .59 + this.b / 255 * .11
            }, morph: function (e) {
                return this.destination = new c.Color(e), this
            }, at: function (e) {
                return this.destination ? new c.Color({
                    r: ~~(this.r + (this.destination.r - this.r) * (e = e < 0 ? 0 : 1 < e ? 1 : e)),
                    g: ~~(this.g + (this.destination.g - this.g) * e),
                    b: ~~(this.b + (this.destination.b - this.b) * e)
                }) : this
            }
        }), c.Color.test = function (e) {
            return c.regex.isHex.test(e += "") || c.regex.isRgb.test(e)
        }, c.Color.isRgb = function (e) {
            return e && "number" == typeof e.r && "number" == typeof e.g && "number" == typeof e.b
        }, c.Color.isColor = function (e) {
            return c.Color.isRgb(e) || c.Color.test(e)
        }, c.Array = function (e, t) {
            0 == (e = (e || []).valueOf()).length && t && (e = t.valueOf()), this.value = this.parse(e)
        }, c.extend(c.Array, {
            toString: function () {
                return this.value.join(" ")
            }, valueOf: function () {
                return this.value
            }, parse: function (e) {
                return e = e.valueOf(), Array.isArray(e) ? e : this.split(e)
            }
        }), c.PointArray = function (e, t) {
            c.Array.call(this, e, t || [[0, 0]])
        }, c.PointArray.prototype = new c.Array, c.PointArray.prototype.constructor = c.PointArray;
        for (var l = {
            M: function (e, t, i) {
                return t.x = i.x = e[0], t.y = i.y = e[1], ["M", t.x, t.y]
            }, L: function (e, t) {
                return t.x = e[0], t.y = e[1], ["L", e[0], e[1]]
            }, H: function (e, t) {
                return t.x = e[0], ["H", e[0]]
            }, V: function (e, t) {
                return t.y = e[0], ["V", e[0]]
            }, C: function (e, t) {
                return t.x = e[4], t.y = e[5], ["C", e[0], e[1], e[2], e[3], e[4], e[5]]
            }, Q: function (e, t) {
                return t.x = e[2], t.y = e[3], ["Q", e[0], e[1], e[2], e[3]]
            }, S: function (e, t) {
                return t.x = e[2], t.y = e[3], ["S", e[0], e[1], e[2], e[3]]
            }, Z: function (e, t, i) {
                return t.x = i.x, t.y = i.y, ["Z"]
            }
        }, e = "mlhvqtcsaz".split(""), t = 0, i = e.length; t < i; ++t) l[e[t]] = (n => function (e, t, i) {
            if ("H" == n) e[0] = e[0] + t.x; else if ("V" == n) e[0] = e[0] + t.y; else if ("A" == n) e[5] = e[5] + t.x, e[6] = e[6] + t.y; else for (var s = 0, a = e.length; s < a; ++s) e[s] = e[s] + (s % 2 ? t.y : t.x);
            if (l && "function" == typeof l[n]) return l[n](e, t, i)
        })(e[t].toUpperCase());
        c.PathArray = function (e, t) {
            c.Array.call(this, e, t || [["M", 0, 0]])
        }, c.PathArray.prototype = new c.Array, c.PathArray.prototype.constructor = c.PathArray, c.extend(c.PathArray, {
            toString: function () {
                for (var e = this.value, t = 0, i = e.length, s = ""; t < i; t++) s += e[t][0], null != e[t][1] && (s += e[t][1], null != e[t][2]) && (s = s + " " + e[t][2], null != e[t][3]) && (s = (s = s + " " + e[t][3]) + " " + e[t][4], null != e[t][5]) && (s = (s = s + " " + e[t][5]) + " " + e[t][6], null != e[t][7]) && (s = s + " " + e[t][7]);
                return s + " "
            }, move: function (e, t) {
                var i = this.bbox();
                return i.x, this
            }, at: function (e) {
                if (!this.destination) return this;
                for (var t = this.value, i = this.destination.value, s = [], a = new c.PathArray, n = 0, r = t.length; n < r; n++) {
                    s[n] = [t[n][0]];
                    for (var o = 1, l = t[n].length; o < l; o++) s[n][o] = t[n][o] + (i[n][o] - t[n][o]) * e;
                    "A" === s[n][0] && (s[n][4] = +(0 != s[n][4]), s[n][5] = +(0 != s[n][5]))
                }
                return a.value = s, a
            }, parse: function (e) {
                if (e instanceof c.PathArray) return e.valueOf();
                for (var t, i = {
                    M: 2,
                    L: 2,
                    H: 1,
                    V: 1,
                    C: 6,
                    S: 4,
                    Q: 4,
                    T: 2,
                    A: 7,
                    Z: 0
                }, s = (e = "string" == typeof e ? e.replace(c.regex.numbersWithDots, h).replace(c.regex.pathLetters, " $& ").replace(c.regex.hyphen, "$1 -").trim().split(c.regex.delimiter) : e.reduce(function (e, t) {
                    return [].concat.call(e, t)
                }, []), []), a = new c.Point, n = new c.Point, r = 0, o = e.length; c.regex.isPathLetter.test(e[r]) ? (t = e[r], ++r) : "M" == t ? t = "L" : "m" == t && (t = "l"), s.push(l[t].call(null, e.slice(r, r += i[t.toUpperCase()]).map(parseFloat), a, n)), r < o;) ;
                return s
            }, bbox: function () {
                return c.parser.draw || c.prepare(), c.parser.path.setAttribute("d", this.toString()), c.parser.path.getBBox()
            }
        }), c.Number = c.invent({
            create: function (e, t) {
                this.value = 0, this.unit = t || "", "number" == typeof e ? this.value = isNaN(e) ? 0 : isFinite(e) ? e : e < 0 ? -34e37 : 34e37 : "string" == typeof e ? (t = e.match(c.regex.numberAndUnit)) && (this.value = parseFloat(t[1]), "%" == t[5] ? this.value /= 100 : "s" == t[5] && (this.value *= 1e3), this.unit = t[5]) : e instanceof c.Number && (this.value = e.valueOf(), this.unit = e.unit)
            }, extend: {
                toString: function () {
                    return ("%" == this.unit ? ~~(1e8 * this.value) / 1e6 : "s" == this.unit ? this.value / 1e3 : this.value) + this.unit
                }, toJSON: function () {
                    return this.toString()
                }, valueOf: function () {
                    return this.value
                }, plus: function (e) {
                    return e = new c.Number(e), new c.Number(this + e, this.unit || e.unit)
                }, minus: function (e) {
                    return e = new c.Number(e), new c.Number(this - e, this.unit || e.unit)
                }, times: function (e) {
                    return e = new c.Number(e), new c.Number(this * e, this.unit || e.unit)
                }, divide: function (e) {
                    return e = new c.Number(e), new c.Number(this / e, this.unit || e.unit)
                }, to: function (e) {
                    var t = new c.Number(this);
                    return "string" == typeof e && (t.unit = e), t
                }, morph: function (e) {
                    return this.destination = new c.Number(e), e.relative && (this.destination.value += this.value), this
                }, at: function (e) {
                    return this.destination ? new c.Number(this.destination).minus(this).times(e).plus(this) : this
                }
            }
        }), c.Element = c.invent({
            create: function (e) {
                this._stroke = c.defaults.attrs.stroke, this._event = null, this.dom = {}, (this.node = e) && (this.type = e.nodeName, (this.node.instance = this)._stroke = e.getAttribute("stroke") || this._stroke)
            }, extend: {
                x: function (e) {
                    return this.attr("x", e)
                }, y: function (e) {
                    return this.attr("y", e)
                }, cx: function (e) {
                    return null == e ? this.x() + this.width() / 2 : this.x(e - this.width() / 2)
                }, cy: function (e) {
                    return null == e ? this.y() + this.height() / 2 : this.y(e - this.height() / 2)
                }, move: function (e, t) {
                    return this.x(e).y(t)
                }, center: function (e, t) {
                    return this.cx(e).cy(t)
                }, width: function (e) {
                    return this.attr("width", e)
                }, height: function (e) {
                    return this.attr("height", e)
                }, size: function (e, t) {
                    e = u(this, e, t);
                    return this.width(new c.Number(e.width)).height(new c.Number(e.height))
                }, clone: function (e) {
                    this.writeDataToDom();
                    var t = f(this.node.cloneNode(!0));
                    return e ? e.add(t) : this.after(t), t
                }, remove: function () {
                    return this.parent() && this.parent().removeElement(this), this
                }, replace: function (e) {
                    return this.after(e).remove(), e
                }, addTo: function (e) {
                    return e.put(this)
                }, putIn: function (e) {
                    return e.add(this)
                }, id: function (e) {
                    return this.attr("id", e)
                }, show: function () {
                    return this.style("display", "")
                }, hide: function () {
                    return this.style("display", "none")
                }, visible: function () {
                    return "none" != this.style("display")
                }, toString: function () {
                    return this.attr("id")
                }, classes: function () {
                    var e = this.attr("class");
                    return null == e ? [] : e.trim().split(c.regex.delimiter)
                }, hasClass: function (e) {
                    return -1 != this.classes().indexOf(e)
                }, addClass: function (e) {
                    var t;
                    return this.hasClass(e) || ((t = this.classes()).push(e), this.attr("class", t.join(" "))), this
                }, removeClass: function (t) {
                    return this.hasClass(t) && this.attr("class", this.classes().filter(function (e) {
                        return e != t
                    }).join(" ")), this
                }, toggleClass: function (e) {
                    return this.hasClass(e) ? this.removeClass(e) : this.addClass(e)
                }, reference: function (e) {
                    return c.get(this.attr(e))
                }, parent: function (e) {
                    var t = this;
                    if (!t.node.parentNode) return null;
                    if (t = c.adopt(t.node.parentNode), !e) return t;
                    for (; t && t.node instanceof a.SVGElement;) {
                        if ("string" == typeof e ? t.matches(e) : t instanceof e) return t;
                        if (!t.node.parentNode || "#document" == t.node.parentNode.nodeName) return null;
                        t = c.adopt(t.node.parentNode)
                    }
                }, doc: function () {
                    return this instanceof c.Doc ? this : this.parent(c.Doc)
                }, parents: function (e) {
                    for (var t = [], i = this; (i = i.parent(e)) && i.node && (t.push(i), i.parent);) ;
                    return t
                }, matches: function (e) {
                    return ((t = this.node).matches || t.matchesSelector || t.msMatchesSelector || t.mozMatchesSelector || t.webkitMatchesSelector || t.oMatchesSelector).call(t, e);
                    var t
                }, native: function () {
                    return this.node
                }, svg: function (e) {
                    var t = n.createElementNS("http://www.w3.org/2000/svg", "svg");
                    if (!(e && this instanceof c.Parent)) return t.appendChild(e = n.createElementNS("http://www.w3.org/2000/svg", "svg")), this.writeDataToDom(), e.appendChild(this.node.cloneNode(!0)), t.innerHTML.replace(/^<svg>/, "").replace(/<\/svg>$/, "");
                    t.innerHTML = "<svg>" + e.replace(/\n/, "").replace(/<([\w:-]+)([^<]+?)\/>/g, "<$1$2></$1>") + "</svg>";
                    for (var i = 0, s = t.firstChild.childNodes.length; i < s; i++) this.node.appendChild(t.firstChild.firstChild);
                    return this
                }, writeDataToDom: function () {
                    return (this.each || this.lines) && (this.each ? this : this.lines()).each(function () {
                        this.writeDataToDom()
                    }), this.node.removeAttribute("svgjs:data"), Object.keys(this.dom).length && this.node.setAttribute("svgjs:data", JSON.stringify(this.dom)), this
                }, setData: function (e) {
                    return this.dom = e, this
                }, is: function (e) {
                    return this instanceof e
                }
            }
        }), c.easing = {
            "-": function (e) {
                return e
            }, "<>": function (e) {
                return -Math.cos(e * Math.PI) / 2 + .5
            }, ">": function (e) {
                return Math.sin(e * Math.PI / 2)
            }, "<": function (e) {
                return 1 - Math.cos(e * Math.PI / 2)
            }
        }, c.morph = function (i) {
            return function (e, t) {
                return new c.MorphObj(e, t).at(i)
            }
        }, c.Situation = c.invent({
            create: function (e) {
                this.init = !1, this.reversed = !1, this.reversing = !1, this.duration = new c.Number(e.duration).valueOf(), this.delay = new c.Number(e.delay).valueOf(), this.start = +new Date + this.delay, this.finish = this.start + this.duration, this.ease = e.ease, this.loop = 0, this.loops = !1, this.animations = {}, this.attrs = {}, this.styles = {}, this.transforms = [], this.once = {}
            }
        }), c.FX = c.invent({
            create: function (e) {
                this._target = e, this.situations = [], this.active = !1, this.situation = null, this.paused = !1, this.lastPos = 0, this.pos = 0, this.absPos = 0, this._speed = 1
            }, extend: {
                animate: function (e, t, i) {
                    "object" === v(e) && (t = e.ease, i = e.delay, e = e.duration);
                    e = new c.Situation({duration: e || 1e3, delay: i || 0, ease: c.easing[t || "-"] || t});
                    return this.queue(e), this
                }, target: function (e) {
                    return e && e instanceof c.Element ? (this._target = e, this) : this._target
                }, timeToAbsPos: function (e) {
                    return (e - this.situation.start) / (this.situation.duration / this._speed)
                }, absPosToTime: function (e) {
                    return this.situation.duration / this._speed * e + this.situation.start
                }, startAnimFrame: function () {
                    this.stopAnimFrame(), this.animationFrame = a.requestAnimationFrame(function () {
                        this.step()
                    }.bind(this))
                }, stopAnimFrame: function () {
                    a.cancelAnimationFrame(this.animationFrame)
                }, start: function () {
                    return !this.active && this.situation && (this.active = !0, this.startCurrent()), this
                }, startCurrent: function () {
                    return this.situation.start = +new Date + this.situation.delay / this._speed, this.situation.finish = this.situation.start + this.situation.duration / this._speed, this.initAnimations().step()
                }, queue: function (e) {
                    return ("function" == typeof e || e instanceof c.Situation) && this.situations.push(e), this.situation || (this.situation = this.situations.shift()), this
                }, dequeue: function () {
                    return this.stop(), this.situation = this.situations.shift(), this.situation && (this.situation instanceof c.Situation ? this.start() : this.situation.call(this)), this
                }, initAnimations: function () {
                    var e, t = this.situation;
                    if (!t.init) {
                        for (var i in t.animations) {
                            e = this.target()[i](), Array.isArray(e) || (e = [e]), Array.isArray(t.animations[i]) || (t.animations[i] = [t.animations[i]]);
                            for (var s = e.length; s--;) t.animations[i][s] instanceof c.Number && (e[s] = new c.Number(e[s])), t.animations[i][s] = e[s].morph(t.animations[i][s])
                        }
                        for (var i in t.attrs) t.attrs[i] = new c.MorphObj(this.target().attr(i), t.attrs[i]);
                        for (var i in t.styles) t.styles[i] = new c.MorphObj(this.target().style(i), t.styles[i]);
                        t.initialTransformation = this.target().matrixify(), t.init = !0
                    }
                    return this
                }, clearQueue: function () {
                    return this.situations = [], this
                }, clearCurrent: function () {
                    return this.situation = null, this
                }, stop: function (e, t) {
                    var i = this.active;
                    return this.active = !1, t && this.clearQueue(), e && this.situation && (i || this.startCurrent(), this.atEnd()), this.stopAnimFrame(), this.clearCurrent()
                }, after: function (i) {
                    var s = this.last();
                    return this.target().on("finished.fx", function e(t) {
                        t.detail.situation == s && (i.call(this, s), this.off("finished.fx", e))
                    }), this._callStart()
                }, during: function (t) {
                    function e(e) {
                        e.detail.situation == i && t.call(this, e.detail.pos, c.morph(e.detail.pos), e.detail.eased, i)
                    }

                    var i = this.last();
                    return this.target().off("during.fx", e).on("during.fx", e), this.after(function () {
                        this.off("during.fx", e)
                    }), this._callStart()
                }, afterAll: function (t) {
                    function i(e) {
                        t.call(this), this.off("allfinished.fx", i)
                    }

                    return this.target().off("allfinished.fx", i).on("allfinished.fx", i), this._callStart()
                }, last: function () {
                    return this.situations.length ? this.situations[this.situations.length - 1] : this.situation
                }, add: function (e, t, i) {
                    return this.last()[i || "animations"][e] = t, this._callStart()
                }, step: function (e) {
                    e || (this.absPos = this.timeToAbsPos(+new Date)), !1 !== this.situation.loops ? (e = Math.max(this.absPos, 0), t = Math.floor(e), !0 === this.situation.loops || t < this.situation.loops ? (this.pos = e - t, i = this.situation.loop, this.situation.loop = t) : (this.absPos = this.situation.loops, this.pos = 1, i = this.situation.loop - 1, this.situation.loop = this.situation.loops), this.situation.reversing && (this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - i) % 2))) : (this.absPos = Math.min(this.absPos, 1), this.pos = this.absPos), this.pos < 0 && (this.pos = 0), this.situation.reversed && (this.pos = 1 - this.pos);
                    var t, i, s, a = this.situation.ease(this.pos);
                    for (s in this.situation.once) s > this.lastPos && s <= a && (this.situation.once[s].call(this.target(), this.pos, a), delete this.situation.once[s]);
                    return this.active && this.target().fire("during", {
                        pos: this.pos,
                        eased: a,
                        fx: this,
                        situation: this.situation
                    }), this.situation && (this.eachAt(), 1 == this.pos && !this.situation.reversed || this.situation.reversed && 0 == this.pos ? (this.stopAnimFrame(), this.target().fire("finished", {
                        fx: this,
                        situation: this.situation
                    }), this.situations.length || (this.target().fire("allfinished"), this.situations.length) || (this.target().off(".fx"), this.active = !1), this.active ? this.dequeue() : this.clearCurrent()) : !this.paused && this.active && this.startAnimFrame(), this.lastPos = a), this
                }, eachAt: function () {
                    var e, t = this, i = this.target(), s = this.situation;
                    for (e in s.animations) r = [].concat(s.animations[e]).map(function (e) {
                        return "string" != typeof e && e.at ? e.at(s.ease(t.pos), t.pos) : e
                    }), i[e].apply(i, r);
                    for (e in s.attrs) r = [e].concat(s.attrs[e]).map(function (e) {
                        return "string" != typeof e && e.at ? e.at(s.ease(t.pos), t.pos) : e
                    }), i.attr.apply(i, r);
                    for (e in s.styles) r = [e].concat(s.styles[e]).map(function (e) {
                        return "string" != typeof e && e.at ? e.at(s.ease(t.pos), t.pos) : e
                    }), i.style.apply(i, r);
                    if (s.transforms.length) {
                        r = s.initialTransformation, e = 0;
                        for (var a = s.transforms.length; e < a; e++) var n = s.transforms[e], r = n instanceof c.Matrix ? n.relative ? r.multiply((new c.Matrix).morph(n).at(s.ease(this.pos))) : r.morph(n).at(s.ease(this.pos)) : (n.relative || n.undo(r.extract()), r.multiply(n.at(s.ease(this.pos))));
                        i.matrix(r)
                    }
                    return this
                }, once: function (e, t, i) {
                    var s = this.last();
                    return i || (e = s.ease(e)), s.once[e] = t, this
                }, _callStart: function () {
                    return setTimeout(function () {
                        this.start()
                    }.bind(this), 0), this
                }
            }, parent: c.Element, construct: {
                animate: function (e, t, i) {
                    return (this.fx || (this.fx = new c.FX(this))).animate(e, t, i)
                }, delay: function (e) {
                    return (this.fx || (this.fx = new c.FX(this))).delay(e)
                }, stop: function (e, t) {
                    return this.fx && this.fx.stop(e, t), this
                }, finish: function () {
                    return this.fx && this.fx.finish(), this
                }
            }
        }), c.MorphObj = c.invent({
            create: function (e, t) {
                return c.Color.isColor(t) ? new c.Color(e).morph(t) : c.regex.delimiter.test(e) ? new (c.regex.pathLetters.test(e) ? c.PathArray : c.Array)(e).morph(t) : c.regex.numberAndUnit.test(t) ? new c.Number(e).morph(t) : (this.value = e, void (this.destination = t))
            }, extend: {
                at: function (e, t) {
                    return t < 1 ? this.value : this.destination
                }, valueOf: function () {
                    return this.value
                }
            }
        }), c.extend(c.FX, {
            attr: function (e, t, i) {
                if ("object" === v(e)) for (var s in e) this.attr(s, e[s]); else this.add(e, t, "attrs");
                return this
            }, plot: function (e, t, i, s) {
                return 4 == arguments.length ? this.plot([e, t, i, s]) : this.add("plot", new (this.target().morphArray)(e))
            }
        }), c.Box = c.invent({
            create: function (e, t, i, s) {
                if (!("object" !== v(e) || e instanceof c.Element)) return c.Box.call(this, null != e.left ? e.left : e.x, null != e.top ? e.top : e.y, e.width, e.height);
                4 == arguments.length && (this.x = e, this.y = t, this.width = i, this.height = s), null == (e = this).x && (e.x = 0, e.y = 0, e.width = 0, e.height = 0), e.w = e.width, e.h = e.height, e.x2 = e.x + e.width, e.y2 = e.y + e.height, e.cx = e.x + e.width / 2, e.cy = e.y + e.height / 2
            }
        }), c.BBox = c.invent({
            create: function (t) {
                if (c.Box.apply(this, [].slice.call(arguments)), t instanceof c.Element) {
                    var i, s;
                    try {
                        if (!n.documentElement.contains) {
                            for (var e = t.node; e.parentNode;) e = e.parentNode;
                            if (e != n) throw new Error("Element not in the dom")
                        }
                        i = t.node.getBBox()
                    } catch (e) {
                        t instanceof c.Shape ? (c.parser.draw || c.prepare(), (s = t.clone(c.parser.draw.instance).show()) && s.node && "function" == typeof s.node.getBBox && (i = s.node.getBBox()), s && "function" == typeof s.remove && s.remove()) : i = {
                            x: t.node.clientLeft,
                            y: t.node.clientTop,
                            width: t.node.clientWidth,
                            height: t.node.clientHeight
                        }
                    }
                    c.Box.call(this, i)
                }
            }, inherit: c.Box, parent: c.Element, construct: {
                bbox: function () {
                    return new c.BBox(this)
                }
            }
        }), c.BBox.prototype.constructor = c.BBox, c.Matrix = c.invent({
            create: function (e) {
                var t = p([1, 0, 0, 1, 0, 0]);
                e = null === e ? t : e instanceof c.Element ? e.matrixify() : "string" == typeof e ? p(e.split(c.regex.delimiter).map(parseFloat)) : 6 == arguments.length ? p([].slice.call(arguments)) : Array.isArray(e) ? p(e) : e && "object" === v(e) ? e : t;
                for (var i = b.length - 1; 0 <= i; --i) this[b[i]] = (null != e[b[i]] ? e : t)[b[i]]
            }, extend: {
                extract: function () {
                    var e = g(this, 0, 1), e = (g(this, 1, 0), 180 / Math.PI * Math.atan2(e.y, e.x) - 90);
                    return {
                        x: this.e,
                        y: this.f,
                        transformedX: (this.e * Math.cos(e * Math.PI / 180) + this.f * Math.sin(e * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b),
                        transformedY: (this.f * Math.cos(e * Math.PI / 180) + this.e * Math.sin(-e * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d),
                        rotation: e,
                        a: this.a,
                        b: this.b,
                        c: this.c,
                        d: this.d,
                        e: this.e,
                        f: this.f,
                        matrix: new c.Matrix(this)
                    }
                }, clone: function () {
                    return new c.Matrix(this)
                }, morph: function (e) {
                    return this.destination = new c.Matrix(e), this
                }, multiply: function (e) {
                    return new c.Matrix(this.native().multiply((e = (e = e) instanceof c.Matrix ? e : new c.Matrix(e)).native()))
                }, inverse: function () {
                    return new c.Matrix(this.native().inverse())
                }, translate: function (e, t) {
                    return new c.Matrix(this.native().translate(e || 0, t || 0))
                }, native: function () {
                    for (var e = c.parser.native.createSVGMatrix(), t = b.length - 1; 0 <= t; t--) e[b[t]] = this[b[t]];
                    return e
                }, toString: function () {
                    return "matrix(" + x(this.a) + "," + x(this.b) + "," + x(this.c) + "," + x(this.d) + "," + x(this.e) + "," + x(this.f) + ")"
                }
            }, parent: c.Element, construct: {
                ctm: function () {
                    return new c.Matrix(this.node.getCTM())
                }, screenCTM: function () {
                    var e, t;
                    return this instanceof c.Nested ? (t = (e = this.rect(1, 1)).node.getScreenCTM(), e.remove(), new c.Matrix(t)) : new c.Matrix(this.node.getScreenCTM())
                }
            }
        }), c.Point = c.invent({
            create: function (e, t) {
                t = Array.isArray(e) ? {x: e[0], y: e[1]} : "object" === v(e) ? {x: e.x, y: e.y} : null != e ? {
                    x: e,
                    y: null != t ? t : e
                } : {x: 0, y: 0};
                this.x = t.x, this.y = t.y
            }, extend: {
                clone: function () {
                    return new c.Point(this)
                }, morph: function (e, t) {
                    return this.destination = new c.Point(e, t), this
                }
            }
        }), c.extend(c.Element, {
            point: function (e, t) {
                return new c.Point(e, t).transform(this.screenCTM().inverse())
            }
        }), c.extend(c.Element, {
            attr: function (e, t, i) {
                if (null == e) {
                    for (e = {}, i = (t = this.node.attributes).length - 1; 0 <= i; i--) e[t[i].nodeName] = c.regex.isNumber.test(t[i].nodeValue) ? parseFloat(t[i].nodeValue) : t[i].nodeValue;
                    return e
                }
                if ("object" === v(e)) for (var s in e) this.attr(s, e[s]); else if (null === t) this.node.removeAttribute(e); else {
                    if (null == t) return null == (t = this.node.getAttribute(e)) ? c.defaults.attrs[e] : c.regex.isNumber.test(t) ? parseFloat(t) : t;
                    "stroke-width" == e ? this.attr("stroke", 0 < parseFloat(t) ? this._stroke : null) : "stroke" == e && (this._stroke = t), "fill" != e && "stroke" != e || (t = c.regex.isImage.test(t) ? this.doc().defs().image(t, 0, 0) : t) instanceof c.Image && (t = this.doc().defs().pattern(0, 0, function () {
                        this.add(t)
                    })), "number" == typeof t ? t = new c.Number(t) : c.Color.isColor(t) ? t = new c.Color(t) : Array.isArray(t) && (t = new c.Array(t)), "leading" == e ? this.leading && this.leading(t) : "string" == typeof i ? this.node.setAttributeNS(i, e, t.toString()) : this.node.setAttribute(e, t.toString()), !this.rebuild || "font-size" != e && "x" != e || this.rebuild(e, t)
                }
                return this
            }
        }), c.extend(c.Element, {
            transform: function (e, t) {
                var i;
                return "object" !== v(e) ? (i = new c.Matrix(this).extract(), "string" == typeof e ? i[e] : i) : (i = new c.Matrix(this), t = !!t || !!e.relative, null != e.a && (i = t ? i.multiply(new c.Matrix(e)) : new c.Matrix(e)), this.attr("transform", i))
            }
        }), c.extend(c.Element, {
            untransform: function () {
                return this.attr("transform", null)
            }, matrixify: function () {
                return (this.attr("transform") || "").split(c.regex.transforms).slice(0, -1).map(function (e) {
                    e = e.trim().split("(");
                    return [e[0], e[1].split(c.regex.delimiter).map(function (e) {
                        return parseFloat(e)
                    })]
                }).reduce(function (e, t) {
                    return "matrix" == t[0] ? e.multiply(p(t[1])) : e[t[0]].apply(e, t[1])
                }, new c.Matrix)
            }, toParent: function (e) {
                var t, i;
                return this != e && (t = this.screenCTM(), i = e.screenCTM().inverse(), this.addTo(e).untransform().transform(i.multiply(t))), this
            }, toDoc: function () {
                return this.toParent(this.doc())
            }
        }), c.Transformation = c.invent({
            create: function (e, t) {
                if (1 < arguments.length && "boolean" != typeof t) return this.constructor.call(this, [].slice.call(arguments));
                if (Array.isArray(e)) for (var i = 0, s = this.arguments.length; i < s; ++i) this[this.arguments[i]] = e[i]; else if (e && "object" === v(e)) for (i = 0, s = this.arguments.length; i < s; ++i) this[this.arguments[i]] = e[this.arguments[i]];
                !(this.inversed = !1) === t && (this.inversed = !0)
            }
        }), c.Translate = c.invent({
            parent: c.Matrix, inherit: c.Transformation, create: function (e, t) {
                this.constructor.apply(this, [].slice.call(arguments))
            }, extend: {arguments: ["transformedX", "transformedY"], method: "translate"}
        }), c.extend(c.Element, {
            style: function (e, t) {
                if (0 == arguments.length) return this.node.style.cssText || "";
                if (arguments.length < 2) if ("object" === v(e)) for (var i in e) this.style(i, e[i]); else {
                    if (!c.regex.isCss.test(e)) return this.node.style[r(e)];
                    for (e = e.split(/\s*;\s*/).filter(function (e) {
                        return !!e
                    }).map(function (e) {
                        return e.split(/\s*:\s*/)
                    }); t = e.pop();) this.style(t[0], t[1])
                } else this.node.style[r(e)] = null === t || c.regex.isBlank.test(t) ? "" : t;
                return this
            }
        }), c.Parent = c.invent({
            create: function (e) {
                this.constructor.call(this, e)
            }, inherit: c.Element, extend: {
                children: function () {
                    return c.utils.map(c.utils.filterSVGElements(this.node.childNodes), function (e) {
                        return c.adopt(e)
                    })
                }, add: function (e, t) {
                    return null == t ? this.node.appendChild(e.node) : e.node != this.node.childNodes[t] && this.node.insertBefore(e.node, this.node.childNodes[t]), this
                }, put: function (e, t) {
                    return this.add(e, t), e
                }, has: function (e) {
                    return 0 <= this.index(e)
                }, index: function (e) {
                    return [].slice.call(this.node.childNodes).indexOf(e.node)
                }, get: function (e) {
                    return c.adopt(this.node.childNodes[e])
                }, first: function () {
                    return this.get(0)
                }, last: function () {
                    return this.get(this.node.childNodes.length - 1)
                }, each: function (e, t) {
                    for (var i = this.children(), s = 0, a = i.length; s < a; s++) i[s] instanceof c.Element && e.apply(i[s], [s, i]), t && i[s] instanceof c.Container && i[s].each(e, t);
                    return this
                }, removeElement: function (e) {
                    return this.node.removeChild(e.node), this
                }, clear: function () {
                    for (; this.node.hasChildNodes();) this.node.removeChild(this.node.lastChild);
                    return delete this._defs, this
                }, defs: function () {
                    return this.doc().defs()
                }
            }
        }), c.extend(c.Parent, {
            ungroup: function (e, t) {
                return 0 === t || this instanceof c.Defs || this.node == c.parser.draw || (e = e || (this instanceof c.Doc ? this : this.parent(c.Parent)), t = t || 1 / 0, this.each(function () {
                    return this instanceof c.Defs ? this : this instanceof c.Parent ? this.ungroup(e, t - 1) : this.toParent(e)
                }), this.node.firstChild) || this.remove(), this
            }, flatten: function (e, t) {
                return this.ungroup(e, t)
            }
        }), c.Container = c.invent({
            create: function (e) {
                this.constructor.call(this, e)
            }, inherit: c.Parent
        }), c.ViewBox = c.invent({
            parent: c.Container,
            construct: {}
        }), ["click", "dblclick", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "touchstart", "touchmove", "touchleave", "touchend", "touchcancel"].forEach(function (t) {
            c.Element.prototype[t] = function (e) {
                return c.on(this.node, t, e), this
            }
        }), c.listeners = [], c.handlerMap = [], c.listenerId = 0, c.on = function (e, t, i, s, a) {
            var s = i.bind(s || e.instance || e), n = (c.handlerMap.indexOf(e) + 1 || c.handlerMap.push(e)) - 1,
                r = t.split(".")[0], t = t.split(".")[1] || "*";
            c.listeners[n] = c.listeners[n] || {}, c.listeners[n][r] = c.listeners[n][r] || {}, c.listeners[n][r][t] = c.listeners[n][r][t] || {}, i._svgjsListenerId || (i._svgjsListenerId = ++c.listenerId), c.listeners[n][r][t][i._svgjsListenerId] = s, e.addEventListener(r, s, a || {passive: !1})
        }, c.off = function (e, t, i) {
            var s = c.handlerMap.indexOf(e), a = t && t.split(".")[0], n = t && t.split(".")[1], r = "";
            if (-1 != s) if (i) !(i = "function" == typeof i ? i._svgjsListenerId : i) || c.listeners[s][a] && c.listeners[s][a][n || "*"] && (e.removeEventListener(a, c.listeners[s][a][n || "*"][i], !1), delete c.listeners[s][a][n || "*"][i]); else if (n && a) {
                if (c.listeners[s][a] && c.listeners[s][a][n]) {
                    for (var o in c.listeners[s][a][n]) c.off(e, [a, n].join("."), o);
                    delete c.listeners[s][a][n]
                }
            } else if (n) for (var l in c.listeners[s]) for (var r in c.listeners[s][l]) n === r && c.off(e, [l, n].join(".")); else if (a) {
                if (c.listeners[s][a]) {
                    for (var r in c.listeners[s][a]) c.off(e, [a, r].join("."));
                    delete c.listeners[s][a]
                }
            } else {
                for (var l in c.listeners[s]) c.off(e, l);
                delete c.listeners[s], delete c.handlerMap[s]
            }
        }, c.extend(c.Element, {
            on: function (e, t, i, s) {
                return c.on(this.node, e, t, i, s), this
            }, off: function (e, t) {
                return c.off(this.node, e, t), this
            }, fire: function (e, t) {
                return e instanceof a.Event ? this.node.dispatchEvent(e) : this.node.dispatchEvent(e = new c.CustomEvent(e, {
                    detail: t,
                    cancelable: !0
                })), this._event = e, this
            }, event: function () {
                return this._event
            }
        }), c.Defs = c.invent({create: "defs", inherit: c.Container}), c.G = c.invent({
            create: "g",
            inherit: c.Container,
            extend: {
                x: function (e) {
                    return null == e ? this.transform("x") : this.transform({x: e - this.x()}, !0)
                }
            },
            construct: {
                group: function () {
                    return this.put(new c.G)
                }
            }
        }), c.Doc = c.invent({
            create: function (e) {
                e && ("svg" == (e = "string" == typeof e ? n.getElementById(e) : e).nodeName ? this.constructor.call(this, e) : (this.constructor.call(this, c.create("svg")), e.appendChild(this.node), this.size("100%", "100%")), this.namespace().defs())
            }, inherit: c.Container, extend: {
                namespace: function () {
                    return this.attr({
                        xmlns: c.ns,
                        version: "1.1"
                    }).attr("xmlns:xlink", c.xlink, c.xmlns).attr("xmlns:svgjs", c.svgjs, c.xmlns)
                }, defs: function () {
                    var e;
                    return this._defs || ((e = this.node.getElementsByTagName("defs")[0]) ? this._defs = c.adopt(e) : this._defs = new c.Defs, this.node.appendChild(this._defs.node)), this._defs
                }, parent: function () {
                    return this.node.parentNode && "#document" != this.node.parentNode.nodeName ? this.node.parentNode : null
                }, remove: function () {
                    return this.parent() && this.parent().removeChild(this.node), this
                }, clear: function () {
                    for (; this.node.hasChildNodes();) this.node.removeChild(this.node.lastChild);
                    return delete this._defs, c.parser.draw && !c.parser.draw.parentNode && this.node.appendChild(c.parser.draw), this
                }, clone: function (e) {
                    this.writeDataToDom();
                    var t = this.node, i = f(t.cloneNode(!0));
                    return e ? (e.node || e).appendChild(i.node) : t.parentNode.insertBefore(i.node, t.nextSibling), i
                }
            }
        }), c.extend(c.Element, {}), c.Gradient = c.invent({
            create: function (e) {
                this.constructor.call(this, c.create(e + "Gradient")), this.type = e
            }, inherit: c.Container, extend: {
                at: function (e, t, i) {
                    return this.put(new c.Stop).update(e, t, i)
                }, update: function (e) {
                    return this.clear(), "function" == typeof e && e.call(this, this), this
                }, fill: function () {
                    return "url(#" + this.id() + ")"
                }, toString: function () {
                    return this.fill()
                }, attr: function (e, t, i) {
                    return c.Container.prototype.attr.call(this, e = "transform" == e ? "gradientTransform" : e, t, i)
                }
            }, construct: {
                gradient: function (e, t) {
                    return this.defs().gradient(e, t)
                }
            }
        }), c.extend(c.Gradient, c.FX, {
            from: function (e, t) {
                return "radial" == (this._target || this).type ? this.attr({
                    fx: new c.Number(e),
                    fy: new c.Number(t)
                }) : this.attr({x1: new c.Number(e), y1: new c.Number(t)})
            }, to: function (e, t) {
                return "radial" == (this._target || this).type ? this.attr({
                    cx: new c.Number(e),
                    cy: new c.Number(t)
                }) : this.attr({x2: new c.Number(e), y2: new c.Number(t)})
            }
        }), c.extend(c.Defs, {
            gradient: function (e, t) {
                return this.put(new c.Gradient(e)).update(t)
            }
        }), c.Stop = c.invent({
            create: "stop", inherit: c.Element, extend: {
                update: function (e) {
                    return null != (e = "number" == typeof e || e instanceof c.Number ? {
                        offset: arguments[0],
                        color: arguments[1],
                        opacity: arguments[2]
                    } : e).opacity && this.attr("stop-opacity", e.opacity), null != e.color && this.attr("stop-color", e.color), null != e.offset && this.attr("offset", new c.Number(e.offset)), this
                }
            }
        }), c.Pattern = c.invent({
            create: "pattern", inherit: c.Container, extend: {
                fill: function () {
                    return "url(#" + this.id() + ")"
                }, update: function (e) {
                    return this.clear(), "function" == typeof e && e.call(this, this), this
                }, toString: function () {
                    return this.fill()
                }, attr: function (e, t, i) {
                    return c.Container.prototype.attr.call(this, e = "transform" == e ? "patternTransform" : e, t, i)
                }
            }, construct: {
                pattern: function (e, t, i) {
                    return this.defs().pattern(e, t, i)
                }
            }
        }), c.extend(c.Defs, {
            pattern: function (e, t, i) {
                return this.put(new c.Pattern).update(i).attr({
                    x: 0,
                    y: 0,
                    width: e,
                    height: t,
                    patternUnits: "userSpaceOnUse"
                })
            }
        }), c.Shape = c.invent({
            create: function (e) {
                this.constructor.call(this, e)
            }, inherit: c.Element
        }), c.Symbol = c.invent({
            create: "symbol", inherit: c.Container, construct: {
                symbol: function () {
                    return this.put(new c.Symbol)
                }
            }
        }), c.Use = c.invent({
            create: "use", inherit: c.Shape, extend: {
                element: function (e, t) {
                    return this.attr("href", (t || "") + "#" + e, c.xlink)
                }
            }, construct: {
                use: function (e, t) {
                    return this.put(new c.Use).element(e, t)
                }
            }
        }), c.Rect = c.invent({
            create: "rect", inherit: c.Shape, construct: {
                rect: function (e, t) {
                    return this.put(new c.Rect).size(e, t)
                }
            }
        }), c.Circle = c.invent({
            create: "circle", inherit: c.Shape, construct: {
                circle: function (e) {
                    return this.put(new c.Circle).rx(new c.Number(e).divide(2)).move(0, 0)
                }
            }
        }), c.extend(c.Circle, c.FX, {
            rx: function (e) {
                return this.attr("r", e)
            }, ry: function (e) {
                return this.rx(e)
            }
        }), c.Ellipse = c.invent({
            create: "ellipse", inherit: c.Shape, construct: {
                ellipse: function (e, t) {
                    return this.put(new c.Ellipse).size(e, t).move(0, 0)
                }
            }
        }), c.extend(c.Ellipse, c.Rect, c.FX, {
            rx: function (e) {
                return this.attr("rx", e)
            }, ry: function (e) {
                return this.attr("ry", e)
            }
        }), c.extend(c.Circle, c.Ellipse, {
            x: function (e) {
                return null == e ? this.cx() - this.rx() : this.cx(e + this.rx())
            }, y: function (e) {
                return null == e ? this.cy() - this.ry() : this.cy(e + this.ry())
            }, cx: function (e) {
                return null == e ? this.attr("cx") : this.attr("cx", e)
            }, cy: function (e) {
                return null == e ? this.attr("cy") : this.attr("cy", e)
            }, width: function (e) {
                return null == e ? 2 * this.rx() : this.rx(new c.Number(e).divide(2))
            }, height: function (e) {
                return null == e ? 2 * this.ry() : this.ry(new c.Number(e).divide(2))
            }, size: function (e, t) {
                e = u(this, e, t);
                return this.rx(new c.Number(e.width).divide(2)).ry(new c.Number(e.height).divide(2))
            }
        }), c.Line = c.invent({
            create: "line", inherit: c.Shape, extend: {
                array: function () {
                    return new c.PointArray([[this.attr("x1"), this.attr("y1")], [this.attr("x2"), this.attr("y2")]])
                }, plot: function (e, t, i, s) {
                    return null == e ? this.array() : (e = void 0 !== t ? {
                        x1: e,
                        y1: t,
                        x2: i,
                        y2: s
                    } : new c.PointArray(e).toLine(), this.attr(e))
                }, move: function (e, t) {
                    return this.attr(this.array().move(e, t).toLine())
                }, size: function (e, t) {
                    e = u(this, e, t);
                    return this.attr(this.array().size(e.width, e.height).toLine())
                }
            }, construct: {
                line: function (e, t, i, s) {
                    return c.Line.prototype.plot.apply(this.put(new c.Line), null != e ? [e, t, i, s] : [0, 0, 0, 0])
                }
            }
        }), c.Polyline = c.invent({
            create: "polyline", inherit: c.Shape, construct: {
                polyline: function (e) {
                    return this.put(new c.Polyline).plot(e || new c.PointArray)
                }
            }
        }), c.Polygon = c.invent({
            create: "polygon", inherit: c.Shape, construct: {
                polygon: function (e) {
                    return this.put(new c.Polygon).plot(e || new c.PointArray)
                }
            }
        }), c.extend(c.Polyline, c.Polygon, {
            array: function () {
                return this._array || (this._array = new c.PointArray(this.attr("points")))
            }, plot: function (e) {
                return null == e ? this.array() : this.clear().attr("points", "string" == typeof e ? e : this._array = new c.PointArray(e))
            }, clear: function () {
                return delete this._array, this
            }, move: function (e, t) {
                return this.attr("points", this.array().move(e, t))
            }, size: function (e, t) {
                e = u(this, e, t);
                return this.attr("points", this.array().size(e.width, e.height))
            }
        }), c.extend(c.Line, c.Polyline, c.Polygon, {
            morphArray: c.PointArray, x: function (e) {
                return null == e ? this.bbox().x : this.move(e, this.bbox().y)
            }, y: function (e) {
                return null == e ? this.bbox().y : this.move(this.bbox().x, e)
            }, width: function (e) {
                var t = this.bbox();
                return null == e ? t.width : this.size(e, t.height)
            }, height: function (e) {
                var t = this.bbox();
                return null == e ? t.height : this.size(t.width, e)
            }
        }), c.Path = c.invent({
            create: "path", inherit: c.Shape, extend: {
                morphArray: c.PathArray, array: function () {
                    return this._array || (this._array = new c.PathArray(this.attr("d")))
                }, plot: function (e) {
                    return null == e ? this.array() : this.clear().attr("d", "string" == typeof e ? e : this._array = new c.PathArray(e))
                }, clear: function () {
                    return delete this._array, this
                }
            }, construct: {
                path: function (e) {
                    return this.put(new c.Path).plot(e || new c.PathArray)
                }
            }
        }), c.Image = c.invent({
            create: "image", inherit: c.Shape, extend: {
                load: function (t) {
                    var i, s;
                    return t ? (i = this, s = new a.Image, c.on(s, "load", function () {
                        c.off(s);
                        var e = i.parent(c.Pattern);
                        null !== e && (0 == i.width() && 0 == i.height() && i.size(s.width, s.height), e && 0 == e.width() && 0 == e.height() && e.size(i.width(), i.height()), "function" == typeof i._loaded) && i._loaded.call(i, {
                            width: s.width,
                            height: s.height,
                            ratio: s.width / s.height,
                            url: t
                        })
                    }), c.on(s, "error", function (e) {
                        c.off(s), "function" == typeof i._error && i._error.call(i, e)
                    }), this.attr("href", s.src = this.src = t, c.xlink)) : this
                }, loaded: function (e) {
                    return this._loaded = e, this
                }, error: function (e) {
                    return this._error = e, this
                }
            }, construct: {
                image: function (e, t, i) {
                    return this.put(new c.Image).load(e).size(t || 0, i || t || 0)
                }
            }
        }), c.Text = c.invent({
            create: function () {
                this.constructor.call(this, c.create("text")), this.dom.leading = new c.Number(1.3), this._rebuild = !0, this._build = !1, this.attr("font-family", c.defaults.attrs["font-family"])
            }, inherit: c.Shape, extend: {
                x: function (e) {
                    return null == e ? this.attr("x") : this.attr("x", e)
                }, text: function (e) {
                    if (void 0 === e) {
                        e = "";
                        for (var t = this.node.childNodes, i = 0, s = t.length; i < s; ++i) 0 != i && 3 != t[i].nodeType && 1 == c.adopt(t[i]).dom.newLined && (e += "\n"), e += t[i].textContent;
                        return e
                    }
                    if (this.clear().build(!0), "function" == typeof e) e.call(this, this); else for (var i = 0, a = (e = e.split("\n")).length; i < a; i++) this.tspan(e[i]).newLine();
                    return this.build(!1).rebuild()
                }, size: function (e) {
                    return this.attr("font-size", e).rebuild()
                }, leading: function (e) {
                    return null == e ? this.dom.leading : (this.dom.leading = new c.Number(e), this.rebuild())
                }, lines: function () {
                    var e = (this.textPath && this.textPath() || this).node,
                        e = c.utils.map(c.utils.filterSVGElements(e.childNodes), function (e) {
                            return c.adopt(e)
                        });
                    return new c.Set(e)
                }, rebuild: function (e) {
                    var t, i, s;
                    return "boolean" == typeof e && (this._rebuild = e), this._rebuild && (i = 0, s = (t = this).dom.leading * new c.Number(this.attr("font-size")), this.lines().each(function () {
                        this.dom.newLined && (t.textPath() || this.attr("x", t.attr("x")), "\n" == this.text() ? i += s : (this.attr("dy", s + i), i = 0))
                    }), this.fire("rebuild")), this
                }, build: function (e) {
                    return this._build = !!e, this
                }, setData: function (e) {
                    return this.dom = e, this.dom.leading = new c.Number(e.leading || 1.3), this
                }
            }, construct: {
                text: function (e) {
                    return this.put(new c.Text).text(e)
                }, plain: function (e) {
                    return this.put(new c.Text).plain(e)
                }
            }
        }), c.Tspan = c.invent({
            create: "tspan", inherit: c.Shape, extend: {
                text: function (e) {
                    return null == e ? this.node.textContent + (this.dom.newLined ? "\n" : "") : ("function" == typeof e ? e.call(this, this) : this.plain(e), this)
                }, dx: function (e) {
                    return this.attr("dx", e)
                }, dy: function (e) {
                    return this.attr("dy", e)
                }, newLine: function () {
                    var e = this.parent(c.Text);
                    return this.dom.newLined = !0, this.dy(e.dom.leading * e.attr("font-size")).attr("x", e.x())
                }
            }
        }), c.extend(c.Text, c.Tspan, {
            plain: function (e) {
                return !1 === this._build && this.clear(), this.node.appendChild(n.createTextNode(e)), this
            }, tspan: function (e) {
                var t = (this.textPath && this.textPath() || this).node, i = new c.Tspan;
                return !1 === this._build && this.clear(), t.appendChild(i.node), i.text(e)
            }, clear: function () {
                for (var e = (this.textPath && this.textPath() || this).node; e.hasChildNodes();) e.removeChild(e.lastChild);
                return this
            }, length: function () {
                return this.node.getComputedTextLength()
            }
        }), c.TextPath = c.invent({
            create: "textPath",
            inherit: c.Parent,
            parent: c.Text,
            construct: {
                morphArray: c.PathArray, array: function () {
                    var e = this.track();
                    return e ? e.array() : null
                }, plot: function (e) {
                    var t = this.track(), i = null;
                    return t && (i = t.plot(e)), null == e ? i : this
                }, track: function () {
                    var e = this.textPath();
                    if (e) return e.reference("href")
                }, textPath: function () {
                    if (this.node.firstChild && "textPath" == this.node.firstChild.nodeName) return c.adopt(this.node.firstChild)
                }
            }
        }), c.Nested = c.invent({
            create: function () {
                this.constructor.call(this, c.create("svg")), this.style("overflow", "visible")
            }, inherit: c.Container, construct: {
                nested: function () {
                    return this.put(new c.Nested)
                }
            }
        });
        var s = {
            stroke: ["color", "width", "opacity", "linecap", "linejoin", "miterlimit", "dasharray", "dashoffset"],
            fill: ["color", "opacity", "rule"],
            prefix: function (e, t) {
                return "color" == t ? e : e + "-" + t
            }
        };

        function h(e, t, i, s) {
            return i + s.replace(c.regex.dots, " .")
        }

        function r(e) {
            return e.toLowerCase().replace(/-(.)/g, function (e, t) {
                return t.toUpperCase()
            })
        }

        function o(e) {
            return e.charAt(0).toUpperCase() + e.slice(1)
        }

        function d(e) {
            e = e.toString(16);
            return 1 == e.length ? "0" + e : e
        }

        function u(e, t, i) {
            return null != t && null != i || (e = e.bbox(), null == t ? t = e.width / e.height * i : null == i && (i = e.height / e.width * t)), {
                width: t,
                height: i
            }
        }

        function g(e, t, i) {
            return {x: t * e.a + i * e.c, y: t * e.b + i * e.d}
        }

        function p(e) {
            return {a: e[0], b: e[1], c: e[2], d: e[3], e: e[4], f: e[5]}
        }

        function f(e) {
            for (var t = e.childNodes.length - 1; 0 <= t; t--) e.childNodes[t] instanceof a.SVGElement && f(e.childNodes[t]);
            return c.adopt(e).id(c.eid(e.nodeName))
        }

        function x(e) {
            return 1e-37 < Math.abs(e) ? e : 0
        }

        ["fill", "stroke"].forEach(function (i) {
            var e = {};
            e[i] = function (e) {
                if (void 0 !== e) if ("string" == typeof e || c.Color.isRgb(e) || e && "function" == typeof e.fill) this.attr(i, e); else for (var t = s[i].length - 1; 0 <= t; t--) null != e[s[i][t]] && this.attr(s.prefix(i, s[i][t]), e[s[i][t]]);
                return this
            }, c.extend(c.Element, c.FX, e)
        }), c.extend(c.Element, c.FX, {
            translate: function (e, t) {
                return this.transform({x: e, y: t})
            }, matrix: function (e) {
                return this.attr("transform", new c.Matrix(6 == arguments.length ? [].slice.call(arguments) : e))
            }, opacity: function (e) {
                return this.attr("opacity", e)
            }, dx: function (e) {
                return this.x(new c.Number(e).plus(this instanceof c.FX ? 0 : this.x()), !0)
            }, dy: function (e) {
                return this.y(new c.Number(e).plus(this instanceof c.FX ? 0 : this.y()), !0)
            }
        }), c.extend(c.Path, {
            length: function () {
                return this.node.getTotalLength()
            }, pointAt: function (e) {
                return this.node.getPointAtLength(e)
            }
        }), c.Set = c.invent({
            create: function (e) {
                Array.isArray(e) ? this.members = e : this.clear()
            }, extend: {
                add: function () {
                    for (var e = [].slice.call(arguments), t = 0, i = e.length; t < i; t++) this.members.push(e[t]);
                    return this
                }, remove: function (e) {
                    e = this.index(e);
                    return -1 < e && this.members.splice(e, 1), this
                }, each: function (e) {
                    for (var t = 0, i = this.members.length; t < i; t++) e.apply(this.members[t], [t, this.members]);
                    return this
                }, clear: function () {
                    return this.members = [], this
                }, length: function () {
                    return this.members.length
                }, has: function (e) {
                    return 0 <= this.index(e)
                }, index: function (e) {
                    return this.members.indexOf(e)
                }, get: function (e) {
                    return this.members[e]
                }, first: function () {
                    return this.get(0)
                }, last: function () {
                    return this.get(this.members.length - 1)
                }, valueOf: function () {
                    return this.members
                }
            }, construct: {
                set: function (e) {
                    return new c.Set(e)
                }
            }
        }), c.FX.Set = c.invent({
            create: function (e) {
                this.set = e
            }
        }), c.Set.inherit = function () {
            var e, t = [];
            for (e in c.Shape.prototype) "function" == typeof c.Shape.prototype[e] && "function" != typeof c.Set.prototype[e] && t.push(e);
            for (e in t.forEach(function (i) {
                c.Set.prototype[i] = function () {
                    for (var e = 0, t = this.members.length; e < t; e++) this.members[e] && "function" == typeof this.members[e][i] && this.members[e][i].apply(this.members[e], arguments);
                    return "animate" == i ? this.fx || (this.fx = new c.FX.Set(this)) : this
                }
            }), t = [], c.FX.prototype) "function" == typeof c.FX.prototype[e] && "function" != typeof c.FX.Set.prototype[e] && t.push(e);
            t.forEach(function (i) {
                c.FX.Set.prototype[i] = function () {
                    for (var e = 0, t = this.set.members.length; e < t; e++) this.set.members[e].fx[i].apply(this.set.members[e].fx, arguments);
                    return this
                }
            })
        }, c.extend(c.Element, {}), c.extend(c.Element, {
            remember: function (e, t) {
                if ("object" === v(e)) for (var i in e) this.remember(i, e[i]); else {
                    if (1 == arguments.length) return this.memory()[e];
                    this.memory()[e] = t
                }
                return this
            }, forget: function () {
                if (0 == arguments.length) this._memory = {}; else for (var e = arguments.length - 1; 0 <= e; e--) delete this.memory()[arguments[e]];
                return this
            }, memory: function () {
                return this._memory || (this._memory = {})
            }
        }), c.get = function (t) {
            var e = n.getElementById((() => {
                var e = (t || "").toString().match(c.regex.reference);
                if (e) return e[1]
            })() || t);
            return c.adopt(e)
        }, c.select = function (e, t) {
            return new c.Set(c.utils.map((t || n).querySelectorAll(e), function (e) {
                return c.adopt(e)
            }))
        }, c.extend(c.Parent, {
            select: function (e) {
                return c.select(e, this.node)
            }
        });
        var m, b = "abcdef".split("");
        return "function" != typeof a.CustomEvent ? ((m = function (e, t) {
            t = t || {bubbles: !1, cancelable: !1, detail: void 0};
            var i = n.createEvent("CustomEvent");
            return i.initCustomEvent(e, t.bubbles, t.cancelable, t.detail), i
        }).prototype = a.Event.prototype, c.CustomEvent = m) : c.CustomEvent = a.CustomEvent, c
    }, "function" == typeof define && define.amd ? define(function () {
        return E(b, b.document)
    }) : "object" === ("undefined" == typeof exports ? "undefined" : v(exports)) && "undefined" != typeof module ? module.exports = b.document ? E(b, b.document) : function (e) {
        return E(e, e.document)
    } : b.SVG = E(b, b.document), function () {
        SVG.Filter = SVG.invent({
            create: "filter", inherit: SVG.Parent, extend: {
                source: "SourceGraphic",
                sourceAlpha: "SourceAlpha",
                background: "BackgroundImage",
                backgroundAlpha: "BackgroundAlpha",
                fill: "FillPaint",
                stroke: "StrokePaint",
                autoSetIn: !0,
                put: function (e, t) {
                    return this.add(e, t), !e.attr("in") && this.autoSetIn && e.attr("in", this.source), e.attr("result") || e.attr("result", e), e
                },
                blend: function (e, t, i) {
                    return this.put(new SVG.BlendEffect(e, t, i))
                },
                colorMatrix: function (e, t) {
                    return this.put(new SVG.ColorMatrixEffect(e, t))
                },
                convolveMatrix: function (e) {
                    return this.put(new SVG.ConvolveMatrixEffect(e))
                },
                componentTransfer: function (e) {
                    return this.put(new SVG.ComponentTransferEffect(e))
                },
                composite: function (e, t, i) {
                    return this.put(new SVG.CompositeEffect(e, t, i))
                },
                flood: function (e, t) {
                    return this.put(new SVG.FloodEffect(e, t))
                },
                offset: function (e, t) {
                    return this.put(new SVG.OffsetEffect(e, t))
                },
                image: function (e) {
                    return this.put(new SVG.ImageEffect(e))
                },
                merge: function () {
                    var e, t = [void 0];
                    for (e in arguments) t.push(arguments[e]);
                    return this.put(new (SVG.MergeEffect.bind.apply(SVG.MergeEffect, t)))
                },
                gaussianBlur: function (e, t) {
                    return this.put(new SVG.GaussianBlurEffect(e, t))
                },
                morphology: function (e, t) {
                    return this.put(new SVG.MorphologyEffect(e, t))
                },
                diffuseLighting: function (e, t, i) {
                    return this.put(new SVG.DiffuseLightingEffect(e, t, i))
                },
                displacementMap: function (e, t, i, s, a) {
                    return this.put(new SVG.DisplacementMapEffect(e, t, i, s, a))
                },
                specularLighting: function (e, t, i, s) {
                    return this.put(new SVG.SpecularLightingEffect(e, t, i, s))
                },
                tile: function () {
                    return this.put(new SVG.TileEffect)
                },
                turbulence: function (e, t, i, s, a) {
                    return this.put(new SVG.TurbulenceEffect(e, t, i, s, a))
                },
                toString: function () {
                    return "url(#" + this.attr("id") + ")"
                }
            }
        }), SVG.extend(SVG.Defs, {
            filter: function (e) {
                var t = this.put(new SVG.Filter);
                return "function" == typeof e && e.call(t, t), t
            }
        }), SVG.extend(SVG.Container, {
            filter: function (e) {
                return this.defs().filter(e)
            }
        }), SVG.extend(SVG.Element, SVG.G, SVG.Nested, {
            filter: function (e) {
                return this.filterer = e instanceof SVG.Element ? e : this.doc().filter(e), this.doc() && this.filterer.doc() !== this.doc() && this.doc().defs().add(this.filterer), this.attr("filter", this.filterer), this.filterer
            }, unfilter: function (e) {
                return this.filterer && !0 === e && this.filterer.remove(), delete this.filterer, this.attr("filter", null)
            }
        }), SVG.Effect = SVG.invent({
            create: function () {
                this.constructor.call(this)
            }, inherit: SVG.Element, extend: {
                in: function (e) {
                    return null == e ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", e)
                }, result: function (e) {
                    return null == e ? this.attr("result") : this.attr("result", e)
                }, toString: function () {
                    return this.result()
                }
            }
        }), SVG.ParentEffect = SVG.invent({
            create: function () {
                this.constructor.call(this)
            }, inherit: SVG.Parent, extend: {
                in: function (e) {
                    return null == e ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", e)
                }, result: function (e) {
                    return null == e ? this.attr("result") : this.attr("result", e)
                }, toString: function () {
                    return this.result()
                }
            }
        });
        var e = {
            blend: function (e, t) {
                return this.parent() && this.parent().blend(this, e, t)
            }, colorMatrix: function (e, t) {
                return this.parent() && this.parent().colorMatrix(e, t).in(this)
            }, convolveMatrix: function (e) {
                return this.parent() && this.parent().convolveMatrix(e).in(this)
            }, componentTransfer: function (e) {
                return this.parent() && this.parent().componentTransfer(e).in(this)
            }, composite: function (e, t) {
                return this.parent() && this.parent().composite(this, e, t)
            }, flood: function (e, t) {
                return this.parent() && this.parent().flood(e, t)
            }, offset: function (e, t) {
                return this.parent() && this.parent().offset(e, t).in(this)
            }, image: function (e) {
                return this.parent() && this.parent().image(e)
            }, merge: function () {
                return this.parent() && this.parent().merge.apply(this.parent(), [this].concat(arguments))
            }, gaussianBlur: function (e, t) {
                return this.parent() && this.parent().gaussianBlur(e, t).in(this)
            }, morphology: function (e, t) {
                return this.parent() && this.parent().morphology(e, t).in(this)
            }, diffuseLighting: function (e, t, i) {
                return this.parent() && this.parent().diffuseLighting(e, t, i).in(this)
            }, displacementMap: function (e, t, i, s) {
                return this.parent() && this.parent().displacementMap(this, e, t, i, s)
            }, specularLighting: function (e, t, i, s) {
                return this.parent() && this.parent().specularLighting(e, t, i, s).in(this)
            }, tile: function () {
                return this.parent() && this.parent().tile().in(this)
            }, turbulence: function (e, t, i, s, a) {
                return this.parent() && this.parent().turbulence(e, t, i, s, a).in(this)
            }
        }, e = (SVG.extend(SVG.Effect, e), SVG.extend(SVG.ParentEffect, e), SVG.ChildEffect = SVG.invent({
            create: function () {
                this.constructor.call(this)
            }, inherit: SVG.Element, extend: {
                in: function (e) {
                    this.attr("in", e)
                }
            }
        }), {
            blend: function (e, t, i) {
                this.attr({in: e, in2: t, mode: i || "normal"})
            }, colorMatrix: function (e, t) {
                "matrix" == e && (t = s(t)), this.attr({type: e, values: void 0 === t ? null : t})
            }, convolveMatrix: function (e) {
                e = s(e), this.attr({order: Math.sqrt(e.split(" ").length), kernelMatrix: e})
            }, composite: function (e, t, i) {
                this.attr({in: e, in2: t, operator: i})
            }, flood: function (e, t) {
                this.attr("flood-color", e), null != t && this.attr("flood-opacity", t)
            }, offset: function (e, t) {
                this.attr({dx: e, dy: t})
            }, image: function (e) {
                this.attr("href", e, SVG.xlink)
            }, displacementMap: function (e, t, i, s, a) {
                this.attr({in: e, in2: t, scale: i, xChannelSelector: s, yChannelSelector: a})
            }, gaussianBlur: function (e, t) {
                null != e || null != t ? this.attr("stdDeviation", (e => {
                    if (!Array.isArray(e)) return e;
                    for (var t = 0, i = e.length, s = []; t < i; t++) s.push(e[t]);
                    return s.join(" ")
                })(Array.prototype.slice.call(arguments))) : this.attr("stdDeviation", "0 0")
            }, morphology: function (e, t) {
                this.attr({operator: e, radius: t})
            }, tile: function () {
            }, turbulence: function (e, t, i, s, a) {
                this.attr({numOctaves: t, seed: i, stitchTiles: s, baseFrequency: e, type: a})
            }
        }), t = {
            merge: function () {
                if (arguments[0] instanceof SVG.Set) {
                    var t = this;
                    arguments[0].each(function (e) {
                        this instanceof SVG.MergeNode ? t.put(this) : (this instanceof SVG.Effect || this instanceof SVG.ParentEffect) && t.put(new SVG.MergeNode(this))
                    })
                } else for (var e = Array.isArray(arguments[0]) ? arguments[0] : arguments, i = 0; i < e.length; i++) e[i] instanceof SVG.MergeNode ? this.put(e[i]) : this.put(new SVG.MergeNode(e[i]))
            }, componentTransfer: function (t) {
                if (this.rgb = new SVG.Set, ["r", "g", "b", "a"].forEach(function (e) {
                    this[e] = new SVG["Func" + e.toUpperCase()]("identity"), this.rgb.add(this[e]), this.node.appendChild(this[e].node)
                }.bind(this)), t) for (var e in t.rgb && (["r", "g", "b"].forEach(function (e) {
                    this[e].attr(t.rgb)
                }.bind(this)), delete t.rgb), t) this[e].attr(t[e])
            }, diffuseLighting: function (e, t, i) {
                this.attr({surfaceScale: e, diffuseConstant: t, kernelUnitLength: i})
            }, specularLighting: function (e, t, i, s) {
                this.attr({surfaceScale: e, diffuseConstant: t, specularExponent: i, kernelUnitLength: s})
            }
        }, i = {
            distantLight: function (e, t) {
                this.attr({azimuth: e, elevation: t})
            }, pointLight: function (e, t, i) {
                this.attr({x: e, y: t, z: i})
            }, spotLight: function (e, t, i, s, a, n) {
                this.attr({x: e, y: t, z: i, pointsAtX: s, pointsAtY: a, pointsAtZ: n})
            }, mergeNode: function (e) {
                this.attr("in", e)
            }
        };

        function s(e) {
            return (e = Array.isArray(e) ? new SVG.Array(e) : e).toString().replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/g, " ")
        }

        function a() {
            var e, t = function () {
            };
            for (e in "function" == typeof arguments[arguments.length - 1] && (t = arguments[arguments.length - 1], Array.prototype.splice.call(arguments, arguments.length - 1, 1)), arguments) for (var i in arguments[e]) t(arguments[e][i], i, arguments[e])
        }

        ["r", "g", "b", "a"].forEach(function (e) {
            i["Func" + e.toUpperCase()] = function (e) {
                switch (this.attr("type", e), e) {
                    case"table":
                        this.attr("tableValues", arguments[1]);
                        break;
                    case"linear":
                        this.attr("slope", arguments[1]), this.attr("intercept", arguments[2]);
                        break;
                    case"gamma":
                        this.attr("amplitude", arguments[1]), this.attr("exponent", arguments[2]), this.attr("offset", arguments[2])
                }
            }
        }), a(e, function (e, t) {
            var i = t.charAt(0).toUpperCase() + t.slice(1);
            SVG[i + "Effect"] = SVG.invent({
                create: function () {
                    this.constructor.call(this, SVG.create("fe" + i)), e.apply(this, arguments), this.result(this.attr("id") + "Out")
                }, inherit: SVG.Effect, extend: {}
            })
        }), a(t, function (e, t) {
            var i = t.charAt(0).toUpperCase() + t.slice(1);
            SVG[i + "Effect"] = SVG.invent({
                create: function () {
                    this.constructor.call(this, SVG.create("fe" + i)), e.apply(this, arguments), this.result(this.attr("id") + "Out")
                }, inherit: SVG.ParentEffect, extend: {}
            })
        }), a(i, function (e, t) {
            var i = t.charAt(0).toUpperCase() + t.slice(1);
            SVG[i] = SVG.invent({
                create: function () {
                    this.constructor.call(this, SVG.create("fe" + i)), e.apply(this, arguments)
                }, inherit: SVG.ChildEffect, extend: {}
            })
        }), SVG.extend(SVG.MergeEffect, {
            in: function (e) {
                return e instanceof SVG.MergeNode ? this.add(e, 0) : this.add(new SVG.MergeNode(e), 0), this
            }
        }), SVG.extend(SVG.CompositeEffect, SVG.BlendEffect, SVG.DisplacementMapEffect, {
            in2: function (e) {
                return null == e ? this.parent() && this.parent().select('[result="' + this.attr("in2") + '"]').get(0) || this.attr("in2") : this.attr("in2", e)
            }
        }), SVG.filter = {sepiatone: [.343, .669, .119, 0, 0, .249, .626, .13, 0, 0, .172, .334, .111, 0, 0, 0, 0, 0, 1, 0]}
    }.call(void 0), SVG.extend(SVG.PathArray, {
        morph: function (e) {
            for (var t = this.value, i = this.parse(e), s = 0, a = 0; !1 !== s || !1 !== a;) var n, r = vi(t, !1 !== s && s + 1), o = vi(i, !1 !== a && a + 1), l = (!1 === s && (s = 0 == (n = new SVG.PathArray(l.start).bbox()).height || 0 == n.width ? t.push(t[0]) - 1 : t.push(["M", n.x + n.width / 2, n.y + n.height / 2]) - 1), !1 === a && (a = 0 == (n = new SVG.PathArray(l.dest).bbox()).height || 0 == n.width ? i.push(i[0]) - 1 : i.push(["M", n.x + n.width / 2, n.y + n.height / 2]) - 1), ((e, t, i, s, a, n, r) => {
                for (var o = e.slice(t, i || r), l = s.slice(a, n || r), c = 0, h = {
                    pos: [0, 0],
                    start: [0, 0]
                }, d = {
                    pos: [0, 0],
                    start: [0, 0]
                }; o[c] = xi.call(h, o[c]), l[c] = xi.call(d, l[c]), o[c][0] != l[c][0] || "M" == o[c][0] || "A" == o[c][0] && (o[c][4] != l[c][4] || o[c][5] != l[c][5]) ? (Array.prototype.splice.apply(o, [c, 1].concat(bi.call(h, o[c]))), Array.prototype.splice.apply(l, [c, 1].concat(bi.call(d, l[c])))) : (o[c] = mi.call(h, o[c]), l[c] = mi.call(d, l[c])), ++c != o.length || c != l.length;) c == o.length && o.push(["C", h.pos[0], h.pos[1], h.pos[0], h.pos[1], h.pos[0], h.pos[1]]), c == l.length && l.push(["C", d.pos[0], d.pos[1], d.pos[0], d.pos[1], d.pos[0], d.pos[1]]);
                return {start: o, dest: l}
            })(t, s, r, i, a, o)), t = t.slice(0, s).concat(l.start, !1 === r ? [] : t.slice(r)), i = i.slice(0, a).concat(l.dest, !1 === o ? [] : i.slice(o)), s = !1 !== r && s + l.start.length, a = !1 !== o && a + l.dest.length;
            return this.value = t, this.destination = new SVG.PathArray, this.destination.value = i, this
        }
    }), function () {
        function s(e) {
            e.remember("_draggable", this), this.el = e
        }

        s.prototype.init = function (e, t) {
            var i = this;
            this.constraint = e, this.value = t, this.el.on("mousedown.drag", function (e) {
                i.start(e)
            }), this.el.on("touchstart.drag", function (e) {
                i.start(e)
            })
        }, s.prototype.transformPoint = function (e, t) {
            e = (e = e || window.event).changedTouches && e.changedTouches[0] || e;
            return this.p.x = e.clientX - (t || 0), this.p.y = e.clientY, this.p.matrixTransform(this.m)
        }, s.prototype.getBBox = function () {
            var e = this.el.bbox();
            return this.el instanceof SVG.Nested && (e = this.el.rbox()), (this.el instanceof SVG.G || this.el instanceof SVG.Use || this.el instanceof SVG.Nested) && (e.x = this.el.x(), e.y = this.el.y()), e
        }, s.prototype.start = function (e) {
            if ("click" != e.type && "mousedown" != e.type && "mousemove" != e.type || 1 == (e.which || e.buttons)) {
                var t = this;
                if (this.el.fire("beforedrag", {event: e, handler: this}), !this.el.event().defaultPrevented) {
                    e.preventDefault(), e.stopPropagation(), this.parent = this.parent || this.el.parent(SVG.Nested) || this.el.parent(SVG.Doc), this.p = this.parent.node.createSVGPoint(), this.m = this.el.node.getScreenCTM().inverse();
                    var i, s = this.getBBox();
                    if (this.el instanceof SVG.Text) switch (i = this.el.node.getComputedTextLength(), this.el.attr("text-anchor")) {
                        case"middle":
                            i /= 2;
                            break;
                        case"start":
                            i = 0
                    }
                    this.startPoints = {
                        point: this.transformPoint(e, i),
                        box: s,
                        transform: this.el.transform()
                    }, SVG.on(window, "mousemove.drag", function (e) {
                        t.drag(e)
                    }), SVG.on(window, "touchmove.drag", function (e) {
                        t.drag(e)
                    }), SVG.on(window, "mouseup.drag", function (e) {
                        t.end(e)
                    }), SVG.on(window, "touchend.drag", function (e) {
                        t.end(e)
                    }), this.el.fire("dragstart", {event: e, p: this.startPoints.point, m: this.m, handler: this})
                }
            }
        }, s.prototype.drag = function (e) {
            var t = this.getBBox(), i = this.transformPoint(e),
                s = this.startPoints.box.x + i.x - this.startPoints.point.x,
                a = this.startPoints.box.y + i.y - this.startPoints.point.y, n = this.constraint,
                r = i.x - this.startPoints.point.x, o = i.y - this.startPoints.point.y;
            return this.el.fire("dragmove", {
                event: e,
                p: i,
                m: this.m,
                handler: this
            }), this.el.event().defaultPrevented || ("function" == typeof n ? (!0 === (e = "boolean" == typeof (e = n.call(this.el, s, a, this.m)) ? {
                x: e,
                y: e
            } : e).x ? this.el.x(s) : !1 !== e.x && this.el.x(e.x), !0 === e.y ? this.el.y(a) : !1 !== e.y && this.el.y(e.y)) : "object" == typeof n && (null != n.minX && s < n.minX ? r = (s = n.minX) - this.startPoints.box.x : null != n.maxX && s > n.maxX - t.width && (r = (s = n.maxX - t.width) - this.startPoints.box.x), null != n.minY && a < n.minY ? o = (a = n.minY) - this.startPoints.box.y : null != n.maxY && a > n.maxY - t.height && (o = (a = n.maxY - t.height) - this.startPoints.box.y), null != n.snapToGrid && (s -= s % n.snapToGrid, a -= a % n.snapToGrid, r -= r % n.snapToGrid, o -= o % n.snapToGrid), this.el instanceof SVG.G ? this.el.matrix(this.startPoints.transform).transform({
                x: r,
                y: o
            }, !0) : this.el.move(s, a))), i
        }, s.prototype.end = function (e) {
            var t = this.drag(e);
            this.el.fire("dragend", {
                event: e,
                p: t,
                m: this.m,
                handler: this
            }), SVG.off(window, "mousemove.drag"), SVG.off(window, "touchmove.drag"), SVG.off(window, "mouseup.drag"), SVG.off(window, "touchend.drag")
        }, SVG.extend(SVG.Element, {
            draggable: function (e, t) {
                "function" != typeof e && "object" != typeof e || (t = e, e = !0);
                var i = this.remember("_draggable") || new s(this);
                return (e = void 0 === e || e) ? i.init(t || {}, e) : (this.off("mousedown.drag"), this.off("touchstart.drag")), this
            }
        })
    }.call(void 0), O.prototype.init = function (e, t) {
        var i = this.el.bbox(), s = (this.options = {}, this.el.selectize.defaults.points);
        for (a in this.el.selectize.defaults) this.options[a] = this.el.selectize.defaults[a], void 0 !== t[a] && (this.options[a] = t[a]);
        var a, n = ["points", "pointsExclude"];
        for (a in n) {
            var r = this.options[n[a]];
            "string" == typeof r ? r = 0 < r.length ? r.split(/\s*,\s*/i) : [] : "boolean" == typeof r && "points" === n[a] && (r = r ? s : []), this.options[n[a]] = r
        }
        this.options.points = [s, this.options.points].reduce(function (e, t) {
            return e.filter(function (e) {
                return -1 < t.indexOf(e)
            })
        }), this.options.points = [this.options.points, this.options.pointsExclude].reduce(function (e, t) {
            return e.filter(function (e) {
                return t.indexOf(e) < 0
            })
        }), this.parent = this.el.parent(), this.nested = this.nested || this.parent.group(), this.nested.matrix(new SVG.Matrix(this.el).translate(i.x, i.y)), this.options.deepSelect && -1 !== ["line", "polyline", "polygon"].indexOf(this.el.type) ? this.selectPoints(e) : this.selectRect(e), this.observe(), this.cleanup()
    }, O.prototype.selectPoints = function (e) {
        return this.pointSelection.isSelected = e, this.pointSelection.set || (this.pointSelection.set = this.parent.set(), this.drawPoints()), this
    }, O.prototype.getPointArray = function () {
        var t = this.el.bbox();
        return this.el.array().valueOf().map(function (e) {
            return [e[0] - t.x, e[1] - t.y]
        })
    }, O.prototype.drawPoints = function () {
        for (var a = this, e = this.getPointArray(), t = 0, i = e.length; t < i; ++t) {
            var s = (s => function (e) {
                    (e = e || window.event).preventDefault ? e.preventDefault() : e.returnValue = !1, e.stopPropagation();
                    var t = e.pageX || e.touches[0].pageX, i = e.pageY || e.touches[0].pageY;
                    a.el.fire("point", {x: t, y: i, i: s, event: e})
                })(t),
                s = this.drawPoint(e[t][0], e[t][1]).addClass(this.options.classPoints).addClass(this.options.classPoints + "_point").on("touchstart", s).on("mousedown", s);
            this.pointSelection.set.add(s)
        }
    }, O.prototype.drawPoint = function (e, t) {
        var i = this.options.pointType;
        switch (i) {
            case"circle":
                return this.drawCircle(e, t);
            case"rect":
                return this.drawRect(e, t);
            default:
                if ("function" == typeof i) return i.call(this, e, t);
                throw new Error("Unknown " + i + " point type!")
        }
    }, O.prototype.drawCircle = function (e, t) {
        return this.nested.circle(this.options.pointSize).center(e, t)
    }, O.prototype.drawRect = function (e, t) {
        return this.nested.rect(this.options.pointSize, this.options.pointSize).center(e, t)
    }, O.prototype.updatePointSelection = function () {
        var t = this.getPointArray();
        this.pointSelection.set.each(function (e) {
            this.cx() === t[e][0] && this.cy() === t[e][1] || this.center(t[e][0], t[e][1])
        })
    }, O.prototype.updateRectSelection = function () {
        var e, i = this, s = this.el.bbox();
        this.rectSelection.set.get(0).attr({
            width: s.width,
            height: s.height
        }), this.options.points.length && this.options.points.map(function (e, t) {
            e = i.pointCoords(e, s);
            i.rectSelection.set.get(t + 1).center(e.x, e.y)
        }), this.options.rotationPoint && (e = this.rectSelection.set.length(), this.rectSelection.set.get(e - 1).center(s.width / 2, 20))
    }, O.prototype.selectRect = function (e) {
        var a = this, s = this.el.bbox();

        function n(s) {
            return function (e) {
                (e = e || window.event).preventDefault ? e.preventDefault() : e.returnValue = !1, e.stopPropagation();
                var t = e.pageX || e.touches[0].pageX, i = e.pageY || e.touches[0].pageY;
                a.el.fire(s, {x: t, y: i, event: e})
            }
        }

        this.rectSelection.isSelected = e, this.rectSelection.set = this.rectSelection.set || this.parent.set(), this.rectSelection.set.get(0) || this.rectSelection.set.add(this.nested.rect(s.width, s.height).addClass(this.options.classRect)), this.options.points.length && this.rectSelection.set.length() < 2 && (this.options.points.map(function (e, t) {
            var i = a.pointCoords(e, s),
                i = a.drawPoint(i.x, i.y).attr("class", a.options.classPoints + "_" + e).on("mousedown", n(e)).on("touchstart", n(e));
            a.rectSelection.set.add(i)
        }), this.rectSelection.set.each(function () {
            this.addClass(a.options.classPoints)
        })), this.options.rotationPoint && (this.options.points && !this.rectSelection.set.get(9) || !this.options.points && !this.rectSelection.set.get(1)) && (e = function (e) {
            (e = e || window.event).preventDefault ? e.preventDefault() : e.returnValue = !1, e.stopPropagation();
            var t = e.pageX || e.touches[0].pageX, i = e.pageY || e.touches[0].pageY;
            a.el.fire("rot", {x: t, y: i, event: e})
        }, e = this.drawPoint(s.width / 2, 20).attr("class", this.options.classPoints + "_rot").on("touchstart", e).on("mousedown", e), this.rectSelection.set.add(e))
    }, O.prototype.handler = function () {
        var e = this.el.bbox();
        this.nested.matrix(new SVG.Matrix(this.el).translate(e.x, e.y)), this.rectSelection.isSelected && this.updateRectSelection(), this.pointSelection.isSelected && this.updatePointSelection()
    }, O.prototype.observe = function () {
        var e = this;
        if (MutationObserver) if (this.rectSelection.isSelected || this.pointSelection.isSelected) this.observerInst = this.observerInst || new MutationObserver(function () {
            e.handler()
        }), this.observerInst.observe(this.el.node, {attributes: !0}); else try {
            this.observerInst.disconnect(), delete this.observerInst
        } catch (e) {
        } else this.el.off("DOMAttrModified.select"), (this.rectSelection.isSelected || this.pointSelection.isSelected) && this.el.on("DOMAttrModified.select", function () {
            e.handler()
        })
    }, O.prototype.cleanup = function () {
        !this.rectSelection.isSelected && this.rectSelection.set && (this.rectSelection.set.each(function () {
            this.remove()
        }), this.rectSelection.set.clear(), delete this.rectSelection.set), !this.pointSelection.isSelected && this.pointSelection.set && (this.pointSelection.set.each(function () {
            this.remove()
        }), this.pointSelection.set.clear(), delete this.pointSelection.set), this.pointSelection.isSelected || this.rectSelection.isSelected || (this.nested.remove(), delete this.nested)
    }, SVG.extend(SVG.Element, {
        selectize: function (e, t) {
            return "object" == typeof e && (t = e, e = !0), (this.remember("_selectHandler") || new O(this)).init(void 0 === e || e, t || {}), this
        }
    }), SVG.Element.prototype.selectize.defaults = {
        points: ["lt", "rt", "rb", "lb", "t", "r", "b", "l"],
        pointsExclude: [],
        classRect: "svg_select_boundingRect",
        classPoints: "svg_select_points",
        pointSize: 7,
        rotationPoint: !0,
        deepSelect: !1,
        pointType: "circle"
    }, function () {
        !function () {
            function t(e) {
                e.remember("_resizeHandler", this), this.el = e, this.parameters = {}, this.lastUpdateCall = null, this.p = e.doc().node.createSVGPoint()
            }

            t.prototype.transformPoint = function (e, t, i) {
                return this.p.x = e - (this.offset.x - window.pageXOffset), this.p.y = t - (this.offset.y - window.pageYOffset), this.p.matrixTransform(i || this.m)
            }, t.prototype._extractPosition = function (e) {
                return {
                    x: (null != e.clientX ? e : e.touches[0]).clientX,
                    y: (null != e.clientY ? e : e.touches[0]).clientY
                }
            }, t.prototype.init = function (e) {
                var t = this;
                if (this.stop(), "stop" !== e) {
                    for (var i in this.options = {}, this.el.resize.defaults) this.options[i] = this.el.resize.defaults[i], void 0 !== e[i] && (this.options[i] = e[i]);
                    this.el.on("lt.resize", function (e) {
                        t.resize(e || window.event)
                    }), this.el.on("rt.resize", function (e) {
                        t.resize(e || window.event)
                    }), this.el.on("rb.resize", function (e) {
                        t.resize(e || window.event)
                    }), this.el.on("lb.resize", function (e) {
                        t.resize(e || window.event)
                    }), this.el.on("t.resize", function (e) {
                        t.resize(e || window.event)
                    }), this.el.on("r.resize", function (e) {
                        t.resize(e || window.event)
                    }), this.el.on("b.resize", function (e) {
                        t.resize(e || window.event)
                    }), this.el.on("l.resize", function (e) {
                        t.resize(e || window.event)
                    }), this.el.on("rot.resize", function (e) {
                        t.resize(e || window.event)
                    }), this.el.on("point.resize", function (e) {
                        t.resize(e || window.event)
                    }), this.update()
                }
            }, t.prototype.stop = function () {
                return this.el.off("lt.resize"), this.el.off("rt.resize"), this.el.off("rb.resize"), this.el.off("lb.resize"), this.el.off("t.resize"), this.el.off("r.resize"), this.el.off("b.resize"), this.el.off("l.resize"), this.el.off("rot.resize"), this.el.off("point.resize"), this
            }, t.prototype.resize = function (e) {
                var t = this, i = (this.m = this.el.node.getScreenCTM().inverse(), this.offset = {
                    x: window.pageXOffset,
                    y: window.pageYOffset
                }, this._extractPosition(e.detail.event));
                switch (this.parameters = {
                    type: this.el.type,
                    p: this.transformPoint(i.x, i.y),
                    x: e.detail.x,
                    y: e.detail.y,
                    box: this.el.bbox(),
                    rotation: this.el.transform().rotation
                }, "text" === this.el.type && (this.parameters.fontSize = this.el.attr()["font-size"]), void 0 !== e.detail.i && (i = this.el.array().valueOf(), this.parameters.i = e.detail.i, this.parameters.pointCoords = [i[e.detail.i][0], i[e.detail.i][1]]), e.type) {
                    case"lt":
                        this.calc = function (e, t) {
                            e = this.snapToGrid(e, t);
                            0 < this.parameters.box.width - e[0] && 0 < this.parameters.box.height - e[1] && ("text" === this.parameters.type ? (this.el.move(this.parameters.box.x + e[0], this.parameters.box.y), this.el.attr("font-size", this.parameters.fontSize - e[0])) : (e = this.checkAspectRatio(e), this.el.move(this.parameters.box.x + e[0], this.parameters.box.y + e[1]).size(this.parameters.box.width - e[0], this.parameters.box.height - e[1])))
                        };
                        break;
                    case"rt":
                        this.calc = function (e, t) {
                            e = this.snapToGrid(e, t, 2);
                            0 < this.parameters.box.width + e[0] && 0 < this.parameters.box.height - e[1] && ("text" === this.parameters.type ? (this.el.move(this.parameters.box.x - e[0], this.parameters.box.y), this.el.attr("font-size", this.parameters.fontSize + e[0])) : (e = this.checkAspectRatio(e, !0), this.el.move(this.parameters.box.x, this.parameters.box.y + e[1]).size(this.parameters.box.width + e[0], this.parameters.box.height - e[1])))
                        };
                        break;
                    case"rb":
                        this.calc = function (e, t) {
                            e = this.snapToGrid(e, t, 0);
                            0 < this.parameters.box.width + e[0] && 0 < this.parameters.box.height + e[1] && ("text" === this.parameters.type ? (this.el.move(this.parameters.box.x - e[0], this.parameters.box.y), this.el.attr("font-size", this.parameters.fontSize + e[0])) : (e = this.checkAspectRatio(e), this.el.move(this.parameters.box.x, this.parameters.box.y).size(this.parameters.box.width + e[0], this.parameters.box.height + e[1])))
                        };
                        break;
                    case"lb":
                        this.calc = function (e, t) {
                            e = this.snapToGrid(e, t, 1);
                            0 < this.parameters.box.width - e[0] && 0 < this.parameters.box.height + e[1] && ("text" === this.parameters.type ? (this.el.move(this.parameters.box.x + e[0], this.parameters.box.y), this.el.attr("font-size", this.parameters.fontSize - e[0])) : (e = this.checkAspectRatio(e, !0), this.el.move(this.parameters.box.x + e[0], this.parameters.box.y).size(this.parameters.box.width - e[0], this.parameters.box.height + e[1])))
                        };
                        break;
                    case"t":
                        this.calc = function (e, t) {
                            e = this.snapToGrid(e, t, 2);
                            0 < this.parameters.box.height - e[1] && "text" !== this.parameters.type && this.el.move(this.parameters.box.x, this.parameters.box.y + e[1]).height(this.parameters.box.height - e[1])
                        };
                        break;
                    case"r":
                        this.calc = function (e, t) {
                            e = this.snapToGrid(e, t, 0);
                            0 < this.parameters.box.width + e[0] && "text" !== this.parameters.type && this.el.move(this.parameters.box.x, this.parameters.box.y).width(this.parameters.box.width + e[0])
                        };
                        break;
                    case"b":
                        this.calc = function (e, t) {
                            e = this.snapToGrid(e, t, 0);
                            0 < this.parameters.box.height + e[1] && "text" !== this.parameters.type && this.el.move(this.parameters.box.x, this.parameters.box.y).height(this.parameters.box.height + e[1])
                        };
                        break;
                    case"l":
                        this.calc = function (e, t) {
                            e = this.snapToGrid(e, t, 1);
                            0 < this.parameters.box.width - e[0] && "text" !== this.parameters.type && this.el.move(this.parameters.box.x + e[0], this.parameters.box.y).width(this.parameters.box.width - e[0])
                        };
                        break;
                    case"rot":
                        this.calc = function (e, t) {
                            var e = e + this.parameters.p.x, t = t + this.parameters.p.y,
                                i = Math.atan2(this.parameters.p.y - this.parameters.box.y - this.parameters.box.height / 2, this.parameters.p.x - this.parameters.box.x - this.parameters.box.width / 2),
                                t = Math.atan2(t - this.parameters.box.y - this.parameters.box.height / 2, e - this.parameters.box.x - this.parameters.box.width / 2),
                                e = this.parameters.rotation + 180 * (t - i) / Math.PI + this.options.snapToAngle / 2;
                            this.el.center(this.parameters.box.cx, this.parameters.box.cy).rotate(e - e % this.options.snapToAngle, this.parameters.box.cx, this.parameters.box.cy)
                        };
                        break;
                    case"point":
                        this.calc = function (e, t) {
                            e = this.snapToGrid(e, t, this.parameters.pointCoords[0], this.parameters.pointCoords[1]), t = this.el.array().valueOf();
                            t[this.parameters.i][0] = this.parameters.pointCoords[0] + e[0], t[this.parameters.i][1] = this.parameters.pointCoords[1] + e[1], this.el.plot(t)
                        }
                }
                this.el.fire("resizestart", {
                    dx: this.parameters.x,
                    dy: this.parameters.y,
                    event: e
                }), SVG.on(window, "touchmove.resize", function (e) {
                    t.update(e || window.event)
                }), SVG.on(window, "touchend.resize", function () {
                    t.done()
                }), SVG.on(window, "mousemove.resize", function (e) {
                    t.update(e || window.event)
                }), SVG.on(window, "mouseup.resize", function () {
                    t.done()
                })
            }, t.prototype.update = function (e) {
                var t, i;
                e ? (i = this._extractPosition(e), t = (i = this.transformPoint(i.x, i.y)).x - this.parameters.p.x, i = i.y - this.parameters.p.y, this.lastUpdateCall = [t, i], this.calc(t, i), this.el.fire("resizing", {
                    dx: t,
                    dy: i,
                    event: e
                })) : this.lastUpdateCall && this.calc(this.lastUpdateCall[0], this.lastUpdateCall[1])
            }, t.prototype.done = function () {
                this.lastUpdateCall = null, SVG.off(window, "mousemove.resize"), SVG.off(window, "mouseup.resize"), SVG.off(window, "touchmove.resize"), SVG.off(window, "touchend.resize"), this.el.fire("resizedone")
            }, t.prototype.snapToGrid = function (e, t, i, s) {
                var a = void 0 !== s ? [(i + e) % this.options.snapToGrid, (s + t) % this.options.snapToGrid] : [(this.parameters.box.x + e + (1 & (i = null == i ? 3 : i) ? 0 : this.parameters.box.width)) % this.options.snapToGrid, (this.parameters.box.y + t + (2 & i ? 0 : this.parameters.box.height)) % this.options.snapToGrid];
                return e < 0 && (a[0] -= this.options.snapToGrid), t < 0 && (a[1] -= this.options.snapToGrid), e -= Math.abs(a[0]) < this.options.snapToGrid / 2 ? a[0] : a[0] - (e < 0 ? -this.options.snapToGrid : this.options.snapToGrid), t -= Math.abs(a[1]) < this.options.snapToGrid / 2 ? a[1] : a[1] - (t < 0 ? -this.options.snapToGrid : this.options.snapToGrid), this.constraintToBox(e, t, i, s)
            }, t.prototype.constraintToBox = function (e, t, i, s) {
                var a, n = this.options.constraint || {},
                    s = void 0 !== s ? (a = i, s) : (a = this.parameters.box.x + (1 & i ? 0 : this.parameters.box.width), this.parameters.box.y + (2 & i ? 0 : this.parameters.box.height));
                return void 0 !== n.minX && a + e < n.minX && (e = n.minX - a), void 0 !== n.maxX && a + e > n.maxX && (e = n.maxX - a), void 0 !== n.minY && s + t < n.minY && (t = n.minY - s), [e, t = void 0 !== n.maxY && s + t > n.maxY ? n.maxY - s : t]
            }, t.prototype.checkAspectRatio = function (e, t) {
                var i, s, a, n, r;
                return this.options.saveAspectRatio ? (i = e.slice(), s = this.parameters.box.width / this.parameters.box.height, (r = (a = this.parameters.box.width + e[0]) / (n = this.parameters.box.height - e[1])) < s ? (i[1] = a / s - this.parameters.box.height, t && (i[1] = -i[1])) : s < r && (i[0] = this.parameters.box.width - n * s, t) && (i[0] = -i[0]), i) : e
            }, SVG.extend(SVG.Element, {
                resize: function (e) {
                    return (this.remember("_resizeHandler") || new t(this)).init(e || {}), this
                }
            }), SVG.Element.prototype.resize.defaults = {
                snapToAngle: .1,
                snapToGrid: 1,
                constraint: {},
                saveAspectRatio: !1
            }
        }.call(this)
    }(), void 0 === window.Apex && (window.Apex = {});
    e(Ci, [{
        key: "initModules", value: function () {
            this.ctx.publicMethods = ["updateOptions", "updateSeries", "appendData", "appendSeries", "isSeriesHidden", "highlightSeries", "toggleSeries", "showSeries", "hideSeries", "setLocale", "resetSeries", "zoomX", "toggleDataPointSelection", "dataURI", "exportToCSV", "addXaxisAnnotation", "addYaxisAnnotation", "addPointAnnotation", "clearAnnotations", "removeAnnotation", "paper", "destroy"], this.ctx.eventList = ["click", "mousedown", "mousemove", "mouseleave", "touchstart", "touchmove", "touchleave", "mouseup", "touchend"], this.ctx.animations = new A(this.ctx), this.ctx.axes = new Te(this.ctx), this.ctx.core = new hi(this.ctx.el, this.ctx), this.ctx.config = new p({}), this.ctx.data = new ve(this.ctx), this.ctx.grid = new we(this.ctx), this.ctx.graphics = new Y(this.ctx), this.ctx.coreUtils = new I(this.ctx), this.ctx.crosshairs = new Ee(this.ctx), this.ctx.events = new Se(this.ctx), this.ctx.exports = new ye(this.ctx), this.ctx.fill = new S(this.ctx), this.ctx.localization = new Le(this.ctx), this.ctx.options = new d, this.ctx.responsive = new Pe(this.ctx), this.ctx.series = new T(this.ctx), this.ctx.theme = new _e(this.ctx), this.ctx.formatters = new f(this.ctx), this.ctx.titleSubtitle = new Me(this.ctx), this.ctx.legend = new Fe(this.ctx), this.ctx.toolbar = new He(this.ctx), this.ctx.tooltip = new qe(this.ctx), this.ctx.dimensions = new Xe(this.ctx), this.ctx.updateHelpers = new di(this.ctx), this.ctx.zoomPanSelection = new Re(this.ctx), this.ctx.w.globals.tooltip = new qe(this.ctx)
        }
    }]);
    var yi = Ci, wi = (e(Ai, [{
        key: "clear", value: function (e) {
            e = e.isUpdating;
            this.ctx.zoomPanSelection && this.ctx.zoomPanSelection.destroy(), this.ctx.toolbar && this.ctx.toolbar.destroy(), this.ctx.animations = null, this.ctx.axes = null, this.ctx.annotations = null, this.ctx.core = null, this.ctx.data = null, this.ctx.grid = null, this.ctx.series = null, this.ctx.responsive = null, this.ctx.theme = null, this.ctx.formatters = null, this.ctx.titleSubtitle = null, this.ctx.legend = null, this.ctx.dimensions = null, this.ctx.options = null, this.ctx.crosshairs = null, this.ctx.zoomPanSelection = null, this.ctx.updateHelpers = null, this.ctx.toolbar = null, this.ctx.localization = null, this.ctx.w.globals.tooltip = null, this.clearDomElements({isUpdating: e})
        }
    }, {
        key: "killSVG", value: function (e) {
            e.each(function (e, t) {
                this.removeClass("*"), this.off(), this.stop()
            }, !0), e.ungroup(), e.clear()
        }
    }, {
        key: "clearDomElements", value: function (e) {
            var t = this, e = e.isUpdating, i = this.w.globals.dom.Paper.node,
                s = (i.parentNode && i.parentNode.parentNode && !e && (i.parentNode.parentNode.style.minHeight = "unset"), this.w.globals.dom.baseEl),
                e = (s && this.ctx.eventList.forEach(function (e) {
                    s.removeEventListener(e, t.ctx.events.documentEvent)
                }), this.w.globals.dom);
            if (null !== this.ctx.el) for (; this.ctx.el.firstChild;) this.ctx.el.removeChild(this.ctx.el.firstChild);
            this.killSVG(e.Paper), e.Paper.remove(), e.elWrap = null, e.elGraphical = null, e.elLegendWrap = null, e.elLegendForeign = null, e.baseEl = null, e.elGridRect = null, e.elGridRectMask = null, e.elGridRectMarkerMask = null, e.elForecastMask = null, e.elNonForecastMask = null, e.elDefs = null
        }
    }]), Ai), ki = new WeakMap;

    function Ai(e) {
        s(this, Ai), this.ctx = e, this.w = e.w
    }

    function Ci(e) {
        s(this, Ci), this.ctx = e, this.w = e.w
    }

    function Si(e, t) {
        s(this, Si), this.opts = t, (this.ctx = this).w = new me(t).init(), this.el = e, this.w.globals.cuid = R.randomId(), this.w.globals.chartID = this.w.config.chart.id ? R.escapeString(this.w.config.chart.id) : this.w.globals.cuid, new yi(this).initModules(), this.create = R.bind(this.create, this), this.windowResizeHandler = this._windowResizeHandler.bind(this), this.parentResizeHandler = this._parentResizeCallback.bind(this)
    }

    return e(Si, [{
        key: "render", value: function () {
            var u = this;
            return new Promise(function (e, t) {
                if (null !== u.el) {
                    void 0 === Apex._chartInstances && (Apex._chartInstances = []), u.w.config.chart.id && Apex._chartInstances.push({
                        id: u.w.globals.chartID,
                        group: u.w.config.chart.group,
                        chart: u
                    }), u.setLocale(u.w.config.chart.defaultLocale);
                    var i, s = u.w.config.chart.events.beforeMount,
                        s = ("function" == typeof s && s(u, u.w), u.events.fireEvent("beforeMount", [u, u.w]), window.addEventListener("resize", u.windowResizeHandler), l = u.el.parentNode, c = u.parentResizeHandler, h = !1, l.nodeType !== Node.DOCUMENT_FRAGMENT_NODE && (s = l.getBoundingClientRect(), "none" !== l.style.display && 0 !== s.width || (h = !0)), d = new ResizeObserver(function (e) {
                            h && c.call(l, e), h = !0
                        }), l.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? Array.from(l.children).forEach(function (e) {
                            return d.observe(e)
                        }) : d.observe(l), ki.set(c, d), u.el.getRootNode && u.el.getRootNode()),
                        a = R.is("ShadowRoot", s), n = u.el.ownerDocument,
                        r = (a ? s : n).getElementById("apexcharts-css"),
                        o = (r || ((r = document.createElement("style")).id = "apexcharts-css", r.textContent = '@keyframes opaque {\n  0% {\n    opacity: 0\n  }\n\n  to {\n    opacity: 1\n  }\n}\n\n@keyframes resizeanim {\n\n  0%,\n  to {\n    opacity: 0\n  }\n}\n\n.apexcharts-canvas {\n  position: relative;\n  user-select: none\n}\n\n.apexcharts-canvas ::-webkit-scrollbar {\n  -webkit-appearance: none;\n  width: 6px\n}\n\n.apexcharts-canvas ::-webkit-scrollbar-thumb {\n  border-radius: 4px;\n  background-color: rgba(0, 0, 0, .5);\n  box-shadow: 0 0 1px rgba(255, 255, 255, .5);\n  -webkit-box-shadow: 0 0 1px rgba(255, 255, 255, .5)\n}\n\n.apexcharts-inner {\n  position: relative\n}\n\n.apexcharts-text tspan {\n  font-family: inherit\n}\n\nrect.legend-mouseover-inactive,\n.legend-mouseover-inactive rect,\n.legend-mouseover-inactive path,\n.legend-mouseover-inactive circle,\n.legend-mouseover-inactive line,\n.legend-mouseover-inactive text.apexcharts-yaxis-title-text,\n.legend-mouseover-inactive text.apexcharts-yaxis-label {\n  transition: .15s ease all;\n  opacity: .2\n}\n\n.apexcharts-legend-text {\n  padding-left: 15px;\n  margin-left: -15px;\n}\n\n.apexcharts-series-collapsed {\n  opacity: 0\n}\n\n.apexcharts-tooltip {\n  border-radius: 5px;\n  box-shadow: 2px 2px 6px -4px #999;\n  cursor: default;\n  font-size: 14px;\n  left: 62px;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 20px;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  white-space: nowrap;\n  z-index: 12;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-theme-light {\n  border: 1px solid #e3e3e3;\n  background: rgba(255, 255, 255, .96)\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark {\n  color: #fff;\n  background: rgba(30, 30, 30, .8)\n}\n\n.apexcharts-tooltip * {\n  font-family: inherit\n}\n\n.apexcharts-tooltip-title {\n  padding: 6px;\n  font-size: 15px;\n  margin-bottom: 4px\n}\n\n.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {\n  background: #eceff1;\n  border-bottom: 1px solid #ddd\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {\n  background: rgba(0, 0, 0, .7);\n  border-bottom: 1px solid #333\n}\n\n.apexcharts-tooltip-text-goals-value,\n.apexcharts-tooltip-text-y-value,\n.apexcharts-tooltip-text-z-value {\n  display: inline-block;\n  margin-left: 5px;\n  font-weight: 600\n}\n\n.apexcharts-tooltip-text-goals-label:empty,\n.apexcharts-tooltip-text-goals-value:empty,\n.apexcharts-tooltip-text-y-label:empty,\n.apexcharts-tooltip-text-y-value:empty,\n.apexcharts-tooltip-text-z-value:empty,\n.apexcharts-tooltip-title:empty {\n  display: none\n}\n\n.apexcharts-tooltip-text-goals-label,\n.apexcharts-tooltip-text-goals-value {\n  padding: 6px 0 5px\n}\n\n.apexcharts-tooltip-goals-group,\n.apexcharts-tooltip-text-goals-label,\n.apexcharts-tooltip-text-goals-value {\n  display: flex\n}\n\n.apexcharts-tooltip-text-goals-label:not(:empty),\n.apexcharts-tooltip-text-goals-value:not(:empty) {\n  margin-top: -6px\n}\n\n.apexcharts-tooltip-marker {\n  width: 12px;\n  height: 12px;\n  position: relative;\n  top: 0;\n  margin-right: 10px;\n  border-radius: 50%\n}\n\n.apexcharts-tooltip-series-group {\n  padding: 0 10px;\n  display: none;\n  text-align: left;\n  justify-content: left;\n  align-items: center\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {\n  opacity: 1\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active,\n.apexcharts-tooltip-series-group:last-child {\n  padding-bottom: 4px\n}\n\n.apexcharts-tooltip-y-group {\n  padding: 6px 0 5px\n}\n\n.apexcharts-custom-tooltip,\n.apexcharts-tooltip-box {\n  padding: 4px 8px\n}\n\n.apexcharts-tooltip-boxPlot {\n  display: flex;\n  flex-direction: column-reverse\n}\n\n.apexcharts-tooltip-box>div {\n  margin: 4px 0\n}\n\n.apexcharts-tooltip-box span.value {\n  font-weight: 700\n}\n\n.apexcharts-tooltip-rangebar {\n  padding: 5px 8px\n}\n\n.apexcharts-tooltip-rangebar .category {\n  font-weight: 600;\n  color: #777\n}\n\n.apexcharts-tooltip-rangebar .series-name {\n  font-weight: 700;\n  display: block;\n  margin-bottom: 5px\n}\n\n.apexcharts-xaxistooltip,\n.apexcharts-yaxistooltip {\n  opacity: 0;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #eceff1;\n  border: 1px solid #90a4ae\n}\n\n.apexcharts-xaxistooltip {\n  padding: 9px 10px;\n  transition: .15s ease all\n}\n\n.apexcharts-xaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, .7);\n  border: 1px solid rgba(0, 0, 0, .5);\n  color: #fff\n}\n\n.apexcharts-xaxistooltip:after,\n.apexcharts-xaxistooltip:before {\n  left: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-xaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-left: -6px\n}\n\n.apexcharts-xaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-left: -7px\n}\n\n.apexcharts-xaxistooltip-bottom:after,\n.apexcharts-xaxistooltip-bottom:before {\n  bottom: 100%\n}\n\n.apexcharts-xaxistooltip-top:after,\n.apexcharts-xaxistooltip-top:before {\n  top: 100%\n}\n\n.apexcharts-xaxistooltip-bottom:after {\n  border-bottom-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-bottom:before {\n  border-bottom-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after,\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {\n  border-bottom-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-xaxistooltip-top:after {\n  border-top-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-top:before {\n  border-top-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after,\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {\n  border-top-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-xaxistooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-yaxistooltip {\n  padding: 4px 10px\n}\n\n.apexcharts-yaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, .7);\n  border: 1px solid rgba(0, 0, 0, .5);\n  color: #fff\n}\n\n.apexcharts-yaxistooltip:after,\n.apexcharts-yaxistooltip:before {\n  top: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-yaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-top: -6px\n}\n\n.apexcharts-yaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-top: -7px\n}\n\n.apexcharts-yaxistooltip-left:after,\n.apexcharts-yaxistooltip-left:before {\n  left: 100%\n}\n\n.apexcharts-yaxistooltip-right:after,\n.apexcharts-yaxistooltip-right:before {\n  right: 100%\n}\n\n.apexcharts-yaxistooltip-left:after {\n  border-left-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-left:before {\n  border-left-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after,\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {\n  border-left-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-yaxistooltip-right:after {\n  border-right-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-right:before {\n  border-right-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after,\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {\n  border-right-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-yaxistooltip.apexcharts-active {\n  opacity: 1\n}\n\n.apexcharts-yaxistooltip-hidden {\n  display: none\n}\n\n.apexcharts-xcrosshairs,\n.apexcharts-ycrosshairs {\n  pointer-events: none;\n  opacity: 0;\n  transition: .15s ease all\n}\n\n.apexcharts-xcrosshairs.apexcharts-active,\n.apexcharts-ycrosshairs.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-ycrosshairs-hidden {\n  opacity: 0\n}\n\n.apexcharts-selection-rect {\n  cursor: move\n}\n\n.svg_select_boundingRect,\n.svg_select_points_rot {\n  pointer-events: none;\n  opacity: 0;\n  visibility: hidden\n}\n\n.apexcharts-selection-rect+g .svg_select_boundingRect,\n.apexcharts-selection-rect+g .svg_select_points_rot {\n  opacity: 0;\n  visibility: hidden\n}\n\n.apexcharts-selection-rect+g .svg_select_points_l,\n.apexcharts-selection-rect+g .svg_select_points_r {\n  cursor: ew-resize;\n  opacity: 1;\n  visibility: visible\n}\n\n.svg_select_points {\n  fill: #efefef;\n  stroke: #333;\n  rx: 2\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-zoom {\n  cursor: crosshair\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-pan {\n  cursor: move\n}\n\n.apexcharts-menu-icon,\n.apexcharts-pan-icon,\n.apexcharts-reset-icon,\n.apexcharts-selection-icon,\n.apexcharts-toolbar-custom-icon,\n.apexcharts-zoom-icon,\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon {\n  cursor: pointer;\n  width: 20px;\n  height: 20px;\n  line-height: 24px;\n  color: #6e8192;\n  text-align: center\n}\n\n.apexcharts-menu-icon svg,\n.apexcharts-reset-icon svg,\n.apexcharts-zoom-icon svg,\n.apexcharts-zoomin-icon svg,\n.apexcharts-zoomout-icon svg {\n  fill: #6e8192\n}\n\n.apexcharts-selection-icon svg {\n  fill: #444;\n  transform: scale(.76)\n}\n\n.apexcharts-theme-dark .apexcharts-menu-icon svg,\n.apexcharts-theme-dark .apexcharts-pan-icon svg,\n.apexcharts-theme-dark .apexcharts-reset-icon svg,\n.apexcharts-theme-dark .apexcharts-selection-icon svg,\n.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg,\n.apexcharts-theme-dark .apexcharts-zoom-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomin-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomout-icon svg {\n  fill: #f3f4f5\n}\n\n.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg {\n  fill: #008ffb\n}\n\n.apexcharts-theme-light .apexcharts-menu-icon:hover svg,\n.apexcharts-theme-light .apexcharts-reset-icon:hover svg,\n.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,\n.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg {\n  fill: #333\n}\n\n.apexcharts-menu-icon,\n.apexcharts-selection-icon {\n  position: relative\n}\n\n.apexcharts-reset-icon {\n  margin-left: 5px\n}\n\n.apexcharts-menu-icon,\n.apexcharts-reset-icon,\n.apexcharts-zoom-icon {\n  transform: scale(.85)\n}\n\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon {\n  transform: scale(.7)\n}\n\n.apexcharts-zoomout-icon {\n  margin-right: 3px\n}\n\n.apexcharts-pan-icon {\n  transform: scale(.62);\n  position: relative;\n  left: 1px;\n  top: 0\n}\n\n.apexcharts-pan-icon svg {\n  fill: #fff;\n  stroke: #6e8192;\n  stroke-width: 2\n}\n\n.apexcharts-pan-icon.apexcharts-selected svg {\n  stroke: #008ffb\n}\n\n.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {\n  stroke: #333\n}\n\n.apexcharts-toolbar {\n  position: absolute;\n  z-index: 11;\n  max-width: 176px;\n  text-align: right;\n  border-radius: 3px;\n  padding: 0 6px 2px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center\n}\n\n.apexcharts-menu {\n  background: #fff;\n  position: absolute;\n  top: 100%;\n  border: 1px solid #ddd;\n  border-radius: 3px;\n  padding: 3px;\n  right: 10px;\n  opacity: 0;\n  min-width: 110px;\n  transition: .15s ease all;\n  pointer-events: none\n}\n\n.apexcharts-menu.apexcharts-menu-open {\n  opacity: 1;\n  pointer-events: all;\n  transition: .15s ease all\n}\n\n.apexcharts-menu-item {\n  padding: 6px 7px;\n  font-size: 12px;\n  cursor: pointer\n}\n\n.apexcharts-theme-light .apexcharts-menu-item:hover {\n  background: #eee\n}\n\n.apexcharts-theme-dark .apexcharts-menu {\n  background: rgba(0, 0, 0, .7);\n  color: #fff\n}\n\n@media screen and (min-width:768px) {\n  .apexcharts-canvas:hover .apexcharts-toolbar {\n    opacity: 1\n  }\n}\n\n.apexcharts-canvas .apexcharts-element-hidden,\n.apexcharts-datalabel.apexcharts-element-hidden,\n.apexcharts-hide .apexcharts-series-points {\n  opacity: 0;\n}\n\n.apexcharts-hidden-element-shown {\n  opacity: 1;\n  transition: 0.25s ease all;\n}\n\n.apexcharts-datalabel,\n.apexcharts-datalabel-label,\n.apexcharts-datalabel-value,\n.apexcharts-datalabels,\n.apexcharts-pie-label {\n  cursor: default;\n  pointer-events: none\n}\n\n.apexcharts-pie-label-delay {\n  opacity: 0;\n  animation-name: opaque;\n  animation-duration: .3s;\n  animation-fill-mode: forwards;\n  animation-timing-function: ease\n}\n\n.apexcharts-radialbar-label {\n  cursor: pointer;\n}\n\n.apexcharts-annotation-rect,\n.apexcharts-area-series .apexcharts-area,\n.apexcharts-area-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,\n.apexcharts-gridline,\n.apexcharts-line,\n.apexcharts-line-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,\n.apexcharts-point-annotation-label,\n.apexcharts-radar-series path:not(.apexcharts-marker),\n.apexcharts-radar-series polygon,\n.apexcharts-toolbar svg,\n.apexcharts-tooltip .apexcharts-marker,\n.apexcharts-xaxis-annotation-label,\n.apexcharts-yaxis-annotation-label,\n.apexcharts-zoom-rect {\n  pointer-events: none\n}\n\n.apexcharts-tooltip-active .apexcharts-marker {\n  transition: .15s ease all\n}\n\n.resize-triggers {\n  animation: 1ms resizeanim;\n  visibility: hidden;\n  opacity: 0;\n  height: 100%;\n  width: 100%;\n  overflow: hidden\n}\n\n.contract-trigger:before,\n.resize-triggers,\n.resize-triggers>div {\n  content: " ";\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0\n}\n\n.resize-triggers>div {\n  height: 100%;\n  width: 100%;\n  background: #eee;\n  overflow: auto\n}\n\n.contract-trigger:before {\n  overflow: hidden;\n  width: 200%;\n  height: 200%\n}\n\n.apexcharts-bar-goals-markers {\n  pointer-events: none\n}\n\n.apexcharts-bar-shadows {\n  pointer-events: none\n}\n\n.apexcharts-rangebar-goals-markers {\n  pointer-events: none\n}', (i = (null == (i = u.opts.chart) ? void 0 : i.nonce) || u.w.config.chart.nonce) && r.setAttribute("nonce", i), a ? s.prepend(r) : n.head.appendChild(r)), u.create(u.w.config.series, {}));
                    if (!o) return e(u);
                    u.mount(o).then(function () {
                        "function" == typeof u.w.config.chart.events.mounted && u.w.config.chart.events.mounted(u, u.w), u.events.fireEvent("mounted", [u, u.w]), e(o)
                    }).catch(function (e) {
                        t(e)
                    })
                } else t(new Error("Element not found"));
                var l, c, h, d
            })
        }
    }, {
        key: "create", value: function (e, t) {
            var i, s = this, a = this.w, n = (new yi(this).initModules(), this.w.globals);
            return n.noData = !1, n.animationEnded = !1, this.responsive.checkResponsiveConfig(t), a.config.xaxis.convertedCatToNumeric && new o(a.config).convertCatToNumericXaxis(a.config, this.ctx), null === this.el || (this.core.setupElements(), "treemap" === a.config.chart.type && (a.config.grid.show = !1, a.config.yaxis[0].show = !1), 0 === n.svgWidth) ? (n.animationEnded = !0, null) : ((i = e).forEach(function (e, t) {
                e.hidden && (i = s.legend.legendHelpers.getSeriesAfterCollapsing({realIndex: t}))
            }), t = I.checkComboSeries(i, a.config.chart.type), n.comboCharts = t.comboCharts, n.comboBarCount = t.comboBarCount, e = i.every(function (e) {
                return e.data && 0 === e.data.length
            }), (0 === i.length || e && n.collapsedSeries.length < 1) && this.series.handleNoData(), this.events.setupEventHandlers(), this.data.parseData(i), this.theme.init(), new k(this).setGlobalMarkerSize(), this.formatters.setLabelFormatters(), this.titleSubtitle.draw(), n.noData && n.collapsedSeries.length !== n.series.length && !a.config.legend.showForSingleSeries || this.legend.init(), this.series.hasAllSeriesEqualX(), n.axisCharts && (this.core.coreCalculations(), "category" !== a.config.xaxis.type && this.formatters.setLabelFormatters(), this.ctx.toolbar.minX = a.globals.minX, this.ctx.toolbar.maxX = a.globals.maxX), this.formatters.heatmapLabelFormatters(), new I(this).getLargestMarkerSize(), this.dimensions.plotCoords(), t = this.core.xySettings(), this.grid.createGridMask(), e = this.core.plotChartType(i, t), (n = new L(this)).bringForward(), a.config.dataLabels.background.enabled && n.dataLabelsBackground(), this.core.shiftGraphPosition(), {
                elGraph: e,
                xyRatios: t,
                dimensions: {
                    plot: {
                        left: a.globals.translateX,
                        top: a.globals.translateY,
                        width: a.globals.gridWidth,
                        height: a.globals.gridHeight
                    }
                }
            })
        }
    }, {
        key: "mount", value: function () {
            var r = this, o = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : null, l = this, c = l.w;
            return new Promise(function (e, t) {
                if (null === l.el) return t(new Error("Not enough data to display or target element not found"));
                null !== o && !c.globals.allSeriesCollapsed || l.series.handleNoData(), l.grid = new we(l);
                t = l.grid.drawGrid();
                if (l.annotations = new fe(l), l.annotations.drawImageAnnos(), l.annotations.drawTextAnnos(), "back" === c.config.grid.position && (t && c.globals.dom.elGraphical.add(t.el), null != t) && null != (a = t.elGridBorders) && a.node && c.globals.dom.elGraphical.add(t.elGridBorders), Array.isArray(o.elGraph)) for (var i = 0; i < o.elGraph.length; i++) c.globals.dom.elGraphical.add(o.elGraph[i]); else c.globals.dom.elGraphical.add(o.elGraph);
                "front" === c.config.grid.position && (t && c.globals.dom.elGraphical.add(t.el), null != t) && null != (a = t.elGridBorders) && a.node && c.globals.dom.elGraphical.add(t.elGridBorders), "front" === c.config.xaxis.crosshairs.position && l.crosshairs.drawXCrosshairs(), "front" === c.config.yaxis[0].crosshairs.position && l.crosshairs.drawYCrosshairs(), "treemap" !== c.config.chart.type && l.axes.drawAxis(c.config.chart.type, t);
                var s, a = new g(r.ctx, t), n = new Ce(r.ctx, t);
                null !== t && (a.xAxisLabelCorrections(t.xAxisTickWidth), n.setYAxisTextAlignments(), c.config.yaxis.map(function (e, t) {
                    -1 === c.globals.ignoreYAxisIndexes.indexOf(t) && n.yAxisTitleRotate(t, e.opposite)
                })), l.annotations.drawAxesAnnotations(), c.globals.noData || (c.config.tooltip.enabled && !c.globals.noData && l.w.globals.tooltip.drawTooltip(o.xyRatios), c.globals.axisCharts && (c.globals.isXNumeric || c.config.xaxis.convertedCatToNumeric || c.globals.isRangeBar) ? (c.config.chart.zoom.enabled || c.config.chart.selection && c.config.chart.selection.enabled || c.config.chart.pan && c.config.chart.pan.enabled) && l.zoomPanSelection.init({xyRatios: o.xyRatios}) : (s = c.config.chart.toolbar.tools, ["zoom", "zoomin", "zoomout", "selection", "pan", "reset"].forEach(function (e) {
                    s[e] = !1
                })), c.config.chart.toolbar.show && !c.globals.allSeriesCollapsed && l.toolbar.createToolbar()), 0 < c.globals.memory.methodsToExec.length && c.globals.memory.methodsToExec.forEach(function (e) {
                    e.method(e.params, !1, e.context)
                }), c.globals.axisCharts || c.globals.noData || l.core.resizeNonAxisCharts(), e(l)
            })
        }
    }, {
        key: "destroy", value: function () {
            window.removeEventListener("resize", this.windowResizeHandler), this.el.parentNode, e = this.parentResizeHandler, (t = ki.get(e)) && (t.disconnect(), ki.delete(e));
            var e, t, i = this.w.config.chart.id;
            i && Apex._chartInstances.forEach(function (e, t) {
                e.id === R.escapeString(i) && Apex._chartInstances.splice(t, 1)
            }), new wi(this.ctx).clear({isUpdating: !1})
        }
    }, {
        key: "updateOptions", value: function (e) {
            var i = this, t = 1 < arguments.length && void 0 !== arguments[1] && arguments[1],
                s = !(2 < arguments.length && void 0 !== arguments[2]) || arguments[2],
                a = !(3 < arguments.length && void 0 !== arguments[3]) || arguments[3],
                n = !(4 < arguments.length && void 0 !== arguments[4]) || arguments[4], r = this.w;
            return r.globals.selection = void 0, e.series && (this.series.resetSeries(!1, !0, !1), e.series.length && e.series[0].data && (e.series = e.series.map(function (e, t) {
                return i.updateHelpers._extendSeries(e, t)
            })), this.updateHelpers.revertDefaultAxisMinMax()), (e = e.xaxis ? this.updateHelpers.forceXAxisUpdate(e) : e).yaxis && (e = this.updateHelpers.forceYAxisUpdate(e)), 0 < r.globals.collapsedSeriesIndices.length && this.series.clearPreviousPaths(), e.theme && (e = this.theme.updateThemeOptions(e)), this.updateHelpers._updateOptions(e, t, s, a, n)
        }
    }, {
        key: "updateSeries", value: function () {
            var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : [],
                t = !(1 < arguments.length && void 0 !== arguments[1]) || arguments[1],
                i = !(2 < arguments.length && void 0 !== arguments[2]) || arguments[2];
            return this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(e, t, i)
        }
    }, {
        key: "appendSeries", value: function (e) {
            var t = !(1 < arguments.length && void 0 !== arguments[1]) || arguments[1],
                i = !(2 < arguments.length && void 0 !== arguments[2]) || arguments[2],
                s = this.w.config.series.slice();
            return s.push(e), this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(s, t, i)
        }
    }, {
        key: "appendData", value: function (e) {
            var t = !(1 < arguments.length && void 0 !== arguments[1]) || arguments[1];
            this.w.globals.dataChanged = !0, this.series.getPreviousPaths();
            for (var i = this.w.config.series.slice(), s = 0; s < i.length; s++) if (null != e[s]) for (var a = 0; a < e[s].data.length; a++) i[s].data.push(e[s].data[a]);
            return this.w.config.series = i, t && (this.w.globals.initialSeries = R.clone(this.w.config.series)), this.update()
        }
    }, {
        key: "update", value: function (s) {
            var a = this;
            return new Promise(function (e, t) {
                new wi(a.ctx).clear({isUpdating: !0});
                var i = a.create(a.w.config.series, s);
                if (!i) return e(a);
                a.mount(i).then(function () {
                    "function" == typeof a.w.config.chart.events.updated && a.w.config.chart.events.updated(a, a.w), a.events.fireEvent("updated", [a, a.w]), a.w.globals.isDirty = !0, e(a)
                }).catch(function (e) {
                    t(e)
                })
            })
        }
    }, {
        key: "getSyncedCharts", value: function () {
            var e = this.getGroupedCharts(), t = [this];
            return e.length && (t = [], e.forEach(function (e) {
                t.push(e)
            })), t
        }
    }, {
        key: "getGroupedCharts", value: function () {
            var t = this;
            return Apex._chartInstances.filter(function (e) {
                if (e.group) return !0
            }).map(function (e) {
                return t.w.config.chart.group === e.group ? e.chart : t
            })
        }
    }, {
        key: "toggleSeries", value: function (e) {
            return this.series.toggleSeries(e)
        }
    }, {
        key: "highlightSeriesOnLegendHover", value: function (e, t) {
            return this.series.toggleSeriesOnHover(e, t)
        }
    }, {
        key: "showSeries", value: function (e) {
            this.series.showSeries(e)
        }
    }, {
        key: "hideSeries", value: function (e) {
            this.series.hideSeries(e)
        }
    }, {
        key: "highlightSeries", value: function (e) {
            this.series.highlightSeries(e)
        }
    }, {
        key: "isSeriesHidden", value: function (e) {
            this.series.isSeriesHidden(e)
        }
    }, {
        key: "resetSeries", value: function () {
            this.series.resetSeries(!(0 < arguments.length && void 0 !== arguments[0]) || arguments[0], !(1 < arguments.length && void 0 !== arguments[1]) || arguments[1])
        }
    }, {
        key: "addEventListener", value: function (e, t) {
            this.events.addEventListener(e, t)
        }
    }, {
        key: "removeEventListener", value: function (e, t) {
            this.events.removeEventListener(e, t)
        }
    }, {
        key: "addXaxisAnnotation", value: function (e) {
            var t = !(1 < arguments.length && void 0 !== arguments[1]) || arguments[1],
                i = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : void 0, i = i ? i : this;
            i.annotations.addXaxisAnnotationExternal(e, t, i)
        }
    }, {
        key: "addYaxisAnnotation", value: function (e) {
            var t = !(1 < arguments.length && void 0 !== arguments[1]) || arguments[1],
                i = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : void 0, i = i ? i : this;
            i.annotations.addYaxisAnnotationExternal(e, t, i)
        }
    }, {
        key: "addPointAnnotation", value: function (e) {
            var t = !(1 < arguments.length && void 0 !== arguments[1]) || arguments[1],
                i = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : void 0, i = i ? i : this;
            i.annotations.addPointAnnotationExternal(e, t, i)
        }
    }, {
        key: "clearAnnotations", value: function () {
            var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : void 0, e = e ? e : this;
            e.annotations.clearAnnotations(e)
        }
    }, {
        key: "removeAnnotation", value: function (e) {
            var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : void 0, t = t ? t : this;
            t.annotations.removeAnnotation(t, e)
        }
    }, {
        key: "getChartArea", value: function () {
            return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner")
        }
    }, {
        key: "getSeriesTotalXRange", value: function (e, t) {
            return this.coreUtils.getSeriesTotalsXRange(e, t)
        }
    }, {
        key: "getHighestValueInSeries", value: function () {
            var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0;
            return new Ae(this.ctx).getMinYMaxY(e).highestY
        }
    }, {
        key: "getLowestValueInSeries", value: function () {
            var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 0;
            return new Ae(this.ctx).getMinYMaxY(e).lowestY
        }
    }, {
        key: "getSeriesTotal", value: function () {
            return this.w.globals.seriesTotals
        }
    }, {
        key: "toggleDataPointSelection", value: function (e, t) {
            return this.updateHelpers.toggleDataPointSelection(e, t)
        }
    }, {
        key: "zoomX", value: function (e, t) {
            this.ctx.toolbar.zoomUpdateOptions(e, t)
        }
    }, {
        key: "setLocale", value: function (e) {
            this.localization.setCurrentLocaleValues(e)
        }
    }, {
        key: "dataURI", value: function (e) {
            return new ye(this.ctx).dataURI(e)
        }
    }, {
        key: "exportToCSV", value: function () {
            var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
            return new ye(this.ctx).exportToCSV(e)
        }
    }, {
        key: "paper", value: function () {
            return this.w.globals.dom.Paper
        }
    }, {
        key: "_parentResizeCallback", value: function () {
            this.w.globals.animationEnded && this.w.config.chart.redrawOnParentResize && this._windowResize()
        }
    }, {
        key: "_windowResize", value: function () {
            var e = this;
            clearTimeout(this.w.globals.resizeTimer), this.w.globals.resizeTimer = window.setTimeout(function () {
                e.w.globals.resized = !0, e.w.globals.dataChanged = !1, e.ctx.update()
            }, 150)
        }
    }, {
        key: "_windowResizeHandler", value: function () {
            var e = this.w.config.chart.redrawOnWindowResize;
            (e = "function" == typeof e ? e() : e) && this._windowResize()
        }
    }], [{
        key: "getChartByID", value: function (e) {
            var t = R.escapeString(e);
            if (Apex._chartInstances) return (e = Apex._chartInstances.filter(function (e) {
                return e.id === t
            })[0]) && e.chart
        }
    }, {
        key: "initOnLoad", value: function () {
            for (var e = document.querySelectorAll("[data-apexcharts]"), t = 0; t < e.length; t++) new Si(e[t], JSON.parse(e[t].getAttribute("data-options"))).render()
        }
    }, {
        key: "exec", value: function (e, t) {
            e = this.getChartByID(e);
            if (e) {
                e.w.globals.isExecCalled = !0;
                var i = null;
                if (-1 !== e.publicMethods.indexOf(t)) {
                    for (var s = arguments.length, a = new Array(2 < s ? s - 2 : 0), n = 2; n < s; n++) a[n - 2] = arguments[n];
                    i = e[t].apply(e, a)
                }
                return i
            }
        }
    }, {
        key: "merge", value: function (e, t) {
            return R.extend(e, t)
        }
    }]), Si
}), ((e, t) => {
    "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.PureCounter = t() : e.PureCounter = t()
})(self, function () {
    return i = {
        3: function (e, t, i) {
            function a(e) {
                return (e => {
                    if (Array.isArray(e)) return s(e)
                })(e) || (() => {
                    if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e)
                })() || (e => {
                    var t;
                    if (e) return "string" == typeof e ? s(e, void 0) : "Map" === (t = "Object" === (t = Object.prototype.toString.call(e).slice(8, -1)) && e.constructor ? e.constructor.name : t) || "Set" === t ? Array.from(e) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? s(e, void 0) : void 0
                })(e) || (() => {
                    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                })()
            }

            function s(e, t) {
                (null == t || t > e.length) && (t = e.length);
                for (var i = 0, s = new Array(t); i < t; i++) s[i] = e[i];
                return s
            }

            function n(e, t) {
                for (var i = 0; i < t.length; i++) {
                    var s = t[i];
                    s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(e, s.key, s)
                }
            }

            i.d(t, {
                Z: function () {
                    return r
                }
            });
            n((i = o).prototype, [{
                key: "setOptions", value: function (e) {
                    var t, i, s = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}, a = {};
                    for (t in e) (0 === Object.keys(s).length || s.hasOwnProperty(t)) && (i = this.parseValue(e[t]), a[t] = i, t.match(/duration|pulse/)) && (a[t] = "boolean" != typeof i ? 1e3 * i : i);
                    return Object.assign({}, s, a)
                }
            }, {
                key: "registerEventListeners", value: function () {
                    var t, i = this.elements;
                    0 !== i.length && (this.intersectionSupport ? (t = new IntersectionObserver(this.animateElements.bind(this), {
                        root: null,
                        rootMargin: "20px",
                        threshold: .5
                    }), i.forEach(function (e) {
                        t.observe(e)
                    })) : window.addEventListener && (this.animateLegacy(i), window.addEventListener("scroll", function (e) {
                        this.animateLegacy(i)
                    }, {passive: !0})))
                }
            }, {
                key: "animateLegacy", value: function (e) {
                    var t = this;
                    e.forEach(function (e) {
                        !0 === t.parseConfig(e).legacy && t.elementIsInView(e) && t.animateElements([e])
                    })
                }
            }, {
                key: "animateElements", value: function (e, s) {
                    var a = this;
                    e.forEach(function (e) {
                        var t = e.target || e, i = a.parseConfig(t);
                        return i.duration <= 0 ? t.innerHTML = a.formatNumber(i.end, i) : !s && !a.elementIsInView(e) || s && e.intersectionRatio < .5 ? (e = i.start > i.end ? i.end : i.start, t.innerHTML = a.formatNumber(e, i)) : void setTimeout(function () {
                            return a.startCounter(t, i)
                        }, i.delay)
                    })
                }
            }, {
                key: "startCounter", value: function (t, i) {
                    var s = this, a = (i.end - i.start) / (i.duration / i.delay), n = "inc",
                        r = (i.end < i.start && (n = "dec", a *= -1), this.parseValue(i.start)),
                        o = (t.innerHTML = this.formatNumber(r, i), !0 === i.once && t.setAttribute("data-purecounter-duration", 0), setInterval(function () {
                            var e = s.nextNumber(r, a, n);
                            t.innerHTML = s.formatNumber(e, i), ((r = e) >= i.end && "inc" === n || r <= i.end && "dec" === n) && (t.innerHTML = s.formatNumber(i.end, i), i.pulse && (t.setAttribute("data-purecounter-duration", 0), setTimeout(function () {
                                t.setAttribute("data-purecounter-duration", i.duration / 1e3)
                            }, i.pulse)), clearInterval(o))
                        }, i.delay))
                }
            }, {
                key: "parseConfig", value: function (e) {
                    var s = this, e = [].filter.call(e.attributes, function (e) {
                        return /^data-purecounter-/.test(e.name)
                    }), e = 0 != e.length ? Object.assign.apply(Object, [{}].concat(a(e.map(function (e) {
                        var t, i = e.name, e = e.value;
                        return t = {}, i = i.replace("data-purecounter-", "").toLowerCase(), e = s.parseValue(e), i in t ? Object.defineProperty(t, i, {
                            value: e,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : t[i] = e, t
                    })))) : {};
                    return this.setOptions(e, this.configOptions)
                }
            }, {
                key: "nextNumber", value: function (e, t) {
                    var i = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : "inc";
                    return e = this.parseValue(e), t = this.parseValue(t), parseFloat("inc" === i ? e + t : e - t)
                }
            }, {
                key: "convertNumber", value: function (e, t) {
                    if (t.filesizing || t.currency) {
                        e = Math.abs(Number(e));
                        var i = 1e3, s = t.currency && "string" == typeof t.currency ? t.currency : "",
                            a = t.decimals || 1, n = ["", "K", "M", "B", "T"], r = "";
                        t.filesizing && (i = 1024, n = ["bytes", "KB", "MB", "GB", "TB"]);
                        for (var o = 4; 0 <= o; o--) if (0 === o && (r = "".concat(e.toFixed(a), " ").concat(n[o])), e >= this.getFilesizeThreshold(i, o)) {
                            r = "".concat((e / this.getFilesizeThreshold(i, o)).toFixed(a), " ").concat(n[o]);
                            break
                        }
                        return s + r
                    }
                    return parseFloat(e)
                }
            }, {
                key: "getFilesizeThreshold", value: function (e, t) {
                    return Math.pow(e, t)
                }
            }, {
                key: "applySeparator", value: function (e, t) {
                    var i, o;
                    return !t.formater || (i = t.separator ? "string" == typeof t.separator ? t.separator : "," : "", "en-US" !== t.formater && !0 === t.separator) ? e : (o = i, e.replace(/^(?:(\d{1,3},(?:\d{1,3},?)*)|(\d{1,3}\.(?:\d{1,3}\.?)*)|(\d{1,3}(?:\s\d{1,3})*))([\.,]?\d{0,2}?)$/gi, function (e, t, i, s, a) {
                        var n = "", r = "";
                        return void 0 !== t ? (n = t.replace(new RegExp(/,/gi, "gi"), o), r = ",") : void 0 !== i ? n = i.replace(new RegExp(/\./gi, "gi"), o) : void 0 !== s && (n = s.replace(new RegExp(/ /gi, "gi"), o)), void 0 !== a && (t = "," !== r && "," !== o ? "," : ".", n += a.replace(new RegExp(/\.|,/gi, "gi"), t)), n
                    }))
                }
            }, {
                key: "formatNumber", value: function (e, t) {
                    var i = {minimumFractionDigits: t.decimals, maximumFractionDigits: t.decimals},
                        s = "string" == typeof t.formater ? t.formater : void 0;
                    return e = this.convertNumber(e, t), e = t.formater ? e.toLocaleString(s, i) : parseInt(e).toString(), this.applySeparator(e, t)
                }
            }, {
                key: "getLocaleSeparator", value: function () {
                }
            }, {
                key: "parseValue", value: function (e) {
                    return /^[0-9]+\.[0-9]+$/.test(e) ? parseFloat(e) : /^[0-9]+$/.test(e) ? parseInt(e) : /^true|false/i.test(e) ? /^true/i.test(e) : e
                }
            }, {
                key: "elementIsInView", value: function (e) {
                    for (var t = e.offsetTop, i = e.offsetLeft, s = e.offsetWidth, a = e.offsetHeight; e.offsetParent;) t += (e = e.offsetParent).offsetTop, i += e.offsetLeft;
                    return t >= window.pageYOffset && i >= window.pageXOffset && t + a <= window.pageYOffset + window.innerHeight && i + s <= window.pageXOffset + window.innerWidth
                }
            }, {
                key: "intersectionListenerSupported", value: function () {
                    return "IntersectionObserver" in window && "IntersectionObserverEntry" in window && "intersectionRatio" in window.IntersectionObserverEntry.prototype
                }
            }]), Object.defineProperty(i, "prototype", {writable: !1});
            var r = o;

            function o() {
                var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {}, t = this, i = o;
                if (!(t instanceof i)) throw new TypeError("Cannot call a class as a function");
                this.defaults = {
                    start: 0,
                    end: 100,
                    duration: 2e3,
                    delay: 10,
                    once: !0,
                    pulse: !1,
                    decimals: 0,
                    legacy: !0,
                    filesizing: !1,
                    currency: !1,
                    separator: !1,
                    formater: "us-US",
                    selector: ".purecounter"
                }, this.configOptions = this.setOptions(e, this.defaults), this.elements = document.querySelectorAll(this.configOptions.selector), this.intersectionSupport = this.intersectionListenerSupported(), this.registerEventListeners()
            }
        }, 634: function (e, t, i) {
            i = i(3).Z;
            e.exports = i
        }
    }, a = {}, s.d = function (e, t) {
        for (var i in t) s.o(t, i) && !s.o(e, i) && Object.defineProperty(e, i, {enumerable: !0, get: t[i]})
    }, s.o = function (e, t) {
        return Object.prototype.hasOwnProperty.call(e, t)
    }, s(634);

    function s(e) {
        var t = a[e];
        return void 0 !== t || (t = a[e] = {exports: {}}, i[e](t, t.exports, s)), t.exports
    }

    var i, a
});